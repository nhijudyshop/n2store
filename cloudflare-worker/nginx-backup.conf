# =====================================================
# NGINX BACKUP CONFIGURATION FOR CLOUDFLARE WORKER
# 
# This configuration replicates all functionality from worker.js
# Use as a backup when Cloudflare is unavailable
# 
# Requirements:
# - Nginx with ngx_http_proxy_module
# - OpenResty (for Lua scripting) OR nginx-plus with JavaScript module
# - ngx_http_lua_module (for token caching and complex logic)
# 
# Deploy: Copy to /etc/nginx/sites-available/ and link to sites-enabled
# =====================================================

# Upstream servers
upstream tpos_backend {
    server tomato.tpos.vn:443;
    keepalive 32;
}

upstream pancake_backend {
    server pancake.vn:443;
    keepalive 32;
}

upstream pages_fm_backend {
    server pages.fm:443;
    keepalive 32;
}

upstream facebook_graph_backend {
    server graph.facebook.com:443;
    keepalive 32;
}

upstream render_backend {
    server n2store-fallback.onrender.com:443;
    keepalive 32;
}

upstream pancake_content_backend {
    server content.pancake.vn:443;
    keepalive 32;
}

# Shared Lua dictionary for token caching (5 minutes buffer)
lua_shared_dict token_cache 1m;

server {
    listen 80;
    listen 443 ssl http2;
    server_name n2store-api.yourdomain.com;  # Change to your domain

    # SSL Configuration (uncomment and configure for production)
    # ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    # ssl_protocols TLSv1.2 TLSv1.3;
    # ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    # ssl_prefer_server_ciphers off;

    # Logging
    access_log /var/log/nginx/n2store-api-access.log;
    error_log /var/log/nginx/n2store-api-error.log;

    # Default CORS headers
    set $cors_origin '*';
    set $cors_methods 'GET, POST, PUT, DELETE, OPTIONS';
    set $cors_headers 'Content-Type, Authorization, Accept, X-Auth-Data, X-User-Id, tposappversion, x-tpos-lang';

    # ========== CORS PREFLIGHT ==========
    if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Origin' $cors_origin always;
        add_header 'Access-Control-Allow-Methods' $cors_methods always;
        add_header 'Access-Control-Allow-Headers' $cors_headers always;
        add_header 'Access-Control-Max-Age' 86400 always;
        add_header 'Content-Type' 'text/plain charset=UTF-8';
        add_header 'Content-Length' 0;
        return 204;
    }

    # ========== TOKEN ENDPOINT WITH CACHING ==========
    # POST /api/token
    location = /api/token {
        # Only allow POST
        if ($request_method != POST) {
            return 405;
        }

        content_by_lua_block {
            local cjson = require "cjson"
            local token_cache = ngx.shared.token_cache
            
            -- Check cache first (with 5-minute buffer)
            local cached = token_cache:get("tpos_token")
            local expiry = token_cache:get("tpos_expiry")
            
            if cached and expiry then
                local now = ngx.now() * 1000
                local buffer = 5 * 60 * 1000  -- 5 minutes
                
                if now < (expiry - buffer) then
                    -- Return cached token
                    local remaining = math.floor((expiry - now) / 1000)
                    local response = {
                        access_token = cached,
                        expires_in = remaining,
                        token_type = token_cache:get("tpos_token_type") or "Bearer"
                    }
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Access-Control-Allow-Origin"] = "*"
                    ngx.say(cjson.encode(response))
                    return
                end
            end
            
            -- Cache miss - fetch from TPOS
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            
            local http = require "resty.http"
            local httpc = http.new()
            
            local res, err = httpc:request_uri("https://tomato.tpos.vn/token", {
                method = "POST",
                body = body,
                headers = {
                    ["Content-Type"] = ngx.var.content_type or "application/x-www-form-urlencoded",
                    ["Origin"] = "https://tomato.tpos.vn/",
                    ["Referer"] = "https://tomato.tpos.vn/",
                },
                ssl_verify = false
            })
            
            if not res then
                ngx.status = 500
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({error = "Failed to fetch token", message = err}))
                return
            end
            
            if res.status ~= 200 then
                ngx.status = res.status
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(res.body)
                return
            end
            
            -- Parse and cache token
            local ok, token_data = pcall(cjson.decode, res.body)
            if ok and token_data.access_token then
                local expires_in = token_data.expires_in or 3600
                local expiry_time = ngx.now() * 1000 + (expires_in * 1000)
                
                token_cache:set("tpos_token", token_data.access_token, expires_in)
                token_cache:set("tpos_expiry", expiry_time, expires_in)
                token_cache:set("tpos_token_type", token_data.token_type or "Bearer", expires_in)
            end
            
            ngx.header["Content-Type"] = "application/json"
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.say(res.body)
        }
    }

    # ========== IMAGE PROXY ENDPOINT ==========
    # GET /api/image-proxy?url=<encoded_url>
    location = /api/image-proxy {
        set $image_url "";
        
        if ($arg_url = "") {
            return 400 '{"error": "Missing url parameter", "usage": "/api/image-proxy?url=<encoded_url>"}';
        }
        
        set_by_lua_block $image_url {
            return ngx.unescape_uri(ngx.var.arg_url)
        }
        
        # Internal redirect to proxy
        rewrite ^ /internal_image_proxy last;
    }
    
    location = /internal_image_proxy {
        internal;
        
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            
            local url = ngx.unescape_uri(ngx.var.arg_url)
            
            local res, err = httpc:request_uri(url, {
                method = "GET",
                headers = {
                    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    ["Accept"] = "image/*,*/*",
                    ["Referer"] = "https://tomato.tpos.vn/"
                },
                ssl_verify = false
            })
            
            if not res then
                ngx.status = 500
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say('{"error": "Failed to proxy image", "message": "' .. (err or "unknown error") .. '"}')
                return
            end
            
            ngx.header["Content-Type"] = res.headers["Content-Type"] or "image/jpeg"
            ngx.header["Cache-Control"] = "public, max-age=86400"
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.header["Access-Control-Allow-Methods"] = "GET, OPTIONS"
            ngx.header["Access-Control-Allow-Headers"] = "Content-Type, Accept"
            ngx.print(res.body)
        }
    }

    # ========== FACEBOOK/PANCAKE AVATAR PROXY ==========
    # GET /api/fb-avatar?id=<facebook_user_id>&page=<page_id>&token=<jwt_token>
    location = /api/fb-avatar {
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            local fb_id = ngx.var.arg_id
            local page_id = ngx.var.arg_page or "270136663390370"
            local access_token = ngx.var.arg_token
            
            if not fb_id or fb_id == "" then
                ngx.status = 400
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    error = "Missing id parameter",
                    usage = "/api/fb-avatar?id=<facebook_user_id>&page=<page_id>&token=<jwt_token>"
                }))
                return
            end
            
            -- Default avatar SVG
            local default_svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle cx="20" cy="20" r="20" fill="#e5e7eb"/><circle cx="20" cy="15" r="7" fill="#9ca3af"/><ellipse cx="20" cy="32" rx="11" ry="8" fill="#9ca3af"/></svg>'
            
            -- Try Pancake Avatar API first
            local pancake_url = "https://pancake.vn/api/v1/pages/" .. page_id .. "/avatar/" .. fb_id
            if access_token then
                pancake_url = pancake_url .. "?access_token=" .. access_token
            end
            
            local res, err = httpc:request_uri(pancake_url, {
                method = "GET",
                headers = {
                    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    ["Accept"] = "image/*,*/*",
                    ["Referer"] = "https://pancake.vn/"
                },
                ssl_verify = false
            })
            
            if res and res.status == 200 then
                ngx.header["Content-Type"] = res.headers["Content-Type"] or "image/jpeg"
                ngx.header["Cache-Control"] = "public, max-age=86400"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.header["Access-Control-Allow-Methods"] = "GET, OPTIONS"
                ngx.header["Access-Control-Allow-Headers"] = "Content-Type, Accept"
                ngx.print(res.body)
                return
            end
            
            -- Fallback to Facebook Graph API
            local fb_url = "https://graph.facebook.com/" .. fb_id .. "/picture?width=80&height=80&type=normal"
            local fb_res, fb_err = httpc:request_uri(fb_url, {
                method = "GET",
                headers = {
                    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    ["Accept"] = "image/*,*/*"
                },
                ssl_verify = false
            })
            
            if fb_res and fb_res.status == 200 then
                ngx.header["Content-Type"] = fb_res.headers["Content-Type"] or "image/jpeg"
                ngx.header["Cache-Control"] = "public, max-age=86400"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.print(fb_res.body)
                return
            end
            
            -- Return default SVG
            ngx.header["Content-Type"] = "image/svg+xml"
            ngx.header["Cache-Control"] = "public, max-age=3600"
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.print(default_svg)
        }
    }

    # ========== PANCAKE AVATAR PROXY ==========
    # GET /api/pancake-avatar?hash=<avatar_hash>
    location = /api/pancake-avatar {
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            local avatar_hash = ngx.var.arg_hash
            
            if not avatar_hash or avatar_hash == "" then
                ngx.status = 400
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    error = "Missing hash parameter",
                    usage = "/api/pancake-avatar?hash=<avatar_hash>"
                }))
                return
            end
            
            local default_svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle cx="20" cy="20" r="20" fill="#e5e7eb"/><circle cx="20" cy="15" r="7" fill="#9ca3af"/><ellipse cx="20" cy="32" rx="11" ry="8" fill="#9ca3af"/></svg>'
            
            local pancake_url = "https://content.pancake.vn/2.1-24/avatars/" .. avatar_hash
            
            local res, err = httpc:request_uri(pancake_url, {
                method = "GET",
                headers = {
                    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    ["Accept"] = "image/*,*/*",
                    ["Referer"] = "https://pancake.vn/"
                },
                ssl_verify = false
            })
            
            if res and res.status == 200 then
                ngx.header["Content-Type"] = res.headers["Content-Type"] or "image/jpeg"
                ngx.header["Cache-Control"] = "public, max-age=86400"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.print(res.body)
                return
            end
            
            ngx.header["Content-Type"] = "image/svg+xml"
            ngx.header["Cache-Control"] = "public, max-age=3600"
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.print(default_svg)
        }
    }

    # ========== GENERIC PROXY ENDPOINT ==========
    # GET/POST /api/proxy?url=<encoded_url>&headers=<json_headers>
    location = /api/proxy {
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            local target_url = ngx.var.arg_url
            
            if not target_url or target_url == "" then
                ngx.status = 400
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    error = "Missing url parameter",
                    usage = "/api/proxy?url=<encoded_url>"
                }))
                return
            end
            
            target_url = ngx.unescape_uri(target_url)
            
            -- Build headers
            local headers = {
                ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                ["Accept"] = "application/json, text/plain, */*"
            }
            
            -- Preserve Content-Type
            local content_type = ngx.var.content_type
            if content_type then
                headers["Content-Type"] = content_type
            end
            
            -- Parse custom headers from query param
            local custom_headers_str = ngx.var.arg_headers
            if custom_headers_str then
                local ok, custom_headers = pcall(cjson.decode, ngx.unescape_uri(custom_headers_str))
                if ok then
                    for k, v in pairs(custom_headers) do
                        headers[k] = v
                    end
                end
            end
            
            -- Get request body
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            
            local res, err = httpc:request_uri(target_url, {
                method = ngx.req.get_method(),
                body = body,
                headers = headers,
                ssl_verify = false
            })
            
            if not res then
                ngx.status = 500
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    error = "Failed to proxy request",
                    message = err or "unknown error"
                }))
                return
            end
            
            -- Copy response headers
            for k, v in pairs(res.headers) do
                if k:lower() ~= "transfer-encoding" and k:lower() ~= "connection" then
                    ngx.header[k] = v
                end
            end
            
            ngx.status = res.status
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
            ngx.header["Access-Control-Allow-Headers"] = "Content-Type, Authorization, Accept, tposappversion, x-tpos-lang"
            ngx.print(res.body)
        }
    }

    # ========== PANCAKE DIRECT API (24h policy bypass) ==========
    # /api/pancake-direct/{path}?page_id=xxx&jwt=xxx
    location ~ ^/api/pancake-direct/(.+)$ {
        set $api_path $1;
        
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            local api_path = ngx.var.api_path
            local page_id = ngx.var.arg_page_id
            local jwt_token = ngx.var.arg_jwt
            
            -- Build query string without our custom params
            local args = ngx.req.get_uri_args()
            args.page_id = nil
            args.jwt = nil
            
            local query_parts = {}
            for k, v in pairs(args) do
                if type(v) == "table" then
                    for _, val in ipairs(v) do
                        table.insert(query_parts, ngx.escape_uri(k) .. "=" .. ngx.escape_uri(val))
                    end
                else
                    table.insert(query_parts, ngx.escape_uri(k) .. "=" .. ngx.escape_uri(v))
                end
            end
            local query_string = #query_parts > 0 and ("?" .. table.concat(query_parts, "&")) or ""
            
            local target_url = "https://pancake.vn/api/v1/" .. api_path .. query_string
            
            -- Determine Referer based on pageId
            local referer_url = "https://pancake.vn/multi_pages"
            if page_id == "117267091364524" then
                referer_url = "https://pancake.vn/NhiJudyHouse.VietNam"
            elseif page_id == "270136663390370" then
                referer_url = "https://pancake.vn/NhiJudyStore"
            end
            
            -- Build headers
            local headers = {
                ["Accept"] = "application/json, text/plain, */*",
                ["Accept-Language"] = "en-US,en;q=0.9,vi;q=0.8",
                ["Origin"] = "https://pancake.vn",
                ["Referer"] = referer_url,
                ["User-Agent"] = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
                ["sec-ch-ua"] = '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                ["sec-ch-ua-mobile"] = "?0",
                ["sec-ch-ua-platform"] = '"macOS"',
                ["sec-fetch-dest"] = "empty",
                ["sec-fetch-mode"] = "cors",
                ["sec-fetch-site"] = "same-origin"
            }
            
            -- Set Content-Type
            local content_type = ngx.var.content_type
            if content_type then
                headers["Content-Type"] = content_type
            end
            
            -- Set Cookie with JWT
            if jwt_token then
                headers["Cookie"] = "jwt=" .. jwt_token .. "; locale=vi"
            end
            
            -- Get request body
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            
            local res, err = httpc:request_uri(target_url, {
                method = ngx.req.get_method(),
                body = body,
                headers = headers,
                ssl_verify = false
            })
            
            if not res then
                ngx.status = 500
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    error = "Pancake direct API failed",
                    message = err or "unknown error"
                }))
                return
            end
            
            -- Copy response headers
            for k, v in pairs(res.headers) do
                if k:lower() ~= "transfer-encoding" and k:lower() ~= "connection" then
                    ngx.header[k] = v
                end
            end
            
            ngx.status = res.status
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
            ngx.header["Access-Control-Allow-Headers"] = "Content-Type, Authorization, Accept"
            ngx.print(res.body)
        }
    }

    # ========== PANCAKE OFFICIAL API (pages.fm Public API) ==========
    # /api/pancake-official/{path}?page_access_token=xxx
    location ~ ^/api/pancake-official/(.+)$ {
        set $api_path $1;
        
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            local api_path = ngx.var.api_path
            local query_string = ngx.var.query_string or ""
            if query_string ~= "" then
                query_string = "?" .. query_string
            end
            
            local target_url = "https://pages.fm/api/public_api/v1/" .. api_path .. query_string
            
            -- Build headers
            local headers = {
                ["Accept"] = "application/json, text/plain, */*",
                ["Accept-Language"] = "en-US,en;q=0.9,vi;q=0.8",
                ["Origin"] = "https://pages.fm",
                ["Referer"] = "https://pages.fm/",
                ["User-Agent"] = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
                ["sec-ch-ua"] = '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                ["sec-ch-ua-mobile"] = "?0",
                ["sec-ch-ua-platform"] = '"macOS"',
                ["sec-fetch-dest"] = "empty",
                ["sec-fetch-mode"] = "cors",
                ["sec-fetch-site"] = "same-origin"
            }
            
            -- Set Content-Type
            local content_type = ngx.var.content_type
            if content_type then
                headers["Content-Type"] = content_type
            end
            
            -- Get request body
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            
            local res, err = httpc:request_uri(target_url, {
                method = ngx.req.get_method(),
                body = body,
                headers = headers,
                ssl_verify = false
            })
            
            if not res then
                ngx.status = 500
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    error = "Pancake Official API failed",
                    message = err or "unknown error"
                }))
                return
            end
            
            -- Copy response headers
            for k, v in pairs(res.headers) do
                if k:lower() ~= "transfer-encoding" and k:lower() ~= "connection" then
                    ngx.header[k] = v
                end
            end
            
            ngx.status = res.status
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
            ngx.header["Access-Control-Allow-Headers"] = "Content-Type, Authorization, Accept"
            ngx.print(res.body)
        }
    }

    # ========== FACEBOOK GRAPH API - SEND MESSAGE WITH TAG ==========
    # POST /api/facebook-send
    # Body: { pageId, psid, message, pageToken, useTag: true, imageUrls: [] }
    location = /api/facebook-send {
        if ($request_method != POST) {
            return 405;
        }
        
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            ngx.req.read_body()
            local body_data = ngx.req.get_body_data()
            
            local ok, body = pcall(cjson.decode, body_data)
            if not ok then
                ngx.status = 400
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({success = false, error = "Invalid JSON body"}))
                return
            end
            
            local page_id = body.pageId
            local psid = body.psid
            local message = body.message
            local page_token = body.pageToken
            local use_tag = body.useTag
            local image_urls = body.imageUrls or {}
            
            -- Validate required fields
            if not page_id or not psid or not page_token then
                ngx.status = 400
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Access-Control-Allow-Origin"] = "*"
                ngx.say(cjson.encode({
                    success = false,
                    error = "Missing required fields",
                    required = {"pageId", "psid", "pageToken"},
                    usage = "POST /api/facebook-send with JSON body { pageId, psid, message, pageToken, useTag: true, imageUrls: [] }"
                }))
                return
            end
            
            local graph_api_url = "https://graph.facebook.com/v21.0/" .. page_id .. "/messages?access_token=" .. page_token
            local message_ids = {}
            local last_result = nil
            
            -- Send images first
            for _, image_url in ipairs(image_urls) do
                local image_body = {
                    recipient = { id = psid },
                    message = {
                        attachment = {
                            type = "image",
                            payload = {
                                url = image_url,
                                is_reusable = true
                            }
                        }
                    }
                }
                
                if use_tag then
                    image_body.messaging_type = "MESSAGE_TAG"
                    image_body.tag = "POST_PURCHASE_UPDATE"
                else
                    image_body.messaging_type = "RESPONSE"
                end
                
                local res, err = httpc:request_uri(graph_api_url, {
                    method = "POST",
                    body = cjson.encode(image_body),
                    headers = {
                        ["Content-Type"] = "application/json",
                        ["Accept"] = "application/json"
                    },
                    ssl_verify = false
                })
                
                if not res then
                    ngx.status = 500
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Access-Control-Allow-Origin"] = "*"
                    ngx.say(cjson.encode({success = false, error = "Failed to send image", message = err}))
                    return
                end
                
                local image_result = cjson.decode(res.body)
                if image_result.error then
                    ngx.status = res.status
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Access-Control-Allow-Origin"] = "*"
                    ngx.say(cjson.encode({
                        success = false,
                        error = image_result.error.message or "Failed to send image",
                        error_code = image_result.error.code,
                        error_subcode = image_result.error.error_subcode
                    }))
                    return
                end
                
                table.insert(message_ids, image_result.message_id)
                last_result = image_result
            end
            
            -- Send text message
            if message and message ~= "" then
                local text_body = {
                    recipient = { id = psid },
                    message = { text = message }
                }
                
                if use_tag then
                    text_body.messaging_type = "MESSAGE_TAG"
                    text_body.tag = "POST_PURCHASE_UPDATE"
                else
                    text_body.messaging_type = "RESPONSE"
                end
                
                local res, err = httpc:request_uri(graph_api_url, {
                    method = "POST",
                    body = cjson.encode(text_body),
                    headers = {
                        ["Content-Type"] = "application/json",
                        ["Accept"] = "application/json"
                    },
                    ssl_verify = false
                })
                
                if not res then
                    ngx.status = 500
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Access-Control-Allow-Origin"] = "*"
                    ngx.say(cjson.encode({success = false, error = "Failed to send message", message = err}))
                    return
                end
                
                local text_result = cjson.decode(res.body)
                if text_result.error then
                    ngx.status = res.status
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Access-Control-Allow-Origin"] = "*"
                    ngx.say(cjson.encode({
                        success = false,
                        error = text_result.error.message or "Failed to send text",
                        error_code = text_result.error.code,
                        error_subcode = text_result.error.error_subcode
                    }))
                    return
                end
                
                table.insert(message_ids, text_result.message_id)
                last_result = text_result
            end
            
            -- Success
            ngx.header["Content-Type"] = "application/json"
            ngx.header["Access-Control-Allow-Origin"] = "*"
            ngx.say(cjson.encode({
                success = true,
                recipient_id = last_result and last_result.recipient_id or nil,
                message_id = last_result and last_result.message_id or nil,
                message_ids = message_ids,
                used_tag = use_tag and "POST_PURCHASE_UPDATE" or cjson.null
            }))
        }
    }

    # ========== PANCAKE API (Generic) ==========
    # /api/pancake/{path}
    location ~ ^/api/pancake/(.+)$ {
        set $api_path $1;
        
        proxy_pass https://pancake.vn/api/v1/$api_path$is_args$args;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host pancake.vn;
        proxy_set_header Accept "application/json, text/plain, */*";
        proxy_set_header Accept-Language "vi,en-US;q=0.9,en;q=0.8";
        proxy_set_header Origin "https://pancake.vn";
        proxy_set_header Referer "https://pancake.vn/multi_pages";
        proxy_set_header User-Agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36";
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept' always;
    }

    # ========== REALTIME SERVER (Render) ==========
    # /api/realtime/start
    location = /api/realtime/start {
        proxy_pass https://n2store-fallback.onrender.com/api/realtime/start;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host n2store-fallback.onrender.com;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept, X-Auth-Data, X-User-Id, tposappversion, x-tpos-lang' always;
    }

    # ========== CHAT SERVER (Render) ==========
    # /api/chat/{path}
    location ~ ^/api/chat/(.+)$ {
        set $chat_path $1;
        
        proxy_pass https://n2store-fallback.onrender.com/api/chat/$chat_path$is_args$args;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host n2store-fallback.onrender.com;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept, X-Auth-Data, X-User-Id, tposappversion, x-tpos-lang' always;
    }

    # ========== SEPAY WEBHOOK & BALANCE HISTORY (Render) ==========
    # /api/sepay/{path}
    location ~ ^/api/sepay/(.+)$ {
        set $sepay_path $1;
        
        proxy_pass https://n2store-fallback.onrender.com/api/sepay/$sepay_path$is_args$args;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host n2store-fallback.onrender.com;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept, X-Auth-Data, X-User-Id, tposappversion, x-tpos-lang' always;
    }

    # ========== CUSTOMERS API (Render - PostgreSQL backend) ==========
    # /api/customers/{path}
    location ~ ^/api/customers/?(.*)$ {
        set $customers_path $1;
        
        proxy_pass https://n2store-fallback.onrender.com/api/customers/$customers_path$is_args$args;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host n2store-fallback.onrender.com;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept, X-Auth-Data, X-User-Id, tposappversion, x-tpos-lang' always;
    }

    # ========== TPOS REST API v2.0 (Live Comments, etc.) ==========
    # /api/rest/{path}
    location ~ ^/api/rest/(.+)$ {
        set $rest_path $1;
        
        proxy_pass https://tomato.tpos.vn/rest/$rest_path$is_args$args;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host tomato.tpos.vn;
        proxy_set_header Accept "*/*";
        proxy_set_header Content-Type "application/json;IEEE754Compatible=false;charset=utf-8";
        proxy_set_header tposappversion "5.11.16.1";
        proxy_set_header Origin "https://tomato.tpos.vn";
        proxy_set_header Referer "https://tomato.tpos.vn/";
        proxy_set_header User-Agent "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36";
        
        # Forward Authorization header
        proxy_set_header Authorization $http_authorization;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept, tposappversion, x-tpos-lang' always;
    }

    # ========== TPOS API (Catch-all) ==========
    # /api/{path} - forwards to tomato.tpos.vn
    location ~ ^/api/(.+)$ {
        set $tpos_path $1;
        
        proxy_pass https://tomato.tpos.vn/$tpos_path$is_args$args;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
        
        proxy_set_header Host tomato.tpos.vn;
        proxy_set_header Origin "https://tomato.tpos.vn/";
        proxy_set_header Referer "https://tomato.tpos.vn/";
        
        # Forward original headers
        proxy_set_header Authorization $http_authorization;
        proxy_set_header Content-Type $content_type;
        proxy_set_header Accept $http_accept;
        proxy_set_header tposappversion $http_tposappversion;
        proxy_set_header x-tpos-lang $http_x_tpos_lang;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, Accept, X-Auth-Data, X-User-Id, tposappversion, x-tpos-lang' always;
    }

    # ========== UNKNOWN ROUTE ==========
    location / {
        return 404 '{"error": "Invalid API route", "message": "Use /api/* routes"}';
        add_header 'Content-Type' 'application/json' always;
        add_header 'Access-Control-Allow-Origin' '*' always;
    }
}
