/**
 * N2Store Core Utilities Bundle
 *
 * Auto-generated by build-scripts/bundle-core.js
 * Generated: 2026-02-22T13:48:54.140Z
 *
 * Includes:
 *  * - logger.js
 * - dom-utils.js
 * - common-utils.js
 * - date-utils.js
 * - form-utils.js
 * - shared-cache-manager.js
 * - notification-system.js
 * - shared-auth-manager.js
 *
 * Usage:
 * <script src="../shared/js/shared-core-bundle.js"></script>
 *
 * This bundle provides:
 * - window.Logger, window.logger
 * - window.DOMUtils, window.$, window.$$
 * - window.CommonUtils, window.showStatusMessage, etc.
 * - window.DateUtils, window.formatDate, etc.
 * - window.FormUtils, window.debounce, window.throttle, etc.
 * - window.CacheManager, window.PersistentCacheManager
 * - window.NotificationManager, window.notificationManager
 * - window.AuthManager, window.authManager
 */

(function(window) {
    'use strict';

    // Prevent double-loading
    if (window.CORE_BUNDLE_LOADED) {
        console.log('[Core Bundle] Already loaded, skipping');
        return;
    }


    // ========================================
    // logger.js
    // ========================================
/**
 * PRODUCTION-SAFE LOGGER
 * File: logger.js
 *
 * WRAPPER FILE - Backward compatibility layer
 * SOURCE OF TRUTH: /shared/browser/logger.js
 *
 * This file is kept for backward compatibility with existing code using:
 *   <script src="../shared/js/logger.js"></script>
 *
 * For new ES Module code, import directly from:
 *   import { Logger, logger } from '/shared/browser/logger.js';
 */

// Detect environment
const IS_PRODUCTION = window.location.hostname !== 'localhost' &&
                     window.location.hostname !== '127.0.0.1' &&
                     !window.location.hostname.includes('192.168.');

// Logger class
class Logger {
    constructor(enabled = !IS_PRODUCTION) {
        this.enabled = enabled;
    }

    log(...args) {
        if (this.enabled) {
            console.log(...args);
        }
    }

    warn(...args) {
        if (this.enabled) {
            console.warn(...args);
        }
    }

    error(...args) {
        // Always show errors, even in production
        console.error(...args);
    }

    info(...args) {
        if (this.enabled) {
            console.info(...args);
        }
    }

    debug(...args) {
        if (this.enabled) {
            console.debug(...args);
        }
    }

    // Force enable/disable
    enable() {
        this.enabled = true;
    }

    disable() {
        this.enabled = false;
    }

    // Toggle
    toggle() {
        this.enabled = !this.enabled;
    }
}

// Global logger instance
const logger = new Logger();

// Expose to window
if (typeof window !== 'undefined') {
    window.logger = logger;
    window.Logger = Logger;

    // Backward compatibility - override console in production
    if (IS_PRODUCTION) {
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalInfo = console.info;
        const originalDebug = console.debug;

        console.log = (...args) => logger.log(...args);
        console.warn = (...args) => logger.warn(...args);
        console.info = (...args) => logger.info(...args);
        console.debug = (...args) => logger.debug(...args);

        // Keep original references for debugging
        console._original = {
            log: originalLog,
            warn: originalWarn,
            info: originalInfo,
            debug: originalDebug
        };
    }
}

// Module export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { Logger, logger };
}



    // ========================================
    // dom-utils.js
    // ========================================
/**
 * SAFE DOM MANIPULATION UTILITIES
 * File: dom-utils.js
 *
 * WRAPPER FILE - Backward compatibility layer
 * SOURCE OF TRUTH: /shared/browser/dom-utils.js
 *
 * This file is kept for backward compatibility with existing code using:
 *   <script src="../shared/js/dom-utils.js"></script>
 *
 * For new ES Module code, import directly from:
 *   import { DOMUtils } from '/shared/browser/dom-utils.js';
 */

const DOMUtils = {
    /**
     * Set text content safely (kh√¥ng d√πng innerHTML)
     * @param {HTMLElement} element
     * @param {string} text
     */
    setText(element, text) {
        if (element) {
            element.textContent = text;
        }
    },

    /**
     * Set HTML content v·ªõi sanitization
     * @param {HTMLElement} element
     * @param {string} html
     */
    setHTML(element, html) {
        if (!element) return;

        // Sanitize HTML ƒë·ªÉ lo·∫°i b·ªè script tags v√† event handlers
        const sanitized = this.sanitizeHTML(html);
        element.innerHTML = sanitized;
    },

    /**
     * Basic HTML sanitization
     * Lo·∫°i b·ªè: <script>, on* attributes, javascript: protocols
     * @param {string} html
     * @returns {string}
     */
    sanitizeHTML(html) {
        if (typeof html !== 'string') return '';

        let cleaned = html;

        // Remove script tags
        cleaned = cleaned.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');

        // Remove event handlers (onclick, onerror, etc.)
        cleaned = cleaned.replace(/\son\w+\s*=\s*["'][^"']*["']/gi, '');
        cleaned = cleaned.replace(/\son\w+\s*=\s*[^\s>]*/gi, '');

        // Remove javascript: protocol
        cleaned = cleaned.replace(/javascript:/gi, '');

        // Remove data: protocol (can be used for XSS)
        cleaned = cleaned.replace(/data:text\/html/gi, '');

        return cleaned;
    },

    /**
     * Create element v·ªõi attributes an to√†n
     * @param {string} tagName
     * @param {object} attributes
     * @param {string} textContent
     * @returns {HTMLElement}
     */
    createElement(tagName, attributes = {}, textContent = '') {
        const element = document.createElement(tagName);

        // Set attributes safely
        for (const [key, value] of Object.entries(attributes)) {
            // Skip dangerous attributes
            if (key.startsWith('on')) continue;
            if (key === 'innerHTML') continue;

            if (key === 'className' || key === 'class') {
                element.className = value;
            } else if (key === 'style' && typeof value === 'object') {
                Object.assign(element.style, value);
            } else {
                element.setAttribute(key, value);
            }
        }

        // Set text content
        if (textContent) {
            element.textContent = textContent;
        }

        return element;
    },

    /**
     * Append child safely
     * @param {HTMLElement} parent
     * @param {HTMLElement} child
     */
    appendChild(parent, child) {
        if (parent && child) {
            parent.appendChild(child);
        }
    },

    /**
     * Remove all children
     * @param {HTMLElement} element
     */
    clearChildren(element) {
        if (element) {
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
    },

    /**
     * Escape HTML entities
     * @param {string} text
     * @returns {string}
     */
    escapeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },

    /**
     * Unescape HTML entities
     * @param {string} html
     * @returns {string}
     */
    unescapeHTML(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div.textContent;
    }
};

// Export to window
if (typeof window !== 'undefined') {
    window.DOMUtils = DOMUtils;
}

// Module export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { DOMUtils };
}



    // ========================================
    // common-utils.js
    // ========================================
/**
 * Common UI Utilities - C√°c ti·ªán √≠ch giao di·ªán chung
 * File: common-utils.js
 *
 * WRAPPER FILE - Backward compatibility layer
 * SOURCE OF TRUTH: /shared/browser/common-utils.js
 *
 * This file is kept for backward compatibility with existing code using:
 *   <script src="../shared/js/common-utils.js"></script>
 *
 * For new ES Module code, import directly from:
 *   import { CommonUtils } from '/shared/browser/common-utils.js';
 */

/**
 * ====================================================================================
 * STATUS & NOTIFICATION SYSTEM
 * ====================================================================================
 */

/**
 * Hi·ªÉn th·ªã th√¥ng b√°o status
 */
function showStatusMessage(message, type = "info") {
    const indicator = document.getElementById("statusIndicator");
    if (indicator) {
        indicator.textContent = message;
        indicator.className = `status-indicator ${type} show`;

        setTimeout(() => {
            indicator.classList.remove("show");
        }, 3000);
    }
}

/**
 * ====================================================================================
 * ENHANCED FLOATING ALERT SYSTEM V·ªöI LOADING BLOCK
 * ====================================================================================
 */

// Namespace ƒë·ªÉ tr√°nh conflicts
window.FloatingAlert = window.FloatingAlert || {};

// Global state tracking trong namespace
if (typeof window.FloatingAlert.isPageBlocked === "undefined") {
    window.FloatingAlert.isPageBlocked = false;
    window.FloatingAlert.blockingOverlay = null;
}

/**
 * Enhanced floating alert v·ªõi kh√≥a t∆∞∆°ng t√°c khi loading
 */
function showFloatingAlert(message, type = "info", duration = 3000) {
    const alert = document.getElementById("floatingAlert");
    if (alert) {
        // T√¨m elements an to√†n
        const alertText = alert.querySelector(".alert-text");
        const spinner = alert.querySelector(".loading-spinner");

        // C·∫≠p nh·∫≠t n·ªôi dung
        if (alertText) {
            alertText.textContent = message;
        } else {
            // Fallback n·∫øu kh√¥ng c√≥ .alert-text
            alert.textContent = message;
        }

        // Reset classes
        alert.className = "show";

        if (type === "loading") {
            alert.classList.add("loading");
            if (spinner) spinner.style.display = "block";

            // KH√ìA T∆Ø∆†NG T√ÅC KHI LOADING
            blockPageInteractions();
        } else {
            alert.classList.add(type);
            if (spinner) spinner.style.display = "none";

            // M·ªû KH√ìA T∆Ø∆†NG T√ÅC CHO C√ÅC LO·∫†I KH√ÅC
            unblockPageInteractions();
        }

        // Auto hide cho non-loading alerts
        if (type !== "loading") {
            setTimeout(() => {
                alert.classList.remove("show");
            }, duration);
        }
    }
}

/**
 * Hide floating alert v√† m·ªü kh√≥a t∆∞∆°ng t√°c
 */
function hideFloatingAlert() {
    const alert = document.getElementById("floatingAlert");
    if (alert) {
        alert.classList.remove("show");

        // M·ªû KH√ìA T∆Ø∆†NG T√ÅC KHI ·∫®N ALERT
        unblockPageInteractions();
    }
}

/**
 * KH√ìA T∆Ø∆†NG T√ÅC TO√ÄN TRANG
 */
function blockPageInteractions() {
    if (window.FloatingAlert.isPageBlocked) return; // Tr√°nh duplicate

    window.FloatingAlert.isPageBlocked = true;

    // T·∫°o overlay ch·∫∑n
    createBlockingOverlay();

    // V√¥ hi·ªáu h√≥a body interactions
    document.body.style.pointerEvents = "none";
    document.body.style.userSelect = "none";
    document.body.classList.add("page-blocked");

    // Cho ph√©p alert v·∫´n ho·∫°t ƒë·ªông
    const alert = document.getElementById("floatingAlert");
    if (alert) {
        alert.style.pointerEvents = "auto";
        alert.style.zIndex = "10000";
    }

    // V√¥ hi·ªáu h√≥a keyboard navigation
    document.addEventListener("keydown", blockKeyboardInteraction, true);
    document.addEventListener("keyup", blockKeyboardInteraction, true);
    document.addEventListener("keypress", blockKeyboardInteraction, true);

    // V√¥ hi·ªáu h√≥a context menu
    document.addEventListener("contextmenu", preventDefaultAction, true);

    // V√¥ hi·ªáu h√≥a drag & drop
    document.addEventListener("dragstart", preventDefaultAction, true);

    console.log("Page interactions blocked for loading");
}

/**
 * M·ªû KH√ìA T∆Ø∆†NG T√ÅC TO√ÄN TRANG
 */
function unblockPageInteractions() {
    if (!window.FloatingAlert.isPageBlocked) return; // Kh√¥ng c·∫ßn unblock n·∫øu ch∆∞a block

    window.FloatingAlert.isPageBlocked = false;

    // X√≥a overlay ch·∫∑n
    removeBlockingOverlay();

    // K√≠ch ho·∫°t l·∫°i body interactions
    document.body.style.pointerEvents = "";
    document.body.style.userSelect = "";
    document.body.classList.remove("page-blocked");

    // Reset alert styles
    const alert = document.getElementById("floatingAlert");
    if (alert) {
        alert.style.pointerEvents = "";
        alert.style.zIndex = "";
    }

    // K√≠ch ho·∫°t l·∫°i keyboard navigation
    document.removeEventListener("keydown", blockKeyboardInteraction, true);
    document.removeEventListener("keyup", blockKeyboardInteraction, true);
    document.removeEventListener("keypress", blockKeyboardInteraction, true);

    // K√≠ch ho·∫°t l·∫°i context menu
    document.removeEventListener("contextmenu", preventDefaultAction, true);

    // K√≠ch ho·∫°t l·∫°i drag & drop
    document.removeEventListener("dragstart", preventDefaultAction, true);

    console.log("Page interactions unblocked");
}

/**
 * T·∫°o overlay ch·∫∑n t∆∞∆°ng t√°c
 */
function createBlockingOverlay() {
    if (window.FloatingAlert.blockingOverlay) return; // Tr√°nh t·∫°o duplicate

    window.FloatingAlert.blockingOverlay = document.createElement("div");
    window.FloatingAlert.blockingOverlay.id = "loadingBlockOverlay";
    window.FloatingAlert.blockingOverlay.innerHTML = `
        <div class="blocking-content">
            <div class="blocking-spinner"></div>
            <div class="blocking-message">Vui l√≤ng ƒë·ª£i...</div>
        </div>
    `;

    // Styles cho overlay
    Object.assign(window.FloatingAlert.blockingOverlay.style, {
        position: "fixed",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        backgroundColor: "rgba(0, 0, 0, 0.6)",
        zIndex: "9999",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backdropFilter: "blur(2px)",
        cursor: "wait",
    });

    document.body.appendChild(window.FloatingAlert.blockingOverlay);

    // Animate in
    setTimeout(() => {
        if (window.FloatingAlert.blockingOverlay) {
            window.FloatingAlert.blockingOverlay.style.opacity = "1";
        }
    }, 10);
}

/**
 * X√≥a overlay ch·∫∑n t∆∞∆°ng t√°c
 */
function removeBlockingOverlay() {
    if (window.FloatingAlert.blockingOverlay) {
        window.FloatingAlert.blockingOverlay.style.opacity = "0";
        setTimeout(() => {
            if (
                window.FloatingAlert.blockingOverlay &&
                window.FloatingAlert.blockingOverlay.parentNode
            ) {
                window.FloatingAlert.blockingOverlay.parentNode.removeChild(
                    window.FloatingAlert.blockingOverlay,
                );
            }
            window.FloatingAlert.blockingOverlay = null;
        }, 300);
    }
}

/**
 * Ch·∫∑n keyboard interactions
 */
function blockKeyboardInteraction(event) {
    // Ch·ªâ cho ph√©p ESC ƒë·ªÉ cancel loading n·∫øu c·∫ßn
    if (event.key === "Escape") {
        return; // C√≥ th·ªÉ th√™m logic cancel loading ·ªü ƒë√¢y
    }

    // Ch·∫∑n t·∫•t c·∫£ c√°c ph√≠m kh√°c
    event.preventDefault();
    event.stopPropagation();
    return false;
}

/**
 * NgƒÉn default actions
 */
function preventDefaultAction(event) {
    event.preventDefault();
    event.stopPropagation();
    return false;
}

/**
 * Inject CSS cho blocking system
 */
function injectBlockingStyles() {
    if (document.getElementById("loadingBlockStyles")) return;

    const styles = document.createElement("style");
    styles.id = "loadingBlockStyles";
    styles.textContent = `
        /* Page blocked state */
        body.page-blocked {
            overflow: hidden;
            cursor: wait;
        }
        
        body.page-blocked * {
            cursor: wait !important;
        }
        
        /* Blocking overlay content */
        .blocking-content {
            text-align: center;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .blocking-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: blockingSpin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        .blocking-message {
            font-size: 16px;
            font-weight: 500;
            opacity: 0.9;
            letter-spacing: 0.5px;
        }
        
        @keyframes blockingSpin {
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Enhanced floating alert z-index */
        #floatingAlert {
            z-index: 10000 !important;
        }
        
        #floatingAlert.loading {
            pointer-events: auto !important;
        }
    `;

    document.head.appendChild(styles);
}

/**
 * Show loading v·ªõi blocking
 */
function showLoading(message = "ƒêang x·ª≠ l√Ω...") {
    showFloatingAlert(message, "loading");
}

/**
 * Show success v√† unblock
 */
function showSuccess(message = "Th√†nh c√¥ng!", duration = 2000) {
    hideFloatingAlert();
    setTimeout(() => {
        showFloatingAlert(message, "success", duration);
    }, 100);
}

/**
 * Show error v√† unblock
 */
function showError(message = "C√≥ l·ªói x·∫£y ra!", duration = 3000) {
    hideFloatingAlert();
    setTimeout(() => {
        showFloatingAlert(message, "error", duration);
    }, 100);
}

/**
 * Utility: Check n·∫øu page ƒëang b·ªã block
 */
function isPageCurrentlyBlocked() {
    return window.FloatingAlert.isPageBlocked;
}

/**
 * Utility: Force unblock (emergency)
 */
function forceUnblockPage() {
    console.warn("Force unblocking page interactions");
    unblockPageInteractions();
    hideFloatingAlert();
}

/**
 * Auto-inject styles khi script load
 */
(function () {
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", injectBlockingStyles);
    } else {
        injectBlockingStyles();
    }
})();

/**
 * Auto-cleanup khi page unload
 */
window.addEventListener("beforeunload", function () {
    if (window.FloatingAlert.isPageBlocked) {
        forceUnblockPage();
    }
});

/**
 * ====================================================================================
 * EVENT HANDLERS SETUP
 * ====================================================================================
 */

/**
 * Setup clipboard container drag & drop feedback
 */
function setupClipboardContainers() {
    const containers = ["container", "containerKH"];
    containers.forEach((containerId) => {
        const container = document.getElementById(containerId);
        if (container) {
            container.addEventListener("dragover", function (e) {
                e.preventDefault();
                this.style.borderColor = "#667eea";
                this.style.background = "#f0f4ff";
            });

            container.addEventListener("dragleave", function (e) {
                e.preventDefault();
                this.style.borderColor = "#ddd";
                this.style.background = "#f9f9f9";
            });

            container.addEventListener("drop", function (e) {
                e.preventDefault();
                this.style.borderColor = "#28a745";
                this.style.background = "#f8fff9";
                this.classList.add("has-content");
            });
        }
    });
}

/**
 * Setup form monitoring cho better UX
 */
function setupFormMonitoring() {
    const form = document.querySelector("#dataForm form");
    if (form) {
        form.addEventListener("input", function () {
            const addButton = document.getElementById("addButton");
            const requiredFields = form.querySelectorAll("[required]");
            let allFilled = true;

            requiredFields.forEach((field) => {
                if (!field.value.trim()) {
                    allFilled = false;
                }
            });

            if (addButton) {
                addButton.style.opacity = allFilled ? "1" : "0.6";
            }
        });
    }
}

/**
 * Setup security and performance indicators
 */
function setupSecurityIndicators() {
    // Update security indicator based on HTTPS
    const securityIndicator = document.getElementById("securityIndicator");
    if (securityIndicator) {
        if (location.protocol !== "https:") {
            securityIndicator.textContent = "Insecure";
            securityIndicator.classList.add("insecure");
        }
    }

    // Show performance indicator
    const performanceIndicator = document.getElementById(
        "performanceIndicator",
    );
    if (performanceIndicator) {
        performanceIndicator.style.display = "block";
        setTimeout(() => {
            performanceIndicator.style.display = "none";
        }, 3000);
    }
}

/**
 * ====================================================================================
 * MONITORING & ERROR HANDLING
 * ====================================================================================
 */

/**
 * Performance monitoring
 */
function setupPerformanceMonitoring() {
    window.addEventListener("load", function () {
        if (performance && performance.timing) {
            const loadTime =
                performance.timing.loadEventEnd -
                performance.timing.navigationStart;
            console.log("Page load time:", loadTime + "ms");

            if (loadTime < 2000) {
                showStatusMessage("T·∫£i trang nhanh!", "success");
            } else if (loadTime > 5000) {
                showStatusMessage("T·∫£i trang ch·∫≠m", "error");
            }
        }
    });
}

/**
 * Global error handler with user feedback
 */
function setupErrorHandling() {
    window.addEventListener("error", function (e) {
        console.error("Global error:", e.error);
        showStatusMessage("C√≥ l·ªói x·∫£y ra!", "error");
    });

    // Handle unhandled promise rejections
    window.addEventListener("unhandledrejection", function (e) {
        console.error("Unhandled promise rejection:", e.reason);
        showStatusMessage("C√≥ l·ªói x·∫£y ra!", "error");
    });
}

/**
 * ====================================================================================
 * INITIALIZATION
 * ====================================================================================
 */

/**
 * Setup all common UI event handlers
 */
function setupCommonEventHandlers() {
    // Enhanced clipboard container feedback
    setupClipboardContainers();

    // Monitor form state
    setupFormMonitoring();

    // Setup security and performance indicators
    setupSecurityIndicators();
}

/**
 * Initialize all common utilities
 */
function initializeCommonUtils() {
    // Setup common UI handlers
    setupCommonEventHandlers();

    // Setup performance monitoring
    setupPerformanceMonitoring();

    // Setup error handling
    setupErrorHandling();

    console.log("Common UI Utilities initialized");
}

/**
 * ====================================================================================
 * EXPORTS
 * ====================================================================================
 */

// Export cho window object ƒë·ªÉ s·ª≠ d·ª•ng globally
if (typeof window !== "undefined") {
    // Export individual functions
    window.showStatusMessage = showStatusMessage;
    window.showFloatingAlert = showFloatingAlert;
    window.hideFloatingAlert = hideFloatingAlert;

    // Export setup functions
    window.setupClipboardContainers = setupClipboardContainers;
    window.setupFormMonitoring = setupFormMonitoring;
    window.setupSecurityIndicators = setupSecurityIndicators;
    window.setupPerformanceMonitoring = setupPerformanceMonitoring;
    window.setupErrorHandling = setupErrorHandling;
    window.setupCommonEventHandlers = setupCommonEventHandlers;
    window.initializeCommonUtils = initializeCommonUtils;

    // Export Role
    window.getRoleInfo = getRoleInfo;
    window.initializePageTitle = initializePageTitle;
    window.displayUserInfo = displayUserInfo;

    // Export as CommonUtils namespace
    window.CommonUtils = {
        // Notification functions
        showStatusMessage: showStatusMessage,
        showFloatingAlert: showFloatingAlert,
        hideFloatingAlert: hideFloatingAlert,

        // Setup functions
        setupClipboardContainers: setupClipboardContainers,
        setupFormMonitoring: setupFormMonitoring,
        setupSecurityIndicators: setupSecurityIndicators,
        setupPerformanceMonitoring: setupPerformanceMonitoring,
        setupErrorHandling: setupErrorHandling,
        setupCommonEventHandlers: setupCommonEventHandlers,

        // Main init
        init: initializeCommonUtils,
    };
}

// Export cho module systems (Node.js, ES6 modules)
if (typeof module !== "undefined" && module.exports) {
    module.exports = {
        showStatusMessage,
        showFloatingAlert,
        hideFloatingAlert,
        setupFormMonitoring,
        setupSecurityIndicators,
        setupPerformanceMonitoring,
        setupErrorHandling,
        setupCommonEventHandlers,
        initializeCommonUtils,
    };
}

/**
 * H√†m l·∫•y icon v√† t√™n role d·ª±a tr√™n checkLogin
 * @param {number} checkLogin - M√£ quy·ªÅn h·∫°n (0, 1, 2, 3, 777)
 * @returns {object} - Object ch·ª©a icon v√† text
 */
function getRoleInfo(checkLogin) {
    const roleMap = {
        0: { icon: "üëë", text: "Admin" },
        1: { icon: "üë§", text: "User" },
        2: { icon: "üîí", text: "Limited" },
        3: { icon: "üí°", text: "Basic" },
        777: { icon: "üë•", text: "Guest" },
    };

    return roleMap[checkLogin] || { icon: "‚ùì", text: "Unknown" };
}

/**
 * H√†m c·∫≠p nh·∫≠t title v·ªõi role icon
 * @param {HTMLElement} titleElement - Element ch·ª©a title
 * @param {object} auth - Object ch·ª©a th√¥ng tin auth user
 */
function updateTitleWithRoleEnhanced(titleElement, auth) {
    if (!titleElement || !auth) return;

    const roleInfo = getRoleInfo(parseInt(auth.checkLogin));
    const baseTitle = titleElement.textContent.split(" - ")[0];

    // Clear v√† rebuild v·ªõi proper structure
    titleElement.innerHTML = "";

    // Title text
    const titleText = document.createTextNode(`${baseTitle} - `);
    titleElement.appendChild(titleText);

    // Icon v·ªõi class theo role
    const iconSpan = document.createElement("span");
    iconSpan.className = "role-icon";

    // Th√™m class specific theo role
    const roleClass =
        {
            0: "admin",
            1: "user",
            2: "limited",
            3: "basic",
            777: "guest",
        }[parseInt(auth.checkLogin)] || "default";

    iconSpan.classList.add(roleClass);
    iconSpan.textContent = roleInfo.icon;
    titleElement.appendChild(iconSpan);

    // User name text
    const userText = document.createTextNode(
        ` ${auth.displayName || auth.username}`,
    );
    titleElement.appendChild(userText);
}

// Export enhanced version
window.updateTitleWithRoleEnhanced = updateTitleWithRoleEnhanced;

/**
 * V√≠ d·ª• s·ª≠ d·ª•ng trong c√°c trang
 */
function initializePageTitle() {
    try {
        const authData = localStorage.getItem("loginindex_auth");
        if (!authData) return;

        const auth = JSON.parse(authData);
        const titleElement = document.querySelector(
            "h1, .page-title, .header h1",
        );

        if (titleElement && auth.checkLogin !== undefined) {
            updateTitleWithRoleEnhanced(titleElement, auth);
        }

        console.log("Page title updated with role icon");
    } catch (error) {
        console.error("Error updating page title:", error);
    }
}

/**
 * H√†m hi·ªÉn th·ªã user info v·ªõi icon ·ªü sidebar ho·∫∑c header
 * @param {string} containerSelector - Selector c·ªßa container
 */
function displayUserInfo(containerSelector = ".user-info") {
    try {
        const authData = localStorage.getItem("loginindex_auth");
        if (!authData) return;

        const auth = JSON.parse(authData);
        const container = document.querySelector(containerSelector);

        if (container) {
            const roleInfo = getRoleInfo(parseInt(auth.checkLogin));
            container.innerHTML = `
                <span class="user-role-badge">
                    ${roleInfo.icon} ${auth.displayName || auth.username}
                    <small>(${roleInfo.text})</small>
                </span>
            `;
        }
    } catch (error) {
        console.error("Error displaying user info:", error);
    }
}

/**
 * CSS cho user role badge
 */
function injectRoleStyles() {
    if (document.getElementById("roleStyles")) return;

    const styles = document.createElement("style");
    styles.id = "roleStyles";
    styles.textContent = `
        /* ================== BEAUTIFUL .page-title STYLES - FIXED VERSION ================== */
        
        /* Beautiful gradient .page-title styles */
        .page-title {
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            margin: 20px 0;
            padding: 20px 15px;
            position: relative;
            letter-spacing: -0.02em;
            line-height: 1.2;
            transition: all 0.3s ease;
            
            /* Gradient ch·ªâ √°p d·ª•ng cho text */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            
            /* Subtle text shadow for depth */
            filter: drop-shadow(0 2px 4px rgba(102, 126, 234, 0.2));
        }

        /* FIX QUAN TR·ªåNG: Role icon styles - SPECIFIC CLASS */
        .page-title .role-icon {
            -webkit-text-fill-color: initial !important;
            background: none !important;
            color: #f39c12 !important;
            text-shadow: 
                0 0 10px rgba(243, 156, 18, 0.6),
                0 0 20px rgba(243, 156, 18, 0.3) !important;
            font-style: normal !important;
            font-size: 0.9em !important;
            margin: 0 8px !important;
            display: inline-block !important;
            animation: roleIconGlow 2s ease-in-out infinite !important;
            filter: drop-shadow(0 3px 6px rgba(243, 156, 18, 0.4)) !important;
            position: relative;
            z-index: 10;
        }

        /* Fallback cho browsers kh√¥ng support background-clip */
        @supports not (-webkit-background-clip: text) {
            .page-title {
                background: none;
                -webkit-text-fill-color: initial;
                color: #667eea;
                text-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
            }
            
            .page-title .role-icon {
                color: #f39c12 !important;
            }
        }

        /* Hover glow effect cho title */
        .page-title::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border-radius: 15px;
            transform: translate(-50%, -50%);
            z-index: -1;
            filter: blur(20px);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .page-title:hover::before {
            opacity: 1;
        }

        .page-title:hover {
            transform: translateY(-2px);
        }

        .page-title:hover .role-icon {
            animation: roleIconBounce 0.6s ease !important;
            text-shadow: 
                0 0 15px rgba(243, 156, 18, 0.8),
                0 0 25px rgba(243, 156, 18, 0.4) !important;
            transform: scale(1.1) !important;
        }

        /* Enhanced role icon animations */
        @keyframes roleIconGlow {
            0%, 100% {
                text-shadow: 
                    0 0 10px rgba(243, 156, 18, 0.6),
                    0 0 20px rgba(243, 156, 18, 0.3);
                transform: scale(1);
            }
            50% {
                text-shadow: 
                    0 0 15px rgba(243, 156, 18, 0.8),
                    0 0 25px rgba(243, 156, 18, 0.5);
                transform: scale(1.05);
            }
        }

        @keyframes roleIconBounce {
            0%, 100% {
                transform: scale(1.1);
            }
            25% {
                transform: scale(1.2) rotate(5deg);
            }
            50% {
                transform: scale(1.15) rotate(0deg);
            }
            75% {
                transform: scale(1.2) rotate(-5deg);
            }
        }

        /* Alternative icon colors cho t·ª´ng role */
        .page-title .role-icon.admin {
            color: #e74c3c !important;
            text-shadow: 
                0 0 10px rgba(231, 76, 60, 0.6),
                0 0 20px rgba(231, 76, 60, 0.3) !important;
        }

        .page-title .role-icon.user {
            color: #3498db !important;
            text-shadow: 
                0 0 10px rgba(52, 152, 219, 0.6),
                0 0 20px rgba(52, 152, 219, 0.3) !important;
        }

        .page-title .role-icon.limited {
            color: #95a5a6 !important;
            text-shadow: 
                0 0 10px rgba(149, 165, 166, 0.6),
                0 0 20px rgba(149, 165, 166, 0.3) !important;
        }

        .page-title .role-icon.basic {
            color: #f1c40f !important;
            text-shadow: 
                0 0 10px rgba(241, 196, 15, 0.6),
                0 0 20px rgba(241, 196, 15, 0.3) !important;
        }

        .page-title .role-icon.guest {
            color: #9b59b6 !important;
            text-shadow: 
                0 0 10px rgba(155, 89, 182, 0.6),
                0 0 20px rgba(155, 89, 182, 0.3) !important;
        }

        /* User role badge v·ªõi beautiful gradient */
        .user-role-badge {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 18px;
            border-radius: 25px;
            font-weight: 500;
            box-shadow: 
                0 4px 15px rgba(102, 126, 234, 0.3),
                0 2px 8px rgba(118, 75, 162, 0.2);
            font-size: 0.9rem;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .user-role-badge:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 20px rgba(102, 126, 234, 0.4),
                0 4px 12px rgba(118, 75, 162, 0.3);
        }

        .user-role-badge small {
            margin-left: 8px;
            opacity: 0.85;
            font-size: 0.8em;
            font-weight: 400;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .page-title {
                font-size: 1.8rem;
                padding: 15px 10px;
                margin: 15px 0;
            }
            
            .page-title .role-icon {
                font-size: 0.85em !important;
                margin: 0 6px !important;
            }
            
            .user-role-badge {
                padding: 8px 14px;
                font-size: 0.85rem;
            }
        }

        @media (max-width: 480px) {
            .page-title {
                font-size: 1.4rem;
                padding: 10px 5px;
            }
            
            .page-title .role-icon {
                font-size: 0.8em !important;
                margin: 0 4px !important;
            }
            
            .user-role-badge {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .page-title .role-icon {
                filter: brightness(1.2) drop-shadow(0 3px 6px rgba(243, 156, 18, 0.4)) !important;
            }
            
            .user-role-badge {
                background: linear-gradient(135deg, #4c51bf, #553c9a);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        /* Print styles */
        @media print {
            .page-title {
                background: none !important;
                -webkit-text-fill-color: initial !important;
                color: #000 !important;
                text-shadow: none !important;
                filter: none !important;
            }
            
            .page-title .role-icon {
                color: #000 !important;
                text-shadow: none !important;
                animation: none !important;
                filter: none !important;
            }
            
            .page-title::before {
                display: none;
            }
            
            .user-role-badge {
                background: #667eea !important;
                box-shadow: none !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .page-title {
                background: none !important;
                -webkit-text-fill-color: initial !important;
                color: #000 !important;
                border: 2px solid #000;
            }
            
            .page-title .role-icon {
                color: #000 !important;
                text-shadow: none !important;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            .page-title,
            .page-title::before,
            .page-title .role-icon,
            .user-role-badge {
                animation: none !important;
                transition: none !important;
            }
        }

        /* Focus accessibility */
        .page-title:focus-visible {
            outline: 3px solid rgba(102, 126, 234, 0.6);
            outline-offset: 4px;
        }

        .user-role-badge:focus-visible {
            outline: 2px solid rgba(255, 255, 255, 0.8);
            outline-offset: 2px;
        }
    `;

    document.head.appendChild(styles);
}

/**
 * C√°ch s·ª≠ d·ª•ng trong code hi·ªán t·∫°i c·ªßa b·∫°n:
 */

// 1. Thay th·∫ø ƒëo·∫°n code hi·ªán t·∫°i:
// if (auth.checkLogin === 0) {
//     titleElement.textContent += ' - üëë ' + auth.displayName;
// }

// B·∫±ng:
// updateTitleWithRole(titleElement, auth);

// 2. Ho·∫∑c s·ª≠ d·ª•ng c√°ch ng·∫Øn g·ªçn:
function updatePageTitleSimple() {
    try {
        const authData = JSON.parse(
            localStorage.getItem("loginindex_auth") || "{}",
        );
        const titleElement = document.querySelector(
            "h1, .page-title, .header h1",
        );

        if (titleElement && authData.checkLogin !== undefined) {
            const roleInfo = getRoleInfo(parseInt(authData.checkLogin));
            const baseTitle = titleElement.textContent.split(" - ")[0];
            titleElement.textContent = `${baseTitle} - ${roleInfo.icon} ${authData.displayName || authData.username}`;
        }
    } catch (error) {
        console.error("Error updating title:", error);
    }
}

// 3. Auto-initialize khi DOM ready
document.addEventListener("DOMContentLoaded", function () {
    injectRoleStyles();

    // Delay m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o auth data ƒë√£ load
    setTimeout(() => {
        initializePageTitle();
    }, 100);
});

// Export ƒë·ªÉ s·ª≠ d·ª•ng global
window.RoleManager = {
    getRoleInfo: getRoleInfo,
    updateTitleWithRoleEnhanced: updateTitleWithRoleEnhanced,
    displayUserInfo: displayUserInfo,
    initializePageTitle: initializePageTitle,
};

window.addEventListener("load", function () {
    const overlay = document.getElementById("loadingOverlay");
    if (overlay) {
        overlay.classList.remove("show");
    }
});



    // ========================================
    // date-utils.js
    // ========================================
/**
 * Date Utilities - Shared Date Formatting Functions
 *
 * SOURCE OF TRUTH for all date operations across the application.
 *
 * Usage:
 * <script src="../shared/js/date-utils.js"></script>
 * <script>
 *   const formatted = formatDate(new Date());
 *   const parsed = parseVietnameseDate("25/12/2024");
 * </script>
 */

/**
 * Format date to Vietnamese format (DD/MM/YYYY)
 * @param {Date|string|number} date - Date to format
 * @returns {string} Formatted date string
 */
function formatDate(date) {
    if (!date) return "";

    // Convert to Date object if needed
    if (!(date instanceof Date)) {
        date = new Date(date);
    }

    if (isNaN(date.getTime())) return "";

    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}

/**
 * Format date with time (DD/MM/YYYY, HH:mm)
 * @param {Date|string|number} date - Date to format
 * @returns {string} Formatted date-time string
 */
function formatDateTime(date) {
    if (!date) return "";

    if (!(date instanceof Date)) {
        date = new Date(date);
    }

    if (isNaN(date.getTime())) return "";

    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const year = date.getFullYear();
    const hour = date.getHours().toString().padStart(2, "0");
    const minute = date.getMinutes().toString().padStart(2, "0");
    return `${day}/${month}/${year}, ${hour}:${minute}`;
}

/**
 * Get current date-time formatted
 * @returns {string} Current date-time string
 */
function getFormattedDateTime() {
    return formatDateTime(new Date());
}

/**
 * Parse Vietnamese date string (DD/MM/YYYY or DD/MM/YYYY HH:mm)
 * @param {string} dateString - Date string to parse
 * @returns {Date|null} Parsed Date object or null
 */
function parseVietnameseDate(dateString) {
    if (!dateString) return null;

    try {
        const cleanDateString = dateString.replace(/,?\s*/g, " ").trim();
        const patterns = [
            /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\s+(\d{1,2}):(\d{2})/,
            /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,
        ];

        for (let pattern of patterns) {
            const match = cleanDateString.match(pattern);
            if (match) {
                const [, day, month, year, hour = 0, minute = 0] = match;
                return new Date(
                    parseInt(year),
                    parseInt(month) - 1,
                    parseInt(day),
                    parseInt(hour),
                    parseInt(minute)
                );
            }
        }

        const date = new Date(dateString);
        return isNaN(date.getTime()) ? null : date;
    } catch (error) {
        console.warn("[DateUtils] Error parsing date:", dateString, error);
        return null;
    }
}

/**
 * Get today's date in Vietnam timezone (YYYY-MM-DD for input fields)
 * @returns {string} Date string for input fields
 */
function getTodayVN() {
    const now = new Date();
    const vnTime = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Ho_Chi_Minh" }));
    return vnTime.toISOString().split("T")[0];
}

/**
 * Get current date formatted for HTML date input (YYYY-MM-DD)
 * @returns {string} Date string for input fields
 */
function getCurrentDateForInput() {
    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, "0");
    const day = now.getDate().toString().padStart(2, "0");
    return `${year}-${month}-${day}`;
}

/**
 * Format date for HTML date input (YYYY-MM-DD)
 * @param {string} dateStr - Date string (DD/MM/YYYY)
 * @returns {string} Date string for input fields (YYYY-MM-DD)
 */
function formatDateForInput(dateStr) {
    if (!dateStr) return "";
    const parts = dateStr.split("/");
    if (parts.length !== 3) return "";
    return `${parts[2]}-${parts[1]}-${parts[0]}`;
}

/**
 * Format date from HTML input to display format
 * @param {string} inputValue - Date from input (YYYY-MM-DD)
 * @returns {string} Display format (DD/MM/YYYY)
 */
function formatDateFromInput(inputValue) {
    if (!inputValue) return "";
    const parts = inputValue.split("-");
    if (parts.length !== 3) return "";
    return `${parts[2]}/${parts[1]}/${parts[0]}`;
}

/**
 * Compare two date strings (DD/MM/YYYY format)
 * @param {string} date1Str - First date
 * @param {string} date2Str - Second date
 * @returns {number} -1 if date1 < date2, 0 if equal, 1 if date1 > date2
 */
function compareDates(date1Str, date2Str) {
    const date1 = parseVietnameseDate(date1Str);
    const date2 = parseVietnameseDate(date2Str);

    if (!date1 && !date2) return 0;
    if (!date1) return -1;
    if (!date2) return 1;

    return date1.getTime() - date2.getTime();
}

/**
 * Convert date to timestamp
 * @param {Date|string} date - Date to convert
 * @returns {number} Timestamp in milliseconds
 */
function convertToTimestamp(date) {
    if (!date) return 0;
    if (date instanceof Date) return date.getTime();
    const parsed = parseVietnameseDate(date);
    return parsed ? parsed.getTime() : 0;
}

/**
 * Format number with commas (Vietnamese currency format)
 * @param {number|string} x - Number to format
 * @returns {string} Formatted number string
 */
function numberWithCommas(x) {
    if (x === null || x === undefined) return "0";
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Global exports
if (typeof window !== "undefined") {
    window.formatDate = formatDate;
    window.formatDateTime = formatDateTime;
    window.getFormattedDateTime = getFormattedDateTime;
    window.parseVietnameseDate = parseVietnameseDate;
    window.getTodayVN = getTodayVN;
    window.getCurrentDateForInput = getCurrentDateForInput;
    window.formatDateForInput = formatDateForInput;
    window.formatDateFromInput = formatDateFromInput;
    window.compareDates = compareDates;
    window.convertToTimestamp = convertToTimestamp;
    window.numberWithCommas = numberWithCommas;
}

console.log("[Date Utils] Module loaded");



    // ========================================
    // form-utils.js
    // ========================================
/**
 * Form Utilities - Shared Form/Input Helper Functions
 *
 * SOURCE OF TRUTH for form utilities across the application.
 *
 * Usage:
 * <script src="../shared/js/form-utils.js"></script>
 * <script>
 *   const clean = sanitizeInput(userInput);
 *   const id = generateUniqueID();
 *   const debouncedFn = debounce(myFunc, 300);
 * </script>
 */

/**
 * Sanitize user input to prevent XSS
 * @param {string} input - User input to sanitize
 * @returns {string} Sanitized string
 */
function sanitizeInput(input) {
    if (typeof input !== "string") return "";
    return input.replace(/[<>"'&]/g, "").trim();
}

/**
 * Generate a unique ID
 * @param {string} prefix - Optional prefix for the ID
 * @returns {string} Unique ID string
 */
function generateUniqueID(prefix = "") {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    return prefix ? `${prefix}_${timestamp}_${random}` : `${timestamp}_${random}`;
}

/**
 * Generate a unique filename for uploads
 * @param {string} extension - File extension (default: 'png')
 * @returns {string} Unique filename
 */
function generateUniqueFileName(extension = "png") {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}.${extension}`;
}

/**
 * Debounce function to limit execution frequency
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Throttle function to limit execution rate
 * @param {Function} func - Function to throttle
 * @param {number} limit - Minimum time between calls in milliseconds
 * @returns {Function} Throttled function
 */
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}

/**
 * Copy text to clipboard
 * @param {string} text - Text to copy
 * @returns {Promise<boolean>} Success status
 */
async function copyToClipboard(text) {
    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            return true;
        }
        // Fallback for older browsers
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-9999px";
        document.body.appendChild(textArea);
        textArea.select();
        const success = document.execCommand("copy");
        document.body.removeChild(textArea);
        return success;
    } catch (error) {
        console.error("[FormUtils] Copy to clipboard failed:", error);
        return false;
    }
}

/**
 * Export array data to CSV file
 * @param {Array} data - Array of objects to export
 * @param {string} filename - Output filename
 * @param {Array} headers - Optional custom headers
 */
function exportToCSV(data, filename = "export.csv", headers = null) {
    if (!data || !data.length) {
        console.warn("[FormUtils] No data to export");
        return;
    }

    const keys = headers || Object.keys(data[0]);
    const csvRows = [];

    // Header row
    csvRows.push(keys.join(","));

    // Data rows
    for (const row of data) {
        const values = keys.map((key) => {
            const val = row[key];
            if (val === null || val === undefined) return "";
            const escaped = String(val).replace(/"/g, '""');
            return `"${escaped}"`;
        });
        csvRows.push(values.join(","));
    }

    const csvString = csvRows.join("\n");
    const blob = new Blob(["\ufeff" + csvString], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();

    URL.revokeObjectURL(url);
}

/**
 * Validate email format
 * @param {string} email - Email to validate
 * @returns {boolean} Is valid email
 */
function isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

/**
 * Validate phone number (Vietnamese format)
 * @param {string} phone - Phone number to validate
 * @returns {boolean} Is valid phone
 */
function isValidPhone(phone) {
    const phoneRegex = /^(0|\+84)[0-9]{9,10}$/;
    return phoneRegex.test(phone.replace(/\s/g, ""));
}

/**
 * Get value from form input safely
 * @param {string} elementId - Element ID
 * @param {*} defaultValue - Default value if not found
 * @returns {*} Input value or default
 */
function getInputValue(elementId, defaultValue = "") {
    const element = document.getElementById(elementId);
    return element ? element.value : defaultValue;
}

/**
 * Set value to form input safely
 * @param {string} elementId - Element ID
 * @param {*} value - Value to set
 */
function setInputValue(elementId, value) {
    const element = document.getElementById(elementId);
    if (element) {
        element.value = value;
    }
}

// Global exports
if (typeof window !== "undefined") {
    window.sanitizeInput = sanitizeInput;
    window.generateUniqueID = generateUniqueID;
    window.generateUniqueFileName = generateUniqueFileName;
    window.debounce = debounce;
    window.throttle = throttle;
    window.copyToClipboard = copyToClipboard;
    window.exportToCSV = exportToCSV;
    window.isValidEmail = isValidEmail;
    window.isValidPhone = isValidPhone;
    window.getInputValue = getInputValue;
    window.setInputValue = setInputValue;
}

console.log("[Form Utils] Module loaded");



    // ========================================
    // shared-cache-manager.js
    // ========================================
/**
 * SHARED PERSISTENT CACHE MANAGER
 * File: shared-cache-manager.js
 *
 * WRAPPER FILE - Backward compatibility layer
 * SOURCE OF TRUTH: /shared/browser/persistent-cache.js
 *
 * This file is kept for backward compatibility with existing code using:
 *   <script src="../shared/js/shared-cache-manager.js"></script>
 *
 * For new ES Module code, import directly from:
 *   import { PersistentCacheManager } from '/shared/browser/persistent-cache.js';
 */

class PersistentCacheManager {
    constructor(config = {}) {
        this.cache = new Map();
        this.maxAge = config.CACHE_EXPIRY || 24 * 60 * 60 * 1000; // 24h default
        this.stats = { hits: 0, misses: 0 };
        this.storageKey = config.storageKey || 'app_cache';
        this.saveTimeout = null;
        this.cleanupInterval = null;

        // Load existing cache from localStorage
        this.loadFromStorage();

        // Auto cleanup expired items every 5 minutes
        this.startAutoCleanup();
    }

    /**
     * Save cache to localStorage
     */
    saveToStorage() {
        try {
            const cacheData = Array.from(this.cache.entries());
            localStorage.setItem(this.storageKey, JSON.stringify(cacheData));
            logger.log(`üíæ Saved ${cacheData.length} items to localStorage (${this.storageKey})`);
        } catch (error) {
            logger.warn('Cannot save cache to localStorage:', error);
            // If quota exceeded, clear old cache
            if (error.name === 'QuotaExceededError') {
                this.clearExpired();
                try {
                    const cacheData = Array.from(this.cache.entries());
                    localStorage.setItem(this.storageKey, JSON.stringify(cacheData));
                } catch (retryError) {
                    logger.error('Failed to save cache even after cleanup:', retryError);
                }
            }
        }
    }

    /**
     * Load cache from localStorage
     */
    loadFromStorage() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (!stored) return;

            const cacheData = JSON.parse(stored);
            const now = Date.now();
            let validCount = 0;

            cacheData.forEach(([key, value]) => {
                if (value.expires > now) {
                    this.cache.set(key, value);
                    validCount++;
                }
            });

            logger.log(`üì¶ Loaded ${validCount} valid items from localStorage (${this.storageKey})`);
        } catch (error) {
            logger.warn('Cannot load cache from localStorage:', error);
            // Clear corrupted cache
            localStorage.removeItem(this.storageKey);
        }
    }

    /**
     * Debounced save to localStorage (avoid too frequent writes)
     */
    debouncedSave() {
        if (this.saveTimeout) clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
            this.saveToStorage();
        }, 2000);
    }

    /**
     * Set cache value
     * @param {string} key
     * @param {*} value
     * @param {string} type - Cache type for grouping
     */
    set(key, value, type = 'general') {
        const cacheKey = type ? `${type}_${key}` : key;
        this.cache.set(cacheKey, {
            value,
            timestamp: Date.now(),
            expires: Date.now() + this.maxAge,
            type,
        });
        this.debouncedSave();
    }

    /**
     * Get cache value
     * @param {string} key
     * @param {string} type
     * @returns {*} Cached value or null
     */
    get(key, type = 'general') {
        const cacheKey = type ? `${type}_${key}` : key;
        const cached = this.cache.get(cacheKey);

        if (cached && cached.expires > Date.now()) {
            this.stats.hits++;
            logger.log(`‚úî Cache HIT: ${cacheKey}`);
            return cached.value;
        }

        if (cached) {
            // Expired, remove it
            this.cache.delete(cacheKey);
        }

        this.stats.misses++;
        logger.log(`‚úó Cache MISS: ${cacheKey}`);
        return null;
    }

    /**
     * Check if key exists and is valid
     * @param {string} key
     * @param {string} type
     * @returns {boolean}
     */
    has(key, type = 'general') {
        const cacheKey = type ? `${type}_${key}` : key;
        const cached = this.cache.get(cacheKey);
        return cached && cached.expires > Date.now();
    }

    /**
     * Delete specific cache entry
     * @param {string} key
     * @param {string} type
     */
    delete(key, type = 'general') {
        const cacheKey = type ? `${type}_${key}` : key;
        const deleted = this.cache.delete(cacheKey);
        if (deleted) {
            this.debouncedSave();
        }
        return deleted;
    }

    /**
     * Clear cache by type or all
     * @param {string|null} type
     */
    clear(type = null) {
        if (type) {
            let cleared = 0;
            for (const [key, value] of this.cache.entries()) {
                if (value.type === type) {
                    this.cache.delete(key);
                    cleared++;
                }
            }
            logger.log(`üóëÔ∏è Cleared ${cleared} items of type: ${type}`);
        } else {
            this.cache.clear();
            localStorage.removeItem(this.storageKey);
            logger.log('üóëÔ∏è Cleared ALL cache');
        }
        this.stats = { hits: 0, misses: 0 };
        this.saveToStorage();
    }

    /**
     * Clean expired entries
     * @returns {number} Number of cleaned entries
     */
    cleanExpired() {
        const now = Date.now();
        let cleaned = 0;
        for (const [key, value] of this.cache.entries()) {
            if (value.expires <= now) {
                this.cache.delete(key);
                cleaned++;
            }
        }
        if (cleaned > 0) {
            logger.log(`üßπ Cleaned ${cleaned} expired entries`);
            this.saveToStorage();
        }
        return cleaned;
    }

    /**
     * Invalidate cache by pattern
     * @param {string} pattern
     * @returns {number} Number of invalidated entries
     */
    invalidatePattern(pattern) {
        let invalidated = 0;
        for (const [key] of this.cache.entries()) {
            if (key.includes(pattern)) {
                this.cache.delete(key);
                invalidated++;
            }
        }
        if (invalidated > 0) {
            logger.log(`üóëÔ∏è Invalidated ${invalidated} entries matching: ${pattern}`);
            this.debouncedSave();
        }
        return invalidated;
    }

    /**
     * Get cache statistics
     */
    getStats() {
        const hitRate = this.stats.hits + this.stats.misses > 0
            ? (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(2)
            : 0;

        return {
            hits: this.stats.hits,
            misses: this.stats.misses,
            hitRate: `${hitRate}%`,
            totalEntries: this.cache.size,
            storageKey: this.storageKey,
            maxAge: this.maxAge,
        };
    }

    /**
     * Get storage size estimate
     */
    getStorageSize() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (!stored) return 0;
            // Return size in KB
            return (stored.length * 2 / 1024).toFixed(2) + ' KB';
        } catch (error) {
            return 'Unknown';
        }
    }

    /**
     * Start auto cleanup interval
     */
    startAutoCleanup() {
        // Clean expired items every 5 minutes
        this.cleanupInterval = setInterval(() => {
            this.cleanExpired();
        }, 5 * 60 * 1000);
    }

    /**
     * Stop auto cleanup (call when destroying instance)
     */
    stopAutoCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
    }

    /**
     * Destroy cache manager (cleanup)
     */
    destroy() {
        this.stopAutoCleanup();
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
        this.saveToStorage();
        this.cache.clear();
    }
}

// Export to window
if (typeof window !== 'undefined') {
    window.PersistentCacheManager = PersistentCacheManager;
}

// Module export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { PersistentCacheManager };
}



    // ========================================
    // notification-system.js
    // ========================================
/**
 * Notification System - Script-Tag Compatible Wrapper
 *
 * SOURCE OF TRUTH: /shared/browser/notification-system.js (ES Module)
 *
 * This file provides window.* exports for legacy script-tag usage.
 * For ES Module usage, import from '/shared/browser/notification-system.js'.
 *
 * Usage:
 * <script src="../shared/js/notification-system.js"></script>
 * <script>
 *   notificationManager.success('Saved!');
 *   notificationManager.error('Error!');
 *   const confirmed = await notificationManager.confirm('Are you sure?');
 * </script>
 */

// =====================================================
// NOTIFICATION CONFIGURATION
// =====================================================

const NOTIFICATION_CONFIG = {
    durations: {
        success: 2000,
        error: 4000,
        warning: 3000,
        info: 3000,
    },
    icons: {
        success: 'check-circle',
        error: 'x-circle',
        warning: 'alert-triangle',
        info: 'info',
        loading: 'loader',
    },
    titles: {
        success: 'Th√†nh c√¥ng',
        error: 'L·ªói',
        warning: 'C·∫£nh b√°o',
        loading: 'ƒêang t·∫£i',
    },
    zIndex: {
        container: 99999,
        overlay: 2999,
        confirmOverlay: 10010,
    },
};

// =====================================================
// NOTIFICATION MANAGER CLASS
// =====================================================

class NotificationManager {
    constructor(options = {}) {
        this.container = null;
        this.notifications = new Map();
        this.notificationCounter = 0;
        this.config = { ...NOTIFICATION_CONFIG, ...options };
        this._stylesInjected = false;
        this.init();
    }

    init() {
        // Wait for DOM to be ready if body doesn't exist yet
        if (!document.body) {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => this.init());
            } else {
                // Fallback: try again after a short delay
                setTimeout(() => this.init(), 10);
            }
            return;
        }

        if (!this._stylesInjected) {
            this._injectStyles();
            this._stylesInjected = true;
        }

        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        this.container.className = 'toast-container';
        document.body.appendChild(this.container);
    }

    show(message, type = 'info', duration = 3000, options = {}) {
        // Ensure container is ready
        if (!this.container) {
            this.init();
            // If still not ready (waiting for DOM), queue the notification
            if (!this.container) {
                setTimeout(() => this.show(message, type, duration, options), 50);
                return null;
            }
        }

        const {
            showOverlay = false,
            showProgress = true,
            persistent = false,
            icon = null,
            title = null,
        } = options;

        if (showOverlay || persistent) this.clearAll();

        const notificationId = ++this.notificationCounter;
        const notification = document.createElement('div');
        notification.className = `toast ${type}`;
        notification.dataset.id = notificationId;

        const selectedIcon = icon || this.config.icons[type] || 'bell';

        const iconHtml = `<i data-lucide="${selectedIcon}" class="toast-icon ${type === 'loading' ? 'spinning' : ''}"></i>`;
        const titleHtml = title ? `<div class="toast-title">${title}</div>` : '';
        const messageHtml = `<div class="toast-message">${message}</div>`;
        const closeBtn = !persistent
            ? `<button class="toast-close"><i data-lucide="x"></i></button>`
            : '';

        notification.innerHTML = `
            ${iconHtml}
            <div class="toast-content">
                ${titleHtml}
                ${messageHtml}
            </div>
            ${closeBtn}
            ${showProgress && duration > 0 ? '<div class="toast-progress"></div>' : ''}
        `;

        const closeBtnEl = notification.querySelector('.toast-close');
        if (closeBtnEl) {
            closeBtnEl.onclick = () => this.remove(notificationId);
        }

        if (showProgress && duration > 0) {
            notification.style.setProperty('--duration', duration + 'ms');
        }

        this.container.appendChild(notification);

        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }

        this.notifications.set(notificationId, {
            element: notification,
            type,
            timeout: null,
            showOverlay,
        });

        if (showOverlay) {
            this.showOverlay();
            document.body.style.overflow = 'hidden';
        }

        requestAnimationFrame(() => notification.classList.add('show'));

        if (duration > 0 && !persistent) {
            const timeoutId = setTimeout(
                () => this.remove(notificationId),
                duration,
            );
            this.notifications.get(notificationId).timeout = timeoutId;
        }

        return notificationId;
    }

    remove(notificationId) {
        const notification = this.notifications.get(notificationId);
        if (!notification) return;

        if (notification.timeout) clearTimeout(notification.timeout);
        notification.element.classList.remove('show');

        setTimeout(() => {
            if (notification.element && notification.element.parentNode) {
                notification.element.parentNode.removeChild(notification.element);
            }
            this.notifications.delete(notificationId);
            if (notification.showOverlay) this.hideOverlay();
        }, 300);
    }

    clearAll() {
        for (const [id] of this.notifications) this.remove(id);
        this.forceHideOverlay();
    }

    forceHideOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) overlay.classList.remove('show');
        document.body.style.overflow = 'auto';
    }

    showOverlay() {
        let overlay = document.getElementById('loading-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'loading-overlay';
            overlay.className = 'loading-overlay';
            document.body.appendChild(overlay);
        }
        overlay.classList.add('show');
    }

    hideOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) overlay.classList.remove('show');
        document.body.style.overflow = 'auto';
    }

    // Convenience methods
    loading(message = 'ƒêang x·ª≠ l√Ω...', title = null) {
        return this.show(message, 'info', 0, {
            showOverlay: true,
            persistent: true,
            icon: 'loader',
            title: title || this.config.titles.loading,
        });
    }

    success(message, duration = this.config.durations.success, title = null) {
        return this.show(message, 'success', duration, {
            showProgress: true,
            title: title || this.config.titles.success,
        });
    }

    error(message, duration = this.config.durations.error, title = null) {
        return this.show(message, 'error', duration, {
            showProgress: true,
            title: title || this.config.titles.error,
        });
    }

    warning(message, duration = this.config.durations.warning, title = null) {
        return this.show(message, 'warning', duration, {
            showProgress: true,
            title: title || this.config.titles.warning,
        });
    }

    info(message, duration = this.config.durations.info, title = null) {
        return this.show(message, 'info', duration, {
            showProgress: true,
            title: title,
        });
    }

    // Action-specific methods
    uploading(current, total) {
        const message = `ƒêang t·∫£i l√™n ${current}/${total} ·∫£nh`;
        return this.show(message, 'info', 0, {
            showOverlay: true,
            persistent: true,
            icon: 'upload-cloud',
            title: 'Upload',
        });
    }

    deleting(message = 'ƒêang x√≥a...') {
        return this.show(message, 'warning', 0, {
            showOverlay: true,
            persistent: true,
            icon: 'trash-2',
            title: 'X√≥a d·ªØ li·ªáu',
        });
    }

    saving(message = 'ƒêang l∆∞u...') {
        return this.show(message, 'info', 0, {
            showOverlay: true,
            persistent: true,
            icon: 'save',
            title: 'L∆∞u',
        });
    }

    loadingData(message = 'ƒêang t·∫£i d·ªØ li·ªáu...') {
        return this.show(message, 'info', 0, {
            showOverlay: true,
            persistent: true,
            icon: 'database',
            title: 'T·∫£i d·ªØ li·ªáu',
        });
    }

    processing(message = 'ƒêang x·ª≠ l√Ω...') {
        return this.show(message, 'info', 0, {
            showOverlay: true,
            persistent: true,
            icon: 'cpu',
            title: 'X·ª≠ l√Ω',
        });
    }

    // Custom confirm dialog
    confirm(message, title = 'X√°c nh·∫≠n') {
        return new Promise((resolve) => {
            const overlay = document.createElement('div');
            overlay.className = 'custom-confirm-overlay';
            overlay.id = 'customConfirmOverlay';

            const modal = document.createElement('div');
            modal.className = 'custom-confirm-modal';
            modal.innerHTML = `
                <div class="custom-confirm-header">
                    <i data-lucide="alert-circle" class="custom-confirm-icon"></i>
                    <h3>${title}</h3>
                </div>
                <div class="custom-confirm-body">
                    <p>${message}</p>
                </div>
                <div class="custom-confirm-footer">
                    <button class="custom-confirm-btn custom-confirm-cancel">
                        <i data-lucide="x"></i>
                        H·ªßy
                    </button>
                    <button class="custom-confirm-btn custom-confirm-ok">
                        <i data-lucide="check"></i>
                        ƒê·ªìng √Ω
                    </button>
                </div>
            `;

            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }

            requestAnimationFrame(() => {
                overlay.classList.add('show');
            });

            const closeModal = (result) => {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    resolve(result);
                }, 200);
            };

            const cancelBtn = modal.querySelector('.custom-confirm-cancel');
            const okBtn = modal.querySelector('.custom-confirm-ok');

            cancelBtn.onclick = () => closeModal(false);
            okBtn.onclick = () => closeModal(true);

            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    closeModal(false);
                }
            };

            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    closeModal(false);
                    document.removeEventListener('keydown', handleKeydown);
                } else if (e.key === 'Enter') {
                    closeModal(true);
                    document.removeEventListener('keydown', handleKeydown);
                }
            };
            document.addEventListener('keydown', handleKeydown);

            okBtn.focus();
        });
    }

    _injectStyles() {
        const styles = `
<style id="notification-system-styles">
.toast-container {
    position: fixed;
    top: 80px;
    right: var(--spacing-xl, 24px);
    z-index: ${this.config.zIndex.container};
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md, 12px);
    pointer-events: none;
    max-width: 420px;
}

.toast {
    min-width: 320px;
    padding: var(--spacing-lg, 16px);
    background: white;
    border-radius: var(--radius-lg, 12px);
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-md, 12px);
    opacity: 0;
    transform: translateX(400px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: auto;
    position: relative;
    overflow: hidden;
    border-left: 4px solid;
}

.toast.show { opacity: 1; transform: translateX(0); }
.toast.success { border-left-color: var(--success, #10b981); }
.toast.error { border-left-color: var(--danger, #ef4444); }
.toast.warning { border-left-color: var(--warning, #f59e0b); }
.toast.info { border-left-color: var(--info, #3b82f6); }

.toast-icon { width: 24px; height: 24px; flex-shrink: 0; margin-top: 2px; }
.toast.success .toast-icon { color: var(--success, #10b981); }
.toast.error .toast-icon { color: var(--danger, #ef4444); }
.toast.warning .toast-icon { color: var(--warning, #f59e0b); }
.toast.info .toast-icon { color: var(--info, #3b82f6); }

.toast-icon.spinning { animation: notification-spin 1s linear infinite; }
@keyframes notification-spin { to { transform: rotate(360deg); } }

.toast-content { flex: 1; min-width: 0; }
.toast-title { font-weight: 600; color: var(--text-primary, #111827); margin-bottom: 4px; font-size: 0.9375rem; }
.toast-message { font-size: 0.875rem; color: var(--text-secondary, #6b7280); line-height: 1.5; }

.toast-close {
    width: 28px; height: 28px; border: none; background: transparent;
    color: var(--text-tertiary, #9ca3af); border-radius: var(--radius, 8px);
    display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.15s; flex-shrink: 0;
}
.toast-close:hover { background: var(--gray-100, #f3f4f6); color: var(--text-primary, #111827); }
.toast-close i { width: 16px; height: 16px; }

.toast-progress {
    position: absolute; bottom: 0; left: 0; height: 3px; width: 100%;
    background: linear-gradient(90deg, var(--primary, #6366f1) 0%, var(--primary-light, #818cf8) 100%);
    transform-origin: left; animation: notification-progress var(--duration, 3000ms) linear forwards;
}
.toast.success .toast-progress { background: linear-gradient(90deg, var(--success, #10b981) 0%, #34d399 100%); }
.toast.error .toast-progress { background: linear-gradient(90deg, var(--danger, #ef4444) 0%, #f87171 100%); }
.toast.warning .toast-progress { background: linear-gradient(90deg, var(--warning, #f59e0b) 0%, #fbbf24 100%); }
@keyframes notification-progress { to { transform: scaleX(0); } }

.loading-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.5); z-index: ${this.config.zIndex.overlay};
    opacity: 0; transition: opacity 0.3s; pointer-events: none; backdrop-filter: blur(2px);
}
.loading-overlay.show { opacity: 1; pointer-events: auto; }

@media (max-width: 768px) {
    .toast-container { top: var(--spacing-md, 12px); right: var(--spacing-md, 12px); left: var(--spacing-md, 12px); max-width: none; }
    .toast { min-width: auto; width: 100%; }
}

/* Custom Confirm Dialog */
.custom-confirm-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.5); z-index: ${this.config.zIndex.confirmOverlay};
    display: flex; align-items: center; justify-content: center;
    opacity: 0; transition: opacity 0.2s ease-out; backdrop-filter: blur(2px);
}
.custom-confirm-overlay.show { opacity: 1; }

.custom-confirm-modal {
    background: white; border-radius: 16px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    max-width: 420px; width: 90%; transform: scale(0.95) translateY(-20px);
    transition: transform 0.2s ease-out; overflow: hidden;
}
.custom-confirm-overlay.show .custom-confirm-modal { transform: scale(1) translateY(0); }

.custom-confirm-header {
    padding: 20px 24px 16px; display: flex; align-items: center; gap: 12px;
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white;
}
.custom-confirm-header h3 { margin: 0; font-size: 18px; font-weight: 600; }
.custom-confirm-icon { width: 24px; height: 24px; }

.custom-confirm-body { padding: 24px; }
.custom-confirm-body p { margin: 0; font-size: 15px; color: #374151; line-height: 1.6; }

.custom-confirm-footer {
    padding: 16px 24px; display: flex; gap: 12px; justify-content: flex-end;
    background: #f9fafb; border-top: 1px solid #e5e7eb;
}

.custom-confirm-btn {
    padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 500;
    cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.15s; border: none;
}
.custom-confirm-btn i { width: 16px; height: 16px; }

.custom-confirm-cancel { background: white; color: #6b7280; border: 1px solid #d1d5db; }
.custom-confirm-cancel:hover { background: #f3f4f6; border-color: #9ca3af; }

.custom-confirm-ok { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; }
.custom-confirm-ok:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4); }
.custom-confirm-ok:focus { outline: none; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3); }
</style>`;

        document.head.insertAdjacentHTML('beforeend', styles);
    }
}

// =====================================================
// GLOBAL EXPORTS
// =====================================================

if (typeof window !== 'undefined') {
    window.NotificationManager = NotificationManager;
    window.NOTIFICATION_CONFIG = NOTIFICATION_CONFIG;
    window.notificationManager = new NotificationManager();
}

// Module exports
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { NotificationManager, NOTIFICATION_CONFIG };
}

console.log('[Notification System] Module loaded');



    // ========================================
    // shared-auth-manager.js
    // ========================================
/**
 * SHARED AUTHENTICATION MANAGER
 * File: shared-auth-manager.js
 *
 * ‚ö†Ô∏è DEPRECATED: This wrapper file is for backward compatibility only.
 *
 * SOURCE OF TRUTH: /shared/browser/auth-manager.js
 *
 * MIGRATION GUIDE:
 * ================
 * For ES Modules (recommended):
 *   import { AuthManager } from '/shared/browser/auth-manager.js';
 *
 * For script-tag (deprecated):
 *   <script type="module" src="../shared/esm/compat.js"></script>
 *   This auto-initializes window.authManager from the ES module source.
 *
 * This file contains duplicated logic and will be removed in future.
 * Please migrate to ES modules when possible.
 */

// Log deprecation warning once
if (typeof window !== 'undefined' && !window._sharedAuthManagerWarned) {
    console.warn('[AuthManager] ‚ö†Ô∏è DEPRECATED: shared-auth-manager.js s·∫Ω b·ªã x√≥a. D√πng ES module t·ª´ /shared/browser/auth-manager.js');
    window._sharedAuthManagerWarned = true;
}

// Prevent redeclaration if already loaded
if (typeof window !== 'undefined' && window.AuthManager) {
    console.log('‚ö†Ô∏è AuthManager already loaded, skipping redeclaration');
} else {
    class AuthManager {
    constructor(options = {}) {
        this.storageKey = options.storageKey || 'loginindex_auth';
        this.redirectUrl = options.redirectUrl || '/index.html';
        this.sessionDuration = options.sessionDuration || 8 * 60 * 60 * 1000; // 8 hours
        this.rememberDuration = options.rememberDuration || 30 * 24 * 60 * 60 * 1000; // 30 days
        this.requiredPermissions = options.requiredPermissions || [];
    }

    /**
     * Check if user is authenticated
     * @returns {boolean}
     */
    isAuthenticated() {
        const authData = this.getAuthData();
        if (!authData) return false;

        // Check if session expired
        if (this.isSessionExpired(authData)) {
            this.logout('Session expired');
            return false;
        }

        return authData.isLoggedIn === 'true' || authData.isLoggedIn === true;
    }

    /**
     * Get auth data from storage
     * @returns {object|null}
     */
    getAuthData() {
        try {
            // Try sessionStorage first (session-only login)
            let authDataStr = sessionStorage.getItem(this.storageKey);
            let storage = 'session';

            // If not in session, try localStorage (remember me)
            if (!authDataStr) {
                authDataStr = localStorage.getItem(this.storageKey);
                storage = 'local';
            }

            if (!authDataStr) return null;

            const authData = JSON.parse(authDataStr);
            authData._storage = storage;
            return authData;
        } catch (error) {
            logger.error('Error reading auth data:', error);
            return null;
        }
    }

    /**
     * Alias for getAuthData (backward compatibility)
     * @returns {object|null}
     */
    getAuthState() {
        return this.getAuthData();
    }

    /**
     * Save auth data to storage
     * @param {object} authData
     * @param {boolean} rememberMe
     */
    saveAuthData(authData, rememberMe = false) {
        try {
            const dataToSave = {
                ...authData,
                timestamp: Date.now(),
                expiresAt: Date.now() + (rememberMe ? this.rememberDuration : this.sessionDuration),
                isRemembered: rememberMe
            };

            const authDataStr = JSON.stringify(dataToSave);

            if (rememberMe) {
                localStorage.setItem(this.storageKey, authDataStr);
            } else {
                sessionStorage.setItem(this.storageKey, authDataStr);
            }

            logger.log('‚úÖ Auth data saved to', rememberMe ? 'localStorage' : 'sessionStorage');
        } catch (error) {
            logger.error('Error saving auth data:', error);
        }
    }

    /**
     * Check if session is expired
     * @param {object} authData
     * @returns {boolean}
     */
    isSessionExpired(authData) {
        if (!authData.expiresAt) {
            // Legacy data without expiry - check timestamp
            const duration = authData.isRemembered ? this.rememberDuration : this.sessionDuration;
            return Date.now() - (authData.timestamp || 0) > duration;
        }
        return Date.now() > authData.expiresAt;
    }

    /**
     * Get user info
     * @returns {object|null}
     */
    getUserInfo() {
        const authData = this.getAuthData();
        if (!authData) return null;

        return {
            username: authData.username,
            displayName: authData.displayName,
            checkLogin: authData.checkLogin,
            uid: authData.uid,
            userType: authData.userType,
            pagePermissions: authData.pagePermissions || []
        };
    }

    /**
     * Check if user has permission for current page
     * ALL users (including Admin) check detailedPermissions - NO bypass
     * @param {string} pageName
     * @returns {boolean}
     */
    hasPagePermission(pageName) {
        const authData = this.getAuthData();
        if (!authData) return false;

        // ALL users check detailedPermissions - NO bypass
        if (authData.detailedPermissions && authData.detailedPermissions[pageName]) {
            const pagePerms = authData.detailedPermissions[pageName];
            return Object.values(pagePerms).some(v => v === true);
        }

        return false;
    }

    // getPermissionLevel() ‚Äî REMOVED: legacy checkLogin system migrated to detailedPermissions

    // hasPermissionLevel() ‚Äî REMOVED: legacy checkLogin system migrated to detailedPermissions

    /**
     * Check if user has specific detailed permission
     * ALL users (including Admin) check detailedPermissions - NO bypass
     * @param {string} pageId
     * @param {string} action
     * @returns {boolean}
     */
    hasDetailedPermission(pageId, action) {
        const authData = this.getAuthData();
        // ALL users check detailedPermissions - NO bypass
        if (!authData?.detailedPermissions?.[pageId]) return false;
        return authData.detailedPermissions[pageId][action] === true;
    }

    /**
     * Check if user has admin template (for UI display only)
     * QUAN TR·ªåNG: Kh√¥ng d√πng ƒë·ªÉ bypass permission - ch·ªâ ƒë·ªÉ hi·ªÉn th·ªã UI
     * @returns {boolean}
     */
    isAdminTemplate() {
        const authData = this.getAuthData();
        return authData?.roleTemplate === 'admin';
    }

    // isAdmin() ‚Äî REMOVED: use isAdminTemplate() instead

    // hasPermission() ‚Äî REMOVED: legacy alias for hasPermissionLevel

    /**
     * Logout user
     * @param {string} reason
     */
    logout(reason = '') {
        if (reason) {
            logger.log('Logging out:', reason);
        }

        // Clear both storages
        sessionStorage.removeItem(this.storageKey);
        localStorage.removeItem(this.storageKey);

        // Redirect to login
        if (typeof window !== 'undefined') {
            window.location.href = this.redirectUrl;
        }
    }

    /**
     * Verify authentication and redirect if not authenticated
     * @returns {boolean}
     */
    requireAuth() {
        if (!this.isAuthenticated()) {
            logger.log('Not authenticated, redirecting to login...');
            this.logout('Authentication required');
            return false;
        }
        return true;
    }

    /**
     * Verify page permission and redirect if not authorized
     * @param {string} pageName
     * @returns {boolean}
     */
    requirePagePermission(pageName) {
        if (!this.requireAuth()) return false;

        if (!this.hasPagePermission(pageName)) {
            logger.warn('Access denied to page:', pageName);
            alert('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p trang n√†y');
            window.location.href = '/live/index.html';
            return false;
        }

        return true;
    }

    // getRoleInfo() ‚Äî REMOVED: legacy checkLogin-based role info, use standalone getRoleInfo() in common-utils for UI display

    /**
     * Extend session (refresh expiry time)
     */
    extendSession() {
        const authData = this.getAuthData();
        if (!authData) return;

        const isRemembered = authData.isRemembered || authData._storage === 'local';
        this.saveAuthData(authData, isRemembered);
        logger.log('‚úÖ Session extended');
    }

    /**
     * Get session info
     * @returns {object}
     */
    getSessionInfo() {
        const authData = this.getAuthData();
        if (!authData) {
            return {
                authenticated: false,
                expiresIn: 0,
                storage: null
            };
        }

        const now = Date.now();
        const expiresIn = authData.expiresAt ? authData.expiresAt - now : 0;

        return {
            authenticated: true,
            expiresIn: Math.max(0, expiresIn),
            expiresInMinutes: Math.floor(expiresIn / 60000),
            storage: authData._storage,
            isRemembered: authData.isRemembered || false,
            user: this.getUserInfo()
        };
    }
    }

    // Export to window
    if (typeof window !== 'undefined') {
        window.AuthManager = AuthManager;
    }

    // Module export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = { AuthManager };
    }
}



    // ========================================
    // AUTO-INITIALIZATION
    // ========================================

    // Mark bundle as loaded
    window.CORE_BUNDLE_LOADED = true;
    window.CORE_UTILITIES_LOADED = true;

    // Auto-initialize authManager if AuthManager exists
    if (typeof AuthManager !== 'undefined' && !window.authManager) {
        try {
            window.authManager = new AuthManager({
                redirectUrl: '../index.html',
                sessionDuration: 8 * 60 * 60 * 1000,
                rememberDuration: 30 * 24 * 60 * 60 * 1000
            });
            console.log('[Core Bundle] AuthManager auto-initialized');
        } catch (e) {
            console.warn('[Core Bundle] Failed to auto-init AuthManager:', e);
        }
    }

    // Auto-initialize notificationManager if NotificationManager exists
    if (typeof NotificationManager !== 'undefined' && !window.notificationManager) {
        try {
            window.notificationManager = new NotificationManager();
            console.log('[Core Bundle] NotificationManager auto-initialized');
        } catch (e) {
            console.warn('[Core Bundle] Failed to auto-init NotificationManager:', e);
        }
    }

    // Dispatch event to signal core utilities are loaded
    document.dispatchEvent(new CustomEvent('coreUtilitiesLoaded'));
    window.dispatchEvent(new CustomEvent('sharedModulesLoaded'));

    console.log('[Core Bundle] All core utilities loaded');

})(typeof window !== 'undefined' ? window : this);
