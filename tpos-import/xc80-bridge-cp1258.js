/**
 * XC80 Print Bridge Server v7.1 - VIETNAMESE PDF SUPPORT
 * H·ªó tr·ª£ CP1258 (Windows-1258) cho ti·∫øng Vi·ªát c√≥ d·∫•u
 * H·ªó tr·ª£ in BITMAP t·ª´ canvas
 * H·ªó tr·ª£ in PDF v·ªõi ti·∫øng Vi·ªát
 *
 * C√°ch ch·∫°y:
 * npm install
 * node xc80-bridge-cp1258.js
 */

const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const net = require("net");
const iconv = require("iconv-lite");
const fs = require("fs").promises;
const fsSync = require("fs");
const path = require("path");
const { promisify } = require("util");
const { exec } = require("child_process");
const execAsync = promisify(exec);

// Th∆∞ vi·ªán x·ª≠ l√Ω h√¨nh ·∫£nh v√† PDF
const sharp = require("sharp");
const pdfParse = require("pdf-parse");

const app = express();
const PORT = 9100;
const TEMP_DIR = path.join(__dirname, "temp");

// T·∫°o th∆∞ m·ª•c temp n·∫øu ch∆∞a c√≥
if (!fsSync.existsSync(TEMP_DIR)) {
  fsSync.mkdirSync(TEMP_DIR, { recursive: true });
}

// Middleware
app.use(cors());
app.use(bodyParser.json({ limit: "50mb" }));
app.use(bodyParser.raw({ type: "application/octet-stream", limit: "50mb" }));

// ESC/POS Constants
const ESC = "\x1B";
const GS = "\x1D";

/**
 * CP1258 Encoding Map (Unicode ‚Üí Windows-1258)
 */
const CP1258_MAP = {
  // Lowercase vowels
  √†: "\xE0", √°: "\xE1", ·∫£: "\xE3", √£: "\xE3", ·∫°: "\xE1",
  ·∫±: "\xE0", ·∫Ø: "\xE1", ·∫≥: "\xE3", ·∫µ: "\xE3", ·∫∑: "\xE1",
  √®: "\xE8", √©: "\xE9", ·∫ª: "\xEB", ·∫Ω: "\xEB", ·∫π: "\xE9",
  ·ªÅ: "\xE8", ·∫ø: "\xE9", ·ªÉ: "\xEB", ·ªÖ: "\xEB", ·ªá: "\xE9",
  √¨: "\xEC", √≠: "\xED", ·ªâ: "\xEF", ƒ©: "\xEF", ·ªã: "\xED",
  √≤: "\xF2", √≥: "\xF3", ·ªè: "\xF5", √µ: "\xF5", ·ªç: "\xF3",
  ·ªì: "\xF2", ·ªë: "\xF3", ·ªï: "\xF5", ·ªó: "\xF5", ·ªô: "\xF3",
  ·ªù: "\xF2", ·ªõ: "\xF3", ·ªü: "\xF5", ·ª°: "\xF5", ·ª£: "\xF3",
  √π: "\xF9", √∫: "\xFA", ·ªß: "\xFC", ≈©: "\xFC", ·ª•: "\xFA",
  ·ª´: "\xF9", ·ª©: "\xFA", ·ª≠: "\xFC", ·ªØ: "\xFC", ·ª±: "\xFA",
  ·ª≥: "\xFD", √Ω: "\xFD", ·ª∑: "\xFF", ·ªπ: "\xFF", ·ªµ: "\xFD",
  ƒë: "\xF0", ƒê: "\xD0",
  // Uppercase vowels
  √Ä: "\xC0", √Å: "\xC1", ·∫¢: "\xC3", √É: "\xC3", ·∫†: "\xC1",
  √à: "\xC8", √â: "\xC9", ·∫∫: "\xCB", ·∫º: "\xCB", ·∫∏: "\xC9",
  √å: "\xCC", √ç: "\xCD", ·ªà: "\xCF", ƒ®: "\xCF", ·ªä: "\xCD",
  √í: "\xD2", √ì: "\xD3", ·ªé: "\xD5", √ï: "\xD5", ·ªå: "\xD3",
  √ô: "\xD9", √ö: "\xDA", ·ª¶: "\xDC", ≈®: "\xDC", ·ª§: "\xDA",
  ·ª≤: "\xDD", √ù: "\xDD", ·ª∂: "\xDF", ·ª∏: "\xDF", ·ª¥: "\xDD",
};

/**
 * Chuy·ªÉn Unicode sang CP1258
 */
function convertToCP1258(text) {
  let result = "";
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    result += CP1258_MAP[char] || char;
  }
  return result;
}

/**
 * Ki·ªÉm tra xem h·ªá th·ªëng c√≥ pdftoppm kh√¥ng
 */
async function checkPdftoppmAvailable() {
  try {
    await execAsync("pdftoppm -v");
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Extract text t·ª´ PDF
 */
async function extractPdfText(pdfBuffer) {
  try {
    const data = await pdfParse(pdfBuffer);
    return data.text;
  } catch (error) {
    console.warn("Cannot extract text from PDF:", error.message);
    return null;
  }
}

/**
 * Convert PDF to ESC/POS bitmap using pdftoppm + sharp
 * C√≥ h·ªó tr·ª£ font ti·∫øng Vi·ªát t·ªët h∆°n
 */
async function pdfToESCPOSBitmap(pdfBuffer, options = {}) {
  const { 
    dpi = 300, 
    threshold = 115, 
    width = 944,
    fontPath = null // ƒê∆∞·ªùng d·∫´n ƒë·∫øn font ti·∫øng Vi·ªát n·∫øu c·∫ßn
  } = options;
  
  const timestamp = Date.now();
  const pdfPath = path.join(TEMP_DIR, `temp_${timestamp}.pdf`);
  const outputPrefix = path.join(TEMP_DIR, `output_${timestamp}`);
  
  try {
    // Step 1: Save PDF buffer to file
    await fs.writeFile(pdfPath, pdfBuffer);
    
    // Step 2: Convert PDF to PNG v·ªõi options h·ªó tr·ª£ font t·ªët h∆°n
    console.log(`üìÑ Converting PDF to PNG (DPI: ${dpi})...`);
    
    // T·∫°o command v·ªõi options t·ªët h∆°n cho ti·∫øng Vi·ªát
    let command = `pdftoppm -r ${dpi} -png`;
    
    // Th√™m antialiasing ƒë·ªÉ text m∆∞·ª£t h∆°n
    command += ` -aa yes -aaVector yes`;
    
    command += ` "${pdfPath}" "${outputPrefix}"`;
    
    console.log(`üîß Command: ${command}`);
    await execAsync(command);
    
    // Step 3: Find generated PNG file
    const pngPath = `${outputPrefix}-1.png`;
    if (!fsSync.existsSync(pngPath)) {
      throw new Error('PDF conversion failed - no output file generated');
    }
    
    // Step 4: Process image v·ªõi sharp
    console.log(`üñºÔ∏è Processing image (width: ${width}px, threshold: ${threshold})...`);
    let img = sharp(pngPath);
    
    // Get metadata
    const metadata = await img.metadata();
    console.log(`üìè Original size: ${metadata.width}x${metadata.height}px`);
    
    // Resize if necessary
    if (metadata.width > width) {
      img = img.resize(width, null, {
        kernel: 'lanczos3',
        fit: 'inside'
      });
    }
    
    // Enhance v√† convert to monochrome v·ªõi settings t·ªët h∆°n cho text
    const processedBuffer = await img
      .greyscale()
      .sharpen({ sigma: 1.2, m1: 0.5, m2: 0.5 })
      .normalise()
      .threshold(threshold)
      .toFormat('png')
      .toBuffer();
    
    // Step 5: Get raw pixel data
    const { data: imageData, info } = await sharp(processedBuffer)
      .raw()
      .toBuffer({ resolveWithObject: true });
    
    console.log(`‚úÖ Final size: ${info.width}x${info.height}px`);
    
    // Step 6: Convert to ESC/POS format
    const escposData = encodeImageToESCPOS(imageData, info.width, info.height);
    
    // Cleanup temp files
    try {
      await fs.unlink(pdfPath);
      await fs.unlink(pngPath);
    } catch (e) {
      console.warn('Warning: Could not delete temp files:', e.message);
    }
    
    return escposData;
    
  } catch (error) {
    // Cleanup on error
    try {
      await fs.unlink(pdfPath).catch(() => {});
      const pngPath = `${outputPrefix}-1.png`;
      await fs.unlink(pngPath).catch(() => {});
    } catch (e) {}
    
    throw new Error(`PDF to ESC/POS conversion failed: ${error.message}`);
  }
}

/**
 * Encode image buffer to ESC/POS bitmap commands (GS v 0 format)
 */
function encodeImageToESCPOS(imageData, width, height) {
  const commands = [];
  
  // Initialize printer
  commands.push(Buffer.from([0x1B, 0x40])); // ESC @ - Initialize
  
  // Center alignment
  commands.push(Buffer.from([0x1B, 0x61, 0x01])); // ESC a 1 - Center
  
  // Calculate bitmap dimensions
  const widthBytes = Math.ceil(width / 8);
  const xL = widthBytes & 0xFF;
  const xH = (widthBytes >> 8) & 0xFF;
  const yL = height & 0xFF;
  const yH = (height >> 8) & 0xFF;
  
  // GS v 0 - Print raster bitmap
  commands.push(Buffer.from([0x1D, 0x76, 0x30, 0x00, xL, xH, yL, yH]));
  
  // Convert pixels to bitmap (1 bit per pixel)
  const bitmapData = [];
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < widthBytes; x++) {
      let byte = 0;
      for (let bit = 0; bit < 8; bit++) {
        const pixelX = x * 8 + bit;
        if (pixelX < width) {
          const pixelIndex = (y * width + pixelX) * (imageData.length / (width * height));
          const pixelValue = imageData[Math.floor(pixelIndex)];
          
          // Black pixel = 1, White pixel = 0
          if (pixelValue < 128) {
            byte |= (1 << (7 - bit));
          }
        }
      }
      bitmapData.push(byte);
    }
  }
  
  commands.push(Buffer.from(bitmapData));
  
  // Left align for next commands
  commands.push(Buffer.from([0x1B, 0x61, 0x00])); // ESC a 0 - Left
  
  // Feed paper
  commands.push(Buffer.from([0x1B, 0x64, 3])); // ESC d 3 - Feed 3 lines
  
  // Cut paper
  commands.push(Buffer.from([0x1D, 0x56, 0x00])); // GS V 0 - Full cut
  
  return Buffer.concat(commands);
}

/**
 * G·ª≠i data ƒë·∫øn m√°y in qua network
 */
async function sendToPrinter(printerIp, printerPort, data) {
  return new Promise((resolve, reject) => {
    const client = net.createConnection(
      {
        host: printerIp,
        port: printerPort,
        timeout: 10000,
      },
      () => {
        client.write(data, (err) => {
          if (err) {
            reject(err);
          } else {
            setTimeout(() => {
              client.end();
              resolve();
            }, 500);
          }
        });
      }
    );

    client.on("timeout", () => {
      client.destroy();
      reject(new Error("Connection timeout"));
    });

    client.on("error", (err) => {
      reject(err);
    });
  });
}

// ============================================
// API ENDPOINTS
// ============================================

/**
 * Bitmap printing endpoint (ESC/POS bitmap format)
 */
app.post('/print/bitmap', async (req, res) => {
  try {
    const { printerIp, printerPort, bitmapData } = req.body;

    if (!printerIp || !printerPort || !bitmapData) {
      return res.status(400).json({ 
        error: 'Missing required fields: printerIp, printerPort, bitmapData' 
      });
    }

    console.log(`üìÑ Printing ESC/POS bitmap to ${printerIp}:${printerPort}`);
    console.log(`Bitmap size: ${bitmapData.length} bytes`);

    const uint8Data = new Uint8Array(bitmapData);
    await sendToPrinter(printerIp, printerPort, uint8Data);

    res.json({ 
      success: true, 
      message: 'ESC/POS bitmap sent to printer',
      bytesTransferred: uint8Data.length
    });

  } catch (error) {
    console.error('‚ùå Bitmap print error:', error.message);
    res.status(500).json({ 
      error: error.message,
      details: 'Failed to print ESC/POS bitmap'
    });
  }
});

/**
 * Health check
 */
app.get("/health", async (req, res) => {
  const hasPdftoppm = await checkPdftoppmAvailable();
  
  res.json({
    status: "OK",
    version: "7.1",
    features: ["text", "bitmap", "pdf", "vietnamese"],
    pdftoppm: hasPdftoppm ? "available" : "not installed",
    timestamp: new Date().toISOString(),
  });
});

/**
 * POST /print/pdf - In file PDF v·ªõi h·ªó tr·ª£ ti·∫øng Vi·ªát
 * Body: {
 *   printerIp: "192.168.1.100",
 *   printerPort: 9100,
 *   pdfBase64: "base64_encoded_pdf_data",
 *   dpi: 300 (optional),
 *   threshold: 115 (optional, 0-255),
 *   width: 944 (optional, pixels for 80mm @ 300 DPI),
 *   mode: "bitmap" | "text" | "auto" (optional, default "auto")
 * }
 */
app.post("/print/pdf", async (req, res) => {
  try {
    const { 
      printerIp, 
      printerPort = 9100, 
      pdfBase64, 
      dpi = 300, 
      threshold = 115, 
      width = 944,
      mode = "auto" // "bitmap", "text", or "auto"
    } = req.body;

    if (!printerIp || !pdfBase64) {
      return res.status(400).json({
        error: "Missing required fields: printerIp, pdfBase64",
      });
    }

    console.log(`\nüìÑ [PDF Print Request]`);
    console.log(`   Printer: ${printerIp}:${printerPort}`);
    console.log(`   Mode: ${mode}`);

    // Decode base64 PDF
    const pdfBuffer = Buffer.from(pdfBase64, "base64");
    console.log(`   PDF size: ${(pdfBuffer.length / 1024).toFixed(2)} KB`);

    // Check if we should try text mode
    let useBitmap = mode === "bitmap";
    let pdfText = null;
    
    if (mode === "auto" || mode === "text") {
      console.log(`   üîç Extracting text from PDF...`);
      pdfText = await extractPdfText(pdfBuffer);
      
      if (pdfText && pdfText.trim().length > 0) {
        console.log(`   ‚úÖ Found ${pdfText.length} characters of text`);
        useBitmap = mode === "bitmap"; // Only use bitmap if explicitly requested
      } else {
        console.log(`   ‚ÑπÔ∏è No extractable text, using bitmap mode`);
        useBitmap = true;
      }
    }

    let escposData;
    
    if (!useBitmap && pdfText) {
      // Text mode - in text tr·ª±c ti·∫øp v·ªõi CP1258
      console.log(`   üìù Using text mode with CP1258 encoding`);
      
      const commands = [];
      commands.push(Buffer.from([0x1B, 0x40])); // Initialize
      commands.push(Buffer.from([0x1B, 0x74, 0x1E])); // Set CP1258
      
      const convertedText = convertToCP1258(pdfText);
      commands.push(Buffer.from(convertedText + "\n\n\n", "binary"));
      commands.push(Buffer.from([0x1D, 0x56, 0x00])); // Cut
      
      escposData = Buffer.concat(commands);
      console.log(`   ‚úÖ Text converted: ${escposData.length} bytes`);
      
    } else {
      // Bitmap mode - convert PDF to image
      console.log(`   üñºÔ∏è Using bitmap mode`);
      console.log(`   Settings: DPI=${dpi}, Threshold=${threshold}, Width=${width}px`);
      
      escposData = await pdfToESCPOSBitmap(pdfBuffer, { dpi, threshold, width });
      console.log(`   ‚úÖ Bitmap created: ${escposData.length} bytes`);
    }

    // Send to printer
    console.log(`   üì§ Sending to printer...`);
    await sendToPrinter(printerIp, printerPort, escposData);
    console.log(`   ‚úÖ Print job sent successfully\n`);

    res.json({
      success: true,
      message: "PDF printed successfully",
      details: {
        mode: useBitmap ? "bitmap" : "text",
        dataSize: escposData.length,
        settings: { dpi, threshold, width }
      },
    });
  } catch (error) {
    console.error(`   ‚ùå Error: ${error.message}\n`);
    res.status(500).json({
      error: error.message,
      stack: process.env.NODE_ENV === "development" ? error.stack : undefined,
    });
  }
});

/**
 * POST /print/text - In text v·ªõi CP1258
 */
app.post("/print/text", async (req, res) => {
  try {
    const { printerIp, printerPort = 9100, text, encoding = "cp1258" } = req.body;

    if (!printerIp || !text) {
      return res.status(400).json({
        error: "Missing required fields: printerIp, text",
      });
    }

    console.log(`\nüìù [Text Print Request]`);
    console.log(`   Printer: ${printerIp}:${printerPort}`);
    console.log(`   Encoding: ${encoding}`);

    // Build ESC/POS commands
    const commands = [];
    commands.push(Buffer.from([0x1B, 0x40])); // Initialize

    // Set code page to CP1258
    if (encoding === "cp1258") {
      commands.push(Buffer.from([0x1B, 0x74, 0x1E])); // ESC t 30
    }

    // Convert text
    const convertedText = encoding === "cp1258" ? convertToCP1258(text) : text;
    commands.push(Buffer.from(convertedText + "\n\n\n", "binary"));
    commands.push(Buffer.from([0x1D, 0x56, 0x00])); // Cut

    const escposData = Buffer.concat(commands);
    await sendToPrinter(printerIp, printerPort, escposData);
    
    console.log(`   ‚úÖ Text printed successfully\n`);

    res.json({
      success: true,
      message: "Text printed successfully",
    });
  } catch (error) {
    console.error(`   ‚ùå Error: ${error.message}\n`);
    res.status(500).json({
      error: error.message,
    });
  }
});

// ============================================
// START SERVER
// ============================================

app.listen(PORT, async () => {
  const hasPdftoppm = await checkPdftoppmAvailable();
  
  console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
  console.log(`‚ïë   XC80 Print Bridge v7.1 - VIETNAMESE PDF SUPPORT        ‚ïë`);
  console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);
  console.log(`üåê Server running on port ${PORT}`);
  console.log(`üì° Endpoints:`);
  console.log(`   GET  /health           - Health check`);
  console.log(`   POST /print/pdf        - Print PDF (Vietnamese support)`);
  console.log(`   POST /print/text       - Print text (CP1258)`);
  console.log(`   POST /print/bitmap     - Print bitmap from canvas\n`);
  console.log(`üîß System Status:`);
  console.log(`   pdftoppm: ${hasPdftoppm ? '‚úÖ Available' : '‚ùå Not installed'}`);
  
  if (!hasPdftoppm) {
    console.log(`\n‚ö†Ô∏è  WARNING: pdftoppm not found!`);
    console.log(`   üì¶ Install poppler-utils:`);
    console.log(`   ‚Ä¢ Ubuntu/Debian: sudo apt-get install poppler-utils`);
    console.log(`   ‚Ä¢ macOS: brew install poppler`);
    console.log(`   ‚Ä¢ Windows: Download from https://blog.alivate.com.au/poppler-windows/\n`);
  }
  
  console.log(`\nüìã Vietnamese Font Tips:`);
  console.log(`   ‚Ä¢ Install Vietnamese fonts for better PDF rendering`);
  console.log(`   ‚Ä¢ Recommended: DejaVu, Liberation, Noto fonts`);
  console.log(`   ‚Ä¢ Ubuntu: sudo apt-get install fonts-dejavu fonts-liberation`);
  console.log(`   ‚Ä¢ PDF text mode uses CP1258 for best Vietnamese support\n`);
  console.log(`üöÄ Ready to accept print jobs!`);
  console.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
});
