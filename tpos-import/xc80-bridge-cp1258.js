/**
 * XP-K200L Print Bridge Server v5.0
 * H·ªó tr·ª£ CP1258 (Windows-1258) cho ti·∫øng Vi·ªát c√≥ d·∫•u
 * 
 * C√°ch ch·∫°y:
 * npm install express body-parser cors iconv-lite
 * node xpk200l-bridge-cp1258.js
 */

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const net = require('net');
const iconv = require('iconv-lite');

const app = express();
const PORT = 9100;

// Middleware
app.use(cors());
app.use(bodyParser.json({ limit: '10mb' }));

// ESC/POS Constants
const ESC = '\x1B';
const GS = '\x1D';

/**
 * CP1258 Encoding Map (Unicode ‚Üí Windows-1258)
 */
const CP1258_MAP = {
  // Lowercase vowels
  '√†': '\xE0', '√°': '\xE1', '·∫£': '\xE3', '√£': '\xE3', '·∫°': '\xE1',
  '·∫±': '\xE0', '·∫Ø': '\xE1', '·∫≥': '\xE3', '·∫µ': '\xE3', '·∫∑': '\xE1',
  '√®': '\xE8', '√©': '\xE9', '·∫ª': '\xEB', '·∫Ω': '\xEB', '·∫π': '\xE9',
  '√¨': '\xEC', '√≠': '\xED', '·ªâ': '\xEF', 'ƒ©': '\xEF', '·ªã': '\xED',
  '√≤': '\xF2', '√≥': '\xF3', '·ªè': '\xF5', '√µ': '\xF5', '·ªç': '\xF3',
  '√π': '\xF9', '√∫': '\xFA', '·ªß': '\xFC', '≈©': '\xFC', '·ª•': '\xFA',
  '·ª≥': '\xFD', '√Ω': '\xFD', '·ª∑': '\xFF', '·ªπ': '\xFF', '·ªµ': '\xFD',
  
  // Special characters
  'ƒë': '\xF0', 'ƒê': '\xD0',
  
  // Uppercase vowels  
  '√Ä': '\xC0', '√Å': '\xC1', '·∫¢': '\xC3', '√É': '\xC3', '·∫†': '\xC1',
  '√à': '\xC8', '√â': '\xC9', '·∫∫': '\xCB', '·∫º': '\xCB', '·∫∏': '\xC9',
  '√å': '\xCC', '√ç': '\xCD', '·ªà': '\xCF', 'ƒ®': '\xCF', '·ªä': '\xCD',
  '√í': '\xD2', '√ì': '\xD3', '·ªé': '\xD5', '√ï': '\xD5', '·ªå': '\xD3',
  '√ô': '\xD9', '√ö': '\xDA', '·ª¶': '\xDC', '≈®': '\xDC', '·ª§': '\xDA',
  '·ª≤': '\xDD', '√ù': '\xDD', '·ª∂': '\xDF', '·ª∏': '\xDF', '·ª¥': '\xDD'
};

/**
 * Chuy·ªÉn Unicode sang CP1258
 */
function convertToCP1258(text) {
  let result = '';
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    result += CP1258_MAP[char] || char;
  }
  return result;
}

/**
 * B·ªè d·∫•u ti·∫øng Vi·ªát
 */
function removeVietnameseTones(str) {
  const tones = {
    '√†': 'a', '√°': 'a', '·∫£': 'a', '√£': 'a', '·∫°': 'a',
    'ƒÉ': 'a', '·∫±': 'a', '·∫Ø': 'a', '·∫≥': 'a', '·∫µ': 'a', '·∫∑': 'a',
    '√¢': 'a', '·∫ß': 'a', '·∫•': 'a', '·∫©': 'a', '·∫´': 'a', '·∫≠': 'a',
    'ƒë': 'd',
    '√®': 'e', '√©': 'e', '·∫ª': 'e', '·∫Ω': 'e', '·∫π': 'e',
    '√™': 'e', '·ªÅ': 'e', '·∫ø': 'e', '·ªÉ': 'e', '·ªÖ': 'e', '·ªá': 'e',
    '√¨': 'i', '√≠': 'i', '·ªâ': 'i', 'ƒ©': 'i', '·ªã': 'i',
    '√≤': 'o', '√≥': 'o', '·ªè': 'o', '√µ': 'o', '·ªç': 'o',
    '√¥': 'o', '·ªì': 'o', '·ªë': 'o', '·ªï': 'o', '·ªó': 'o', '·ªô': 'o',
    '∆°': 'o', '·ªù': 'o', '·ªõ': 'o', '·ªü': 'o', '·ª°': 'o', '·ª£': 'o',
    '√π': 'u', '√∫': 'u', '·ªß': 'u', '≈©': 'u', '·ª•': 'u',
    '∆∞': 'u', '·ª´': 'u', '·ª©': 'u', '·ª≠': 'u', '·ªØ': 'u', '·ª±': 'u',
    '·ª≥': 'y', '√Ω': 'y', '·ª∑': 'y', '·ªπ': 'y', '·ªµ': 'y',
    '√Ä': 'A', '√Å': 'A', '·∫¢': 'A', '√É': 'A', '·∫†': 'A',
    'ƒÇ': 'A', '·∫∞': 'A', '·∫Æ': 'A', '·∫≤': 'A', '·∫¥': 'A', '·∫∂': 'A',
    '√Ç': 'A', '·∫¶': 'A', '·∫§': 'A', '·∫®': 'A', '·∫™': 'A', '·∫¨': 'A',
    'ƒê': 'D',
    '√à': 'E', '√â': 'E', '·∫∫': 'E', '·∫º': 'E', '·∫∏': 'E',
    '√ä': 'E', '·ªÄ': 'E', '·∫æ': 'E', '·ªÇ': 'E', '·ªÑ': 'E', '·ªÜ': 'E',
    '√å': 'I', '√ç': 'I', '·ªà': 'I', 'ƒ®': 'I', '·ªä': 'I',
    '√í': 'O', '√ì': 'O', '·ªé': 'O', '√ï': 'O', '·ªå': 'O',
    '√î': 'O', '·ªí': 'O', '·ªê': 'O', '·ªî': 'O', '·ªñ': 'O', '·ªò': 'O',
    '∆†': 'O', '·ªú': 'O', '·ªö': 'O', '·ªû': 'O', '·ª†': 'O', '·ª¢': 'O',
    '√ô': 'U', '√ö': 'U', '·ª¶': 'U', '≈®': 'U', '·ª§': 'U',
    '∆Ø': 'U', '·ª™': 'U', '·ª®': 'U', '·ª¨': 'U', '·ªÆ': 'U', '·ª∞': 'U',
    '·ª≤': 'Y', '√ù': 'Y', '·ª∂': 'Y', '·ª∏': 'Y', '·ª¥': 'Y'
  };
  
  return str.split('').map(char => tones[char] || char).join('');
}

/**
 * T·∫°o ESC/POS commands
 */
function buildESCPOS(content, options = {}) {
  const {
    mode = 'cp1258', // 'cp1258', 'no-accents', 'utf8'
    align = 'left',
    feeds = 3
  } = options;
  
  const commands = [];
  
  // Initialize
  commands.push(Buffer.from([0x1B, 0x40])); // ESC @
  
  // Set Code Page based on mode
  if (mode === 'cp1258') {
    commands.push(Buffer.from([0x1B, 0x74, 0x1E])); // ESC t 30 (CP1258)
    content = convertToCP1258(content);
  } else if (mode === 'no-accents') {
    commands.push(Buffer.from([0x1B, 0x74, 0x00])); // ESC t 0 (PC437)
    content = removeVietnameseTones(content);
  } else if (mode === 'utf8') {
    commands.push(Buffer.from([0x1B, 0x74, 0x10])); // ESC t 16 (UTF-8)
  }
  
  // Alignment
  const alignCode = { left: 0x00, center: 0x01, right: 0x02 }[align] || 0x00;
  commands.push(Buffer.from([0x1B, 0x61, alignCode]));
  
  // Content
  commands.push(Buffer.from(content, 'binary'));
  
  // Paper feed
  if (feeds > 0) {
    commands.push(Buffer.from([0x1B, 0x64, feeds]));
  }
  
  // Cut paper
  commands.push(Buffer.from([0x1D, 0x56, 0x00]));
  
  return Buffer.concat(commands);
}

/**
 * G·ª≠i data ƒë·∫øn m√°y in
 */
async function sendToPrinter(ip, port, data) {
  return new Promise((resolve, reject) => {
    const client = net.createConnection({ host: ip, port, timeout: 5000 }, () => {
      client.write(data, (err) => {
        if (err) reject(err);
        else {
          setTimeout(() => {
            client.end();
            resolve();
          }, 500);
        }
      });
    });
    
    client.on('timeout', () => {
      client.destroy();
      reject(new Error('Connection timeout'));
    });
    
    client.on('error', reject);
  });
}

// ==================== API ENDPOINTS ====================

/**
 * Health check
 */
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    version: '5.0',
    printer: 'XP-K200L',
    encoding: 'CP1258',
    timestamp: new Date().toISOString()
  });
});

/**
 * Test connection
 */
app.post('/printers/test', async (req, res) => {
  const { ipAddress, port = 9100 } = req.body;
  
  if (!ipAddress) {
    return res.status(400).json({ success: false, error: 'Missing IP address' });
  }
  
  try {
    const testData = buildESCPOS('Test connection OK\n', { feeds: 2 });
    await sendToPrinter(ipAddress, port, testData);
    
    res.json({
      success: true,
      message: 'Printer connected successfully',
      printer: `${ipAddress}:${port}`
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Print content
 */
app.post('/print', async (req, res) => {
  const { ipAddress, port = 9100, content, options = {} } = req.body;
  
  if (!ipAddress || !content) {
    return res.status(400).json({
      success: false,
      error: 'Missing required fields: ipAddress, content'
    });
  }
  
  try {
    const escposData = buildESCPOS(content, options);
    await sendToPrinter(ipAddress, port, escposData);
    
    res.json({
      success: true,
      message: 'Print job sent successfully',
      jobID: Date.now().toString(36),
      encoding: options.mode || 'cp1258',
      printer: `${ipAddress}:${port}`,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================
// üÜï ROUTE M·ªöI: IN BITMAP (CHO TEXT TO IMAGE)
// ============================================
app.post('/print/bitmap', async (req, res) => {
  const { ipAddress, port, bitmapBase64, feeds = 3 } = req.body;

  if (!ipAddress || !port || !bitmapBase64) {
    return res.status(400).json({ 
      success: false, 
      error: 'Missing ipAddress, port, or bitmapBase64' 
    });
  }

  console.log(`\nüñºÔ∏è Bitmap print request:`);
  console.log(`   - Target: ${ipAddress}:${port}`);
  console.log(`   - Bitmap size: ${bitmapBase64.length} bytes (base64)`);

  try {
    const client = new net.Socket();
    client.setTimeout(5000);

    await new Promise((resolve, reject) => {
      client.connect(port, ipAddress, () => {
        console.log(`‚úÖ Connected to ${ipAddress}:${port}`);

        const commands = [];
        
        // ESC @ - Initialize printer
        commands.push(Buffer.from([0x1B, 0x40]));
        
        // Decode base64 ‚Üí Buffer
        const bitmapBuffer = Buffer.from(bitmapBase64, 'base64');
        console.log(`üì¶ Decoded bitmap: ${bitmapBuffer.length} bytes`);
        
        // Add bitmap data
        commands.push(bitmapBuffer);
        
        // Add line feeds
        commands.push(Buffer.from('\n'.repeat(feeds)));
        
        const finalBuffer = Buffer.concat(commands);
        console.log(`üì§ Sending ${finalBuffer.length} bytes to printer`);
        
        client.write(finalBuffer, (err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      client.on('error', reject);
      client.on('timeout', () => {
        client.destroy();
        reject(new Error('Connection timeout'));
      });
    });

    client.end();
    
    res.json({ 
      success: true,
      message: 'Bitmap sent to printer successfully' 
    });

  } catch (error) {
    console.error('‚ùå Bitmap print error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

/**
 * Print bill (legacy support)
 */
app.post('/print-bill', async (req, res) => {
  const { billData, printer } = req.body;
  
  if (!billData || !printer) {
    return res.status(400).json({
      success: false,
      error: 'Missing billData or printer config'
    });
  }
  
  try {
    // Format bill content
    let content = '\n\n';
    content += `#${billData.sessionIndex} - ${billData.phone || 'Chua co SDT'}\n`;
    content += `${billData.customerName}\n`;
    content += `${billData.productCode} - ${billData.productName}\n`;
    if (billData.comment) {
      content += `"${billData.comment}"\n`;
    }
    content += `\n${new Date(billData.createdTime).toLocaleString('vi-VN')}\n`;
    
    const escposData = buildESCPOS(content, { mode: 'cp1258', align: 'center', feeds: 3 });
    await sendToPrinter(printer.ipAddress, printer.port, escposData);
    
    res.json({
      success: true,
      message: `ƒê√£ in qua ${printer.name}`
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Start server
app.listen(PORT, () => {
  console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë                                                               ‚ïë');
  console.log('‚ïë        XP-K200L Print Bridge v5.0 - CP1258                   ‚ïë');
  console.log('‚ïë        Server running on port ' + PORT + '                          ‚ïë');
  console.log('‚ïë                                                               ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  console.log('‚úÖ Server is ready to accept connections!');
  console.log(`üìç Health check: http://localhost:${PORT}/health`);
  console.log(`\nüìñ Endpoints:`);
  console.log(`   POST /print              - In n·ªôi dung text`);
  console.log(`   POST /printers/test      - Test k·∫øt n·ªëi`);
  console.log(`   POST /print-bill         - In h√≥a ƒë∆°n\n`);
  console.log(`üîß Encoding modes:`);
  console.log(`   ‚Ä¢ cp1258 (m·∫∑c ƒë·ªãnh)     - Ti·∫øng Vi·ªát c√≥ d·∫•u`);
  console.log(`   ‚Ä¢ no-accents            - B·ªè d·∫•u (d·ª± ph√≤ng)`);
  console.log(`   ‚Ä¢ utf8                  - UTF-8 (th·ª≠ nghi·ªám)\n`);
});
