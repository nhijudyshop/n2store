<!--
  üìñ GHI CH√ö CHO L·∫¨P TR√åNH VI√äN:
  Khi code ph·∫£i ƒë·ªçc th∆∞ m·ª•c https://github.com/nhijudyshop/n2store/tree/main/docs tr∆∞·ªõc!
  ƒê·ªçc c√°c file SHARED_*.md ƒë·ªÉ hi·ªÉu c√°ch s·ª≠ d·ª•ng shared modules.
-->
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qu·∫£n l√Ω Order - N2Shop</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="firebase-helpers.js"></script>

    <!-- Shared utilities -->
    <script src="../shared/js/firebase-config.js"></script>
    <script src="../shared/js/shared-auth-manager.js"></script>
    <script>if(typeof AuthManager!=="undefined")window.authManager=new AuthManager({redirectUrl:"../index.html"});</script>
    <script src="../shared/js/notification-system.js"></script>
    <script>if(typeof NotificationManager!=="undefined"&&!window.notificationManager)window.notificationManager=new NotificationManager();</script>
    <script defer src="../shared/js/navigation-modern.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        /* Settings Button */
        .btn-settings {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
        }

        .btn-settings:hover {
            background: white;
            color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .settings-icon {
            font-size: 18px;
            animation: rotate 2s linear infinite;
        }

        .btn-settings:hover .settings-icon {
            animation-play-state: paused;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Settings Sidebar */
        .settings-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 25px rgba(0,0,0,0.2);
            z-index: 10000;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .settings-sidebar-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .settings-sidebar-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .settings-sidebar-header h2 {
            margin: 0;
            font-size: 20px;
        }

        .btn-close-sidebar {
            background: transparent;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .btn-close-sidebar:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .settings-sidebar-content {
            padding: 20px;
        }

        .search-section {
            padding: 30px;
            background: #f8f9fa;
        }

        .search-wrapper {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 16px;
            border: 2px solid #667eea;
            border-radius: 10px;
            outline: none;
            transition: all 0.3s;
            position: relative;
            z-index: 1;
        }

        .search-input:focus {
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .suggestions {
            position: absolute;
            top: calc(100% + 2px);
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-top: 5px;
        }

        .suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid #eee;
        }

        .suggestion-item:hover {
            background: #f0f0ff;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: bold;
        }

        .product-display {
            padding: 30px;
            display: none;
        }

        .product-display.show {
            display: block;
        }

        .product-card {
            display: flex;
            gap: 30px;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .product-image {
            flex-shrink: 0;
        }

        .product-image img {
            width: 300px;
            height: 300px;
            object-fit: cover;
            border-radius: 10px;
            border: 3px solid #667eea;
        }

        .product-image .no-image {
            width: 300px;
            height: 300px;
            background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 18px;
            border: 3px solid #ccc;
        }

        .product-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .product-name {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #667eea;
        }

        .product-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: auto;
        }

        .stat-box {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .stat-box.editable {
            background: linear-gradient(135deg, #fff3cd 0%, #ffe69c 100%);
            border-color: #ffc107;
        }

        .stat-box.remaining {
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
            border-color: #17a2b8;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #333;
        }

        .stat-input {
            width: 100%;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            border: none;
            background: transparent;
            color: #333;
            outline: none;
            padding: 5px;
        }

        .stat-input:focus {
            background: rgba(255,255,255,0.5);
            border-radius: 5px;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px;
            border: 2px solid #f5c6cb;
        }

        /* ===== RESPONSIVE CSS ===== */

        @media (max-width: 479px) {
            body {
                padding: 10px;
            }

            .header {
                padding: 20px 15px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .header p {
                font-size: 0.85em;
            }

            .btn-settings {
                top: 10px;
                right: 10px;
                padding: 6px 12px;
                font-size: 11px;
            }

            .settings-text {
                display: none;
            }

            .settings-icon {
                font-size: 18px;
            }

            .search-section {
                padding: 20px 15px;
            }

            .search-input {
                padding: 12px 15px;
                font-size: 14px;
            }

            .product-display {
                padding: 15px;
            }

            .product-card {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }

            .product-image img,
            .product-image .no-image {
                width: 100%;
                height: auto;
                aspect-ratio: 1;
            }

            .product-name {
                font-size: 18px;
                margin-bottom: 15px;
                padding-bottom: 15px;
            }

            .product-stats {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .stat-box {
                padding: 15px;
            }

            .stat-label {
                font-size: 12px;
            }

            .stat-value,
            .stat-input {
                font-size: 24px;
            }

            .settings-sidebar {
                width: 100%;
                right: -100%;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .preview-item {
                grid-template-columns: 60px 1fr;
                gap: 10px;
                padding: 12px;
            }

            .preview-image {
                width: 60px;
                height: 60px;
            }

            .preview-name {
                font-size: 13px;
            }

            .preview-stats {
                flex-direction: column;
                gap: 8px;
                font-size: 12px;
            }

            .qty-control {
                padding: 3px 6px;
            }

            .qty-btn {
                width: 20px;
                height: 20px;
                font-size: 14px;
            }

            .btn-remove {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        @media (min-width: 480px) and (max-width: 767px) {
            body {
                padding: 15px;
            }

            .header {
                padding: 25px 20px;
            }

            .header h1 {
                font-size: 1.75em;
            }

            .btn-settings {
                top: 12px;
                right: 12px;
                padding: 8px 15px;
                font-size: 12px;
            }

            .settings-text {
                display: none;
            }

            .settings-icon {
                font-size: 20px;
            }

            .search-section {
                padding: 25px 20px;
            }

            .search-input {
                padding: 14px 18px;
                font-size: 15px;
            }

            .product-display {
                padding: 20px;
            }

            .product-card {
                flex-direction: column;
                gap: 20px;
                padding: 20px;
            }

            .product-image img,
            .product-image .no-image {
                width: 100%;
                height: auto;
                aspect-ratio: 1;
            }

            .product-name {
                font-size: 20px;
            }

            .product-stats {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .stat-value,
            .stat-input {
                font-size: 28px;
            }

            .settings-sidebar {
                width: 100%;
                right: -100%;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                max-width: 100%;
            }

            .header h1 {
                font-size: 1.85em;
            }

            .btn-settings {
                padding: 10px 18px;
                font-size: 13px;
            }

            .search-section {
                padding: 28px;
            }

            .product-display {
                padding: 25px;
            }

            .product-card {
                gap: 25px;
            }

            .product-image img,
            .product-image .no-image {
                width: 250px;
                height: 250px;
            }

            .product-name {
                font-size: 22px;
            }

            .product-stats {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
            }

            .stat-value,
            .stat-input {
                font-size: 28px;
            }

            .settings-sidebar {
                width: 380px;
            }

            .settings-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .preview-item {
                grid-template-columns: 70px 1fr auto;
            }

            .preview-image {
                width: 70px;
                height: 70px;
            }
        }

        @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
            .product-card {
                flex-direction: row;
            }

            .product-image img,
            .product-image .no-image {
                width: 220px;
                height: 220px;
            }

            .product-stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1025px) and (max-width: 1366px) {
            .container {
                max-width: 1100px;
            }

            .product-image img,
            .product-image .no-image {
                width: 280px;
                height: 280px;
            }
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .settings-section {
            padding: 30px;
            background: #fff8e1;
            border-top: 3px solid #ffc107;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-header h2 {
            color: #333;
            font-size: 1.5em;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .setting-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .setting-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .setting-input {
            width: 100%;
            padding: 10px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #ffc107;
            border-radius: 8px;
            outline: none;
            transition: all 0.3s;
        }

        .setting-input:focus {
            border-color: #ff9800;
            box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.2);
        }

        .setting-description {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }

        .btn-apply-settings {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin-top: 15px;
            width: 100%;
        }

        .btn-apply-settings:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
        }

        /* Toggle Switch Styles */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }

        .toggle-label {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }

        .toggle-label-text {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .toggle-description {
            font-size: 12px;
            color: #999;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }

        .product-list-section {
            padding: 30px;
            background: #f8f9fa;
            border-top: 3px solid #667eea;
        }

        .list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .list-header h2 {
            color: #333;
            font-size: 1.5em;
            flex: 1;
            min-width: 250px;
        }

        .list-search-box {
            position: relative;
            flex: 0 1 300px;
        }

        .list-search-input {
            width: 100%;
            padding: 10px 40px 10px 15px;
            font-size: 14px;
            border: 2px solid #667eea;
            border-radius: 20px;
            outline: none;
            transition: all 0.3s;
        }

        .list-search-input:focus {
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .list-search-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #dc3545;
            color: white;
            border: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .list-search-clear:hover {
            background: #c82333;
            transform: translateY(-50%) scale(1.1);
        }

        .list-search-clear.show {
            display: flex;
        }

        .list-header-actions {
            display: flex;
            gap: 10px;
        }

        .btn-expand {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-expand:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .product-list-preview {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-height: 400px;
            overflow-y: auto;
        }

        .preview-item {
            display: grid;
            grid-template-columns: 80px 1fr auto;
            gap: 15px;
            padding: 15px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .preview-item:last-child {
            border-bottom: none;
        }

        .preview-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 2px solid #667eea;
        }

        .preview-image.no-image {
            background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .preview-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .preview-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .preview-stats {
            display: flex;
            gap: 15px;
            font-size: 13px;
            color: #666;
            align-items: center;
        }

        .qty-control {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #fff3e0;
            padding: 4px 8px;
            border-radius: 6px;
            border: 2px solid #ff9800;
        }

        .qty-btn {
            background: #ff9800;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        }

        .qty-btn:hover {
            background: #f57c00;
            transform: scale(1.1);
        }

        .qty-btn:active {
            transform: scale(0.95);
        }

        .qty-value {
            font-weight: 600;
            color: #e65100;
            min-width: 30px;
            text-align: center;
        }

        /* Editable Quantity Input Styles */
        .editable-qty-input {
            width: 50px;
            border: 1px solid transparent;
            text-align: center;
            background: transparent;
            outline: none;
            transition: all 0.3s;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            padding: 2px;
            border-radius: 4px;
        }

        .editable-qty-input:hover {
            border-color: rgba(102, 126, 234, 0.3);
            background: rgba(255, 255, 255, 0.5);
        }

        .editable-qty-input:focus {
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
            cursor: text;
        }

        /* Remove spinner for number inputs */
        .editable-qty-input::-webkit-outer-spin-button,
        .editable-qty-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .editable-qty-input[type=number] {
            -moz-appearance: textfield;
        }

        .preview-actions {
            display: flex;
            gap: 10px;
        }

        .btn-remove {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-remove:hover {
            background: #c82333;
        }

        .btn-change-image {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-change-image:hover {
            background: #138496;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(23, 162, 184, 0.4);
        }

        /* Image Change Modal */
        .image-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .image-modal-overlay.show {
            display: flex;
        }

        .image-modal {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .image-modal-header {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .image-modal-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .image-modal-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .image-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .image-modal-body {
            padding: 20px;
            max-height: calc(90vh - 140px);
            overflow-y: auto;
        }

        .image-modal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .image-modal-tab {
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            position: relative;
            top: 2px;
        }

        .image-modal-tab:hover {
            color: #17a2b8;
        }

        .image-modal-tab.active {
            color: #17a2b8;
            border-bottom-color: #17a2b8;
        }

        .image-modal-content {
            display: none;
        }

        .image-modal-content.active {
            display: block;
        }

        .paste-area {
            border: 3px dashed #17a2b8;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9fa;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .paste-area:hover {
            background: #e9ecef;
            border-color: #138496;
        }

        .paste-area.has-image {
            border-color: #28a745;
            background: #d4edda;
        }

        .paste-icon {
            font-size: 48px;
            color: #17a2b8;
        }

        .paste-text {
            font-size: 16px;
            color: #666;
            font-weight: 600;
        }

        .paste-hint {
            font-size: 13px;
            color: #999;
        }

        .paste-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
        }

        .paste-preview.show {
            display: block;
        }

        .file-upload-area {
            border: 3px dashed #17a2b8;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9fa;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload-area:hover {
            background: #e9ecef;
            border-color: #138496;
        }

        .file-upload-area.dragover {
            background: #d1ecf1;
            border-color: #17a2b8;
            transform: scale(1.02);
        }

        .file-upload-input {
            display: none;
        }

        .link-input-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .link-input {
            width: 100%;
            padding: 12px 15px;
            font-size: 15px;
            border: 2px solid #17a2b8;
            border-radius: 8px;
            outline: none;
            transition: all 0.3s;
        }

        .link-input:focus {
            border-color: #138496;
            box-shadow: 0 0 0 3px rgba(23, 162, 184, 0.1);
        }

        .link-preview-container {
            display: none;
            margin-top: 15px;
        }

        .link-preview-container.show {
            display: block;
        }

        .link-preview-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            border: 2px solid #17a2b8;
        }

        .image-modal-footer {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-modal {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-modal-cancel {
            background: #6c757d;
            color: white;
        }

        .btn-modal-cancel:hover {
            background: #5a6268;
        }

        .btn-modal-save {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
        }

        .btn-modal-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(23, 162, 184, 0.4);
        }

        .btn-modal-save:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* Camera styles */
        .camera-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            min-height: 300px;
        }

        .camera-video {
            width: 100%;
            height: auto;
            display: block;
            max-height: 400px;
            object-fit: contain;
        }

        .camera-canvas {
            display: none;
        }

        .camera-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn-camera {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-camera-start {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-camera-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .btn-camera-capture {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
        }

        .btn-camera-capture:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.4);
        }

        .btn-camera-switch {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
        }

        .btn-camera-switch:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .btn-camera-stop {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .btn-camera-stop:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }

        .camera-message {
            padding: 40px;
            text-align: center;
            color: #666;
            font-size: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .camera-message-icon {
            font-size: 48px;
            color: #17a2b8;
        }

        /* ============================================================================
         * CART HISTORY / SNAPSHOT STYLES
         * ============================================================================ */

        /* Cart History List */
        .cart-history-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 5px;
            margin-top: 15px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            opacity: 1;
        }

        .cart-history-list.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
            overflow: hidden;
        }

        .cart-history-list::-webkit-scrollbar {
            width: 6px;
        }

        .cart-history-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .cart-history-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .cart-history-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Toggle Icon */
        .toggle-icon {
            display: inline-block;
            transition: transform 0.3s ease;
            font-size: 12px;
            color: #667eea;
        }

        .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .cart-history-header:hover h3 {
            color: #5568d3;
        }

        .cart-history-header:hover .toggle-icon {
            color: #5568d3;
        }

        .no-history {
            text-align: center;
            padding: 20px;
            color: #999;
            font-style: italic;
            font-size: 14px;
        }

        /* Snapshot Card */
        .snapshot-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
        }

        .snapshot-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .snapshot-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            gap: 10px;
        }

        .snapshot-name {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            flex: 1;
            line-height: 1.3;
        }

        .snapshot-date {
            font-size: 11px;
            color: #666;
            white-space: nowrap;
        }

        .snapshot-stats {
            display: flex;
            gap: 12px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #555;
        }

        .snapshot-stats span {
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .snapshot-desc {
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-bottom: 8px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 4px;
            line-height: 1.4;
        }

        .snapshot-actions {
            display: flex;
            gap: 6px;
        }

        .snapshot-actions button {
            flex: 1;
            padding: 6px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .btn-view {
            background: #007bff;
            color: white;
        }

        .btn-view:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        .btn-restore {
            background: #28a745;
            color: white;
        }

        .btn-restore:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        .btn-delete:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 20000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
        }

        .modal-container {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .modal-small {
            width: 90%;
            max-width: 500px;
        }

        .modal-fullscreen {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
        }

        .modal-header-custom {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header-custom h2,
        .modal-header-custom h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .btn-close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            color: #666;
            transition: color 0.2s;
        }

        .btn-close-modal:hover {
            color: #dc3545;
        }

        .modal-body-custom {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer-custom {
            padding: 15px 20px;
            border-top: 1px solid #ddd;
            background: #f8f9fa;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-footer-custom button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary-custom {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: white;
        }

        .btn-primary-custom:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .btn-secondary-custom {
            background: #6c757d;
            color: white;
        }

        .btn-secondary-custom:hover {
            background: #5a6268;
        }

        /* Restore Confirmation Modal */
        .warning-message {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            color: #856404;
            font-size: 14px;
            text-align: center;
        }

        .warning-message strong {
            color: #d39e00;
            font-size: 16px;
        }

        .auto-save-option {
            margin-bottom: 15px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .checkbox-label:hover {
            background: #e9ecef;
        }

        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-label span {
            font-size: 14px;
            font-weight: 500;
            color: #28a745;
        }

        .auto-save-name-input {
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .auto-save-name-input label {
            display: block;
            font-size: 13px;
            color: #666;
            margin-bottom: 6px;
        }

        .auto-save-name-input input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .auto-save-name-input input[type="text"]:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.1);
        }

        .info-message {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 10px;
            color: #0c5460;
            font-size: 12px;
            text-align: center;
        }

        /* Snapshot View Modal */
        .snapshot-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .snapshot-info-grid > div {
            padding: 8px;
            background: white;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
        }

        .snapshot-products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            padding: 10px;
        }

        .snapshot-product-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            position: relative;
            transition: all 0.2s;
        }

        .snapshot-product-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .snapshot-product-card img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .product-name {
            font-size: 14px;
            font-weight: bold;
            margin: 8px 0;
            color: #333;
            line-height: 1.3;
        }

        .product-stats {
            display: flex;
            justify-content: space-around;
            font-size: 12px;
            color: #555;
            background: #f8f9fa;
            padding: 6px;
            border-radius: 4px;
        }

        .product-stats span {
            font-weight: 500;
        }

        .hidden-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .modal-small {
                width: 95%;
            }

            .modal-fullscreen {
                width: 95%;
                height: 95vh;
            }

            .snapshot-products-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 10px;
            }

            .snapshot-info-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Image Change Modal -->
    <div class="image-modal-overlay" id="imageModalOverlay" onclick="if(event.target === this) closeImageModal()">
        <div class="image-modal">
            <div class="image-modal-header">
                <h3>üñºÔ∏è Thay ƒë·ªïi h√¨nh ·∫£nh s·∫£n ph·∫©m</h3>
                <button class="image-modal-close" onclick="closeImageModal()">√ó</button>
            </div>
            <div class="image-modal-body">
                <div class="image-modal-tabs">
                    <button class="image-modal-tab active" onclick="switchImageTab('paste')">üìã Paste ·∫£nh</button>
                    <button class="image-modal-tab" onclick="switchImageTab('upload')">üìÅ Ch·ªçn file</button>
                    <button class="image-modal-tab" onclick="switchImageTab('camera')">üì∑ Ch·ª•p h√¨nh</button>
                    <button class="image-modal-tab" onclick="switchImageTab('link')">üîó Nh·∫≠p link</button>
                </div>

                <!-- Paste Tab -->
                <div class="image-modal-content active" id="pasteTab">
                    <div class="paste-area" id="pasteArea" onclick="focusPasteArea()">
                        <div class="paste-icon">üìã</div>
                        <div class="paste-text">Click v√†o ƒë√¢y v√† paste ·∫£nh (Ctrl+V / Cmd+V)</div>
                        <div class="paste-hint">Ho·∫∑c nh·∫•n Ctrl+V / Cmd+V ·ªü b·∫•t k·ª≥ ƒë√¢u trong modal n√†y</div>
                    </div>
                    <img class="paste-preview" id="pastePreview" alt="Preview">
                </div>

                <!-- Upload Tab -->
                <div class="image-modal-content" id="uploadTab">
                    <div class="file-upload-area" id="fileUploadArea" onclick="document.getElementById('fileUploadInput').click()">
                        <div class="paste-icon">üìÅ</div>
                        <div class="paste-text">Click ƒë·ªÉ ch·ªçn file ho·∫∑c k√©o th·∫£ v√†o ƒë√¢y</div>
                        <div class="paste-hint">H·ªó tr·ª£: JPG, PNG, GIF, WEBP</div>
                    </div>
                    <input type="file" id="fileUploadInput" class="file-upload-input" accept="image/*" onchange="handleFileSelect(event)">
                    <img class="paste-preview" id="uploadPreview" alt="Preview">
                </div>

                <!-- Camera Tab -->
                <div class="image-modal-content" id="cameraTab">
                    <div class="camera-container" id="cameraContainer">
                        <div class="camera-message" id="cameraMessage">
                            <div class="camera-message-icon">üì∑</div>
                            <div>Click "B·∫≠t camera" ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ª•p h√¨nh</div>
                        </div>
                        <video id="cameraVideo" class="camera-video" autoplay playsinline style="display: none;"></video>
                        <canvas id="cameraCanvas" class="camera-canvas"></canvas>
                    </div>
                    <img class="paste-preview" id="cameraPreview" alt="Preview">
                    <div class="camera-controls">
                        <button class="btn-camera btn-camera-start" id="btnStartCamera" onclick="startCamera()">
                            üì∑ B·∫≠t camera
                        </button>
                        <button class="btn-camera btn-camera-switch" id="btnSwitchCamera" onclick="switchCamera()" style="display: none;">
                            üîÑ ƒê·ªïi camera
                        </button>
                        <button class="btn-camera btn-camera-capture" id="btnCapturePhoto" onclick="capturePhoto()" style="display: none;">
                            üì∏ Ch·ª•p ·∫£nh
                        </button>
                        <button class="btn-camera btn-camera-stop" id="btnStopCamera" onclick="stopCamera()" style="display: none;">
                            ‚èπÔ∏è T·∫Øt camera
                        </button>
                    </div>
                </div>

                <!-- Link Tab -->
                <div class="image-modal-content" id="linkTab">
                    <div class="link-input-area">
                        <input
                            type="text"
                            class="link-input"
                            id="linkInput"
                            placeholder="Nh·∫≠p URL h√¨nh ·∫£nh (https://...)"
                            oninput="handleLinkInput(event)"
                        >
                        <div class="paste-hint">ƒê·ªÉ tr·ªëng ƒë·ªÉ x√≥a h√¨nh ·∫£nh hi·ªán t·∫°i</div>
                    </div>
                    <div class="link-preview-container" id="linkPreviewContainer">
                        <img class="link-preview-image" id="linkPreviewImage" alt="Preview">
                    </div>
                </div>
            </div>
            <div class="image-modal-footer">
                <button class="btn-modal btn-modal-cancel" onclick="closeImageModal()">H·ªßy</button>
                <button class="btn-modal btn-modal-save" id="btnSaveImage" onclick="saveImageChange()">L∆∞u thay ƒë·ªïi</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üì¶ Qu·∫£n l√Ω Order N2Shop</h1>
            <p>T√¨m ki·∫øm v√† qu·∫£n l√Ω t·ªìn kho s·∫£n ph·∫©m</p>
            <button class="btn-settings" id="btnSettings" onclick="toggleSettingsSidebar()">
                <span class="settings-icon">‚öôÔ∏è</span>
                <span class="settings-text">C√†i ƒë·∫∑t</span>
            </button>
        </div>

        <div class="search-section">
            <div class="search-wrapper">
                <input
                    type="text"
                    class="search-input"
                    id="productSearch"
                    placeholder="Nh·∫≠p m√£ ho·∫∑c t√™n s·∫£n ph·∫©m (h·ªó tr·ª£ barcode scanner)..."
                    autocomplete="off"
                >
                <div class="suggestions" id="suggestions"></div>
            </div>
            <div id="loadingIndicator" class="loading" style="display: none;">
                <div class="spinner"></div>
                <p style="margin-top: 10px;">ƒêang t·∫£i d·ªØ li·ªáu...</p>
            </div>
        </div>

        <div class="product-display" id="productDisplay"></div>

        <div class="product-list-section" id="productListSection" style="display: none;">
            <div class="list-header">
                <h2>üìã Danh s√°ch s·∫£n ph·∫©m ƒë√£ th√™m (<span id="productCount">0</span>)</h2>
                <div class="list-search-box">
                    <input type="text" class="list-search-input" id="listSearchInput" placeholder="üîç T√¨m ki·∫øm trong danh s√°ch..." autocomplete="off">
                    <button class="list-search-clear" id="listSearchClear" onclick="clearListSearch()">√ó</button>
                </div>
                <div class="list-header-actions">
                    <a href="order-list.html#sync" class="btn-expand" id="btnExpandList" target="_blank" style="text-decoration: none; display: inline-block;">üîç Ph√≥ng to</a>
                </div>
            </div>
            <div class="product-list-preview" id="productListPreview"></div>
        </div>

        <!-- Hidden Products Section -->
        <div class="product-list-section" id="hiddenProductsSection" style="display: none; background: #fff3e0; border-top: 3px solid #ff9800;">
            <div class="list-header">
                <h2>S·∫£n ph·∫©m ƒë√£ ·∫©n (<span id="hiddenProductCount">0</span>)</h2>
                <div class="list-search-box">
                    <input type="text" class="list-search-input" id="hiddenListSearchInput" placeholder="üîç T√¨m ki·∫øm trong danh s√°ch ƒë√£ ·∫©n..." autocomplete="off">
                    <button class="list-search-clear" id="hiddenListSearchClear" onclick="clearHiddenListSearch()">√ó</button>
                </div>
                <div class="list-header-actions">
                    <button class="btn-expand" onclick="openHiddenProductsSettings()" style="background: #ff9800; border-color: #ff9800;" title="C√†i ƒë·∫∑t b·ªë c·ª•c Danh S√°ch ·∫®n">‚öôÔ∏è</button>
                    <a href="hidden-products.html" class="btn-expand" style="text-decoration: none;">üëÅÔ∏è Xem</a>
                </div>
            </div>
            <div class="product-list-preview" id="hiddenProductListPreview"></div>
        </div>
    </div>

    <script>
        let productsData = [];
        let isLoadingExcel = false;
        let bearerToken = null;
        let tokenExpiry = null;
        let orderProducts = {}; // Object-based structure: { product_123: {...}, product_456: {...} }
        let filteredProductsInList = []; // For search in product list
        let listSearchKeyword = ''; // Current search keyword for product list
        let filteredHiddenProducts = []; // For search in hidden product list
        let hiddenListSearchKeyword = ''; // Current search keyword for hidden product list
        let isSyncMode = false;
        let autoAddVariants = true; // M·∫∑c ƒë·ªãnh B·∫¨T ch·∫ø ƒë·ªô t·ª± ƒë·ªông th√™m variants

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA-legWlCgjMDEy70rsaTTwLK39F4ZCKhM",
            authDomain: "n2shop-69e37.firebaseapp.com",
            databaseURL: "https://n2shop-69e37-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "n2shop-69e37",
            storageBucket: "n2shop-69e37-ne0q1",
            messagingSenderId: "598906493303",
            appId: "1:598906493303:web:46d6236a1fdc2eff33e972",
            measurementId: "G-TEJH3S2T1D"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        let isSyncingFromFirebase = false;

        function checkSyncMode() {
            const hash = window.location.hash.substring(1);
            isSyncMode = hash.includes('sync') || hash.includes('admin');
            updateExpandListLink();
        }

        function updateExpandListLink() {
            const btnExpandList = document.getElementById('btnExpandList');
            if (btnExpandList) {
                if (isSyncMode) {
                    btnExpandList.href = 'order-list.html#sync';
                } else {
                    btnExpandList.href = 'order-list.html';
                }
            }
        }

        function sortVariants(variants) {
            // Define size order
            const sizeOrder = ['S', 'M', 'L', 'XL', 'XXL', 'XXXL'];

            return [...variants].sort((a, b) => {
                const nameA = a.NameGet || '';
                const nameB = b.NameGet || '';

                // Extract number in parentheses (1), (2), (3), etc.
                const numberMatchA = nameA.match(/\((\d+)\)/);
                const numberMatchB = nameB.match(/\((\d+)\)/);

                // If both have numbers, sort by number
                if (numberMatchA && numberMatchB) {
                    return parseInt(numberMatchA[1]) - parseInt(numberMatchB[1]);
                }

                // Extract size in parentheses (S), (M), (L), etc.
                const sizeMatchA = nameA.match(/\((S|M|L|XL|XXL|XXXL)\)/i);
                const sizeMatchB = nameB.match(/\((S|M|L|XL|XXL|XXXL)\)/i);

                // If both have sizes, sort by size order
                if (sizeMatchA && sizeMatchB) {
                    const sizeA = sizeMatchA[1].toUpperCase();
                    const sizeB = sizeMatchB[1].toUpperCase();
                    const indexA = sizeOrder.indexOf(sizeA);
                    const indexB = sizeOrder.indexOf(sizeB);

                    // If both sizes are in the order list
                    if (indexA !== -1 && indexB !== -1) {
                        return indexA - indexB;
                    }
                    // If only one is in the list, prioritize it
                    if (indexA !== -1) return -1;
                    if (indexB !== -1) return 1;
                }

                // If one has number and other has size, number comes first
                if (numberMatchA && sizeMatchB) return -1;
                if (sizeMatchA && numberMatchB) return 1;

                // If one has pattern and other doesn't, pattern comes first
                if ((numberMatchA || sizeMatchA) && !(numberMatchB || sizeMatchB)) return -1;
                if ((numberMatchB || sizeMatchB) && !(numberMatchA || sizeMatchA)) return 1;

                // Default: alphabetical sort
                return nameA.localeCompare(nameB);
            });
        }

        function cleanProductForFirebase(product) {
            const cleanProduct = {
                Id: typeof product.Id === 'object' ? product.Id?.Id : product.Id,
                NameGet: String(product.NameGet || ''),
                QtyAvailable: Number(product.QtyAvailable) || 0,
                soldQty: Number(product.soldQty) || 0,
                remainingQty: Number(product.remainingQty) || 0,
                imageUrl: product.imageUrl ? String(product.imageUrl) : null,
                ProductTmplId: typeof product.ProductTmplId === 'object' ? product.ProductTmplId?.Id : product.ProductTmplId,
                ListPrice: Number(product.ListPrice) || 0, // Price for display
                PriceVariant: Number(product.PriceVariant) || 0, // Variant price for display
                addedAt: product.addedAt || Date.now(), // Timestamp for auto-cleanup
                isHidden: product.isHidden || false, // Hidden status
                lastRefreshed: product.lastRefreshed || null // Timestamp for image cache-busting
            };
            return cleanProduct;
        }

        function cleanProductsArray(products) {
            if (!Array.isArray(products)) return [];
            return products.map(p => cleanProductForFirebase(p));
        }

        async function cleanupOldProductsLocal() {
            const initialCount = Object.keys(orderProducts).length;

            try {
                const result = await cleanupOldProducts(database, orderProducts);

                if (result.removed > 0) {
                    console.log(`üóëÔ∏è ƒê√£ x√≥a ${result.removed} s·∫£n ph·∫©m c≈© h∆°n 7 ng√†y`);
                    updateProductListPreview();
                    showNotificationMessage(`üóëÔ∏è ƒê√£ x√≥a ${result.removed} s·∫£n ph·∫©m c≈© h∆°n 7 ng√†y`);
                }
            } catch (error) {
                console.error('‚ùå L·ªói cleanup:', error);
            }
        }

        async function clearAllProductsLocal() {
            const count = Object.keys(orderProducts).length;

            if (count === 0) {
                showNotificationMessage('‚ö†Ô∏è Danh s√°ch ƒë√£ tr·ªëng');
                return;
            }

            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ ${count} s·∫£n ph·∫©m kh√¥ng?`)) {
                try {
                    await clearAllProducts(database, orderProducts);
                    updateProductListPreview();
                    showNotificationMessage('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ s·∫£n ph·∫©m');
                } catch (error) {
                    console.error('‚ùå L·ªói x√≥a t·∫•t c·∫£:', error);
                    showNotificationMessage('‚ùå L·ªói: ' + error.message);
                }
            }
        }

        // ============================================================================
        // CART HISTORY / SNAPSHOT FUNCTIONS
        // ============================================================================

        // Global variables for cart history
        let cartHistorySnapshots = [];
        let pendingRestoreSnapshotId = null;

        /**
         * Calculate cart statistics
         */
        function calculateCartStats(products) {
            const productArray = Object.values(products);

            return {
                productCount: productArray.length,
                totalItems: productArray.reduce((sum, p) => sum + (p.QtyAvailable || 0), 0),
                visibleCount: productArray.filter(p => !p.isHidden).length,
                hiddenCount: productArray.filter(p => p.isHidden).length,
                soldItemsCount: productArray.reduce((sum, p) => sum + (p.soldQty || 0), 0),
                remainingItemsCount: productArray.reduce((sum, p) => sum + (p.remainingQty || p.QtyAvailable || 0), 0)
            };
        }

        /**
         * Format date time for display
         */
        function formatDateTime(date) {
            const d = new Date(date);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            return `${day}/${month}/${year} - ${hours}:${minutes}`;
        }

        /**
         * Save current cart and refresh
         */
        async function saveCartAndRefresh() {
            const productCount = Object.keys(orderProducts).length;

            if (productCount === 0) {
                showNotificationMessage('‚ö†Ô∏è Gi·ªè h√†ng ƒëang tr·ªëng, kh√¥ng c√≥ g√¨ ƒë·ªÉ l∆∞u');
                return;
            }

            const defaultName = `Gi·ªè h√†ng ${formatDateTime(new Date())}`;
            const customName = prompt('ƒê·∫∑t t√™n cho gi·ªè h√†ng n√†y:', defaultName);

            if (customName === null) return; // User cancelled

            const snapshotName = customName.trim() || defaultName;
            const description = prompt('M√¥ t·∫£ (t√πy ch·ªçn):', '') || '';

            if (!confirm(`L∆∞u gi·ªè h√†ng v·ªõi ${productCount} s·∫£n ph·∫©m v√† l√†m m·ªõi?`)) {
                return;
            }

            try {
                const stats = calculateCartStats(orderProducts);
                const snapshot = {
                    metadata: {
                        savedAt: Date.now(),
                        name: snapshotName,
                        description: description,
                        productCount: stats.productCount,
                        totalItems: stats.totalItems,
                        visibleCount: stats.visibleCount,
                        hiddenCount: stats.hiddenCount,
                        soldItemsCount: stats.soldItemsCount,
                        remainingItemsCount: stats.remainingItemsCount
                    },
                    products: { ...orderProducts }
                };

                await saveCartSnapshot(database, snapshot);
                await clearAllProducts(database, orderProducts);

                updateProductListPreview();
                await refreshCartHistory();

                showNotificationMessage('‚úÖ ƒê√£ l∆∞u gi·ªè h√†ng v√† l√†m m·ªõi th√†nh c√¥ng!');

            } catch (error) {
                console.error('Error saving cart:', error);
                showNotificationMessage('‚ùå L·ªói: ' + error.message);
            }
        }

        /**
         * Refresh cart history list
         */
        async function refreshCartHistory() {
            try {
                const snapshots = await getAllCartSnapshots(database);
                cartHistorySnapshots = snapshots;
                renderCartHistoryList(snapshots); // Show all snapshots
            } catch (error) {
                console.error('Error loading cart history:', error);
            }
        }

        /**
         * Filter cart history by selected date
         */
        function filterCartHistoryByDate() {
            const dateInput = document.getElementById('snapshotDateFilter');
            if (!dateInput || !dateInput.value) {
                renderCartHistoryList(cartHistorySnapshots);
                return;
            }

            const selectedDate = new Date(dateInput.value);
            selectedDate.setHours(0, 0, 0, 0);

            const filtered = cartHistorySnapshots.filter(snapshot => {
                const snapshotDate = new Date(snapshot.metadata.savedAt);
                snapshotDate.setHours(0, 0, 0, 0);
                return snapshotDate.getTime() === selectedDate.getTime();
            });

            renderCartHistoryList(filtered);

            if (filtered.length === 0) {
                const container = document.getElementById('cartHistoryList');
                if (container) {
                    container.innerHTML = '<div class="no-history">Kh√¥ng t√¨m th·∫•y snapshot n√†o trong ng√†y n√†y</div>';
                }
            }
        }

        /**
         * Clear date filter and show all snapshots
         */
        function clearDateFilter() {
            const dateInput = document.getElementById('snapshotDateFilter');
            if (dateInput) {
                dateInput.value = '';
            }
            renderCartHistoryList(cartHistorySnapshots);
        }

        /**
         * Render cart history list
         */
        function renderCartHistoryList(snapshots) {
            const container = document.getElementById('cartHistoryList');

            if (!container) return;

            if (snapshots.length === 0) {
                container.innerHTML = '<div class="no-history">Ch∆∞a c√≥ l·ªãch s·ª≠ gi·ªè h√†ng</div>';
                return;
            }

            container.innerHTML = snapshots.map(snapshot => {
                const snapshotId = snapshot.id;
                const meta = snapshot.metadata;

                return `
                    <div class="snapshot-card" data-snapshot-id="${snapshotId}">
                        <div class="snapshot-header">
                            <div class="snapshot-name">${meta.name}</div>
                            <div class="snapshot-date">${formatDateTime(meta.savedAt)}</div>
                        </div>

                        <div class="snapshot-stats">
                            <span>üì¶ ${meta.productCount}</span>
                            <span>üõí ${meta.soldItemsCount}</span>
                            <span>üìä ${meta.remainingItemsCount}</span>
                        </div>

                        ${meta.description ? `<div class="snapshot-desc">${meta.description}</div>` : ''}

                        <div class="snapshot-actions">
                            <button onclick="viewSnapshot('${snapshotId}')" class="btn-view" title="Xem chi ti·∫øt">üëÅÔ∏è</button>
                            <button onclick="restoreSnapshot('${snapshotId}')" class="btn-restore" title="Kh√¥i ph·ª•c">‚ôªÔ∏è</button>
                            <button onclick="deleteSnapshot('${snapshotId}')" class="btn-delete" title="X√≥a">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        /**
         * View snapshot details
         */
        async function viewSnapshot(snapshotId) {
            try {
                const snapshot = await getCartSnapshot(database, snapshotId);

                if (!snapshot) {
                    showNotificationMessage('‚ùå Kh√¥ng t√¨m th·∫•y gi·ªè h√†ng n√†y');
                    return;
                }

                // Populate modal
                document.getElementById('snapshotModalTitle').textContent = snapshot.metadata.name;
                document.getElementById('snapshotModalInfo').innerHTML = `
                    <div>üìÖ L∆∞u l√∫c: ${formatDateTime(snapshot.metadata.savedAt)}</div>
                    <div>üì¶ T·ªïng s·∫£n ph·∫©m: ${snapshot.metadata.productCount}</div>
                    <div>üõí ƒê√£ b√°n: ${snapshot.metadata.soldItemsCount}</div>
                    <div>üìä C√≤n l·∫°i: ${snapshot.metadata.remainingItemsCount}</div>
                    ${snapshot.metadata.description ? `<div>üìù M√¥ t·∫£: ${snapshot.metadata.description}</div>` : ''}
                `;

                // Render products
                renderSnapshotProducts(snapshot.products);

                // Show modal
                const modal = document.getElementById('snapshotViewModal');
                modal.style.display = 'flex';
                modal.dataset.snapshotId = snapshotId;

            } catch (error) {
                console.error('Error viewing snapshot:', error);
                showNotificationMessage('‚ùå L·ªói: ' + error.message);
            }
        }

        /**
         * Render snapshot products in modal
         */
        function renderSnapshotProducts(products) {
            const grid = document.getElementById('snapshotProductsGrid');
            if (!grid) return;

            const productArray = Object.values(products);

            grid.innerHTML = productArray.map(product => {
                const price = Math.round((product.PriceVariant || product.ListPrice || 0) / 1000);
                const imageUrl = product.imageUrl || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="200"%3E%3Crect fill="%23ddd" width="200" height="200"/%3E%3Ctext fill="%23999" x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle"%3ENo Image%3C/text%3E%3C/svg%3E';

                return `
                    <div class="snapshot-product-card">
                        <img src="${imageUrl}" alt="${product.NameGet}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext fill=%22%23999%22 x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                        <div class="product-name">${product.NameGet} ${price}K</div>
                        <div class="product-stats">
                            <span>üì¶ ${product.QtyAvailable}</span>
                            <span>üõí ${product.soldQty || 0}</span>
                            <span>üìä ${product.remainingQty || product.QtyAvailable}</span>
                        </div>
                        ${product.isHidden ? '<div class="hidden-badge">ƒê√£ ·∫©n</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        /**
         * Close snapshot view modal
         */
        function closeSnapshotModal() {
            const modal = document.getElementById('snapshotViewModal');
            if (modal) {
                modal.style.display = 'none';
                delete modal.dataset.snapshotId;
            }
        }

        /**
         * Restore snapshot from modal (safer wrapper)
         */
        async function restoreSnapshotFromModal() {
            const modal = document.getElementById('snapshotViewModal');
            const snapshotId = modal?.dataset?.snapshotId;

            console.log('DEBUG: Restore from modal, snapshotId:', snapshotId);

            if (!snapshotId) {
                console.error('DEBUG: No snapshotId found in modal dataset');
                showNotificationMessage('‚ùå L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ID gi·ªè h√†ng');
                return;
            }

            await restoreSnapshot(snapshotId);
        }

        /**
         * Restore snapshot with auto-save protection
         */
        async function restoreSnapshot(snapshotId) {
            console.log('DEBUG: restoreSnapshot() called with snapshotId:', snapshotId);

            const currentProductCount = Object.keys(orderProducts).length;
            console.log('DEBUG: Current cart has', currentProductCount, 'products');

            // Validate snapshotId
            if (!snapshotId) {
                console.error('DEBUG: snapshotId is null/undefined in restoreSnapshot()!');
                showNotificationMessage('‚ùå L·ªói: ID gi·ªè h√†ng kh√¥ng h·ª£p l·ªá');
                return;
            }

            // Store snapshot ID for later use
            pendingRestoreSnapshotId = snapshotId;
            console.log('DEBUG: Set pendingRestoreSnapshotId to:', pendingRestoreSnapshotId);

            // If current cart is empty, restore directly
            if (currentProductCount === 0) {
                console.log('DEBUG: Cart is empty, restore directly');
                if (confirm('Kh√¥i ph·ª•c gi·ªè h√†ng n√†y?')) {
                    await performRestore(snapshotId, false, null);
                }
                return;
            }

            // Show smart restore dialog
            console.log('DEBUG: Cart has products, showing restore dialog');
            showRestoreConfirmDialog(snapshotId, currentProductCount);
        }

        /**
         * Show restore confirmation dialog
         */
        function showRestoreConfirmDialog(snapshotId, currentProductCount) {
            // Update current cart count
            document.getElementById('currentCartCount').textContent = currentProductCount;

            // Generate default auto-save name
            const defaultName = `Gi·ªè h√†ng tr∆∞·ªõc khi kh√¥i ph·ª•c - ${formatDateTime(new Date())}`;
            document.getElementById('autoSaveName').value = defaultName;

            // Reset checkbox to checked (default behavior)
            const checkbox = document.getElementById('autoSaveBeforeRestore');
            checkbox.checked = true;

            // Show name input
            document.getElementById('autoSaveNameInput').style.display = 'block';

            // Show modal
            document.getElementById('restoreConfirmModal').style.display = 'flex';
        }

        /**
         * Toggle auto-save name input visibility
         */
        function toggleAutoSaveInput() {
            const checkbox = document.getElementById('autoSaveBeforeRestore');
            const nameInput = document.getElementById('autoSaveNameInput');
            nameInput.style.display = checkbox.checked ? 'block' : 'none';
        }

        /**
         * Confirm and execute restore
         */
        async function confirmRestore() {
            const shouldAutoSave = document.getElementById('autoSaveBeforeRestore').checked;
            const autoSaveName = shouldAutoSave ? document.getElementById('autoSaveName').value.trim() : null;

            console.log('DEBUG: confirmRestore() called');
            console.log('DEBUG: pendingRestoreSnapshotId:', pendingRestoreSnapshotId);
            console.log('DEBUG: shouldAutoSave:', shouldAutoSave);
            console.log('DEBUG: autoSaveName:', autoSaveName);

            // Validate pendingRestoreSnapshotId exists
            if (!pendingRestoreSnapshotId) {
                console.error('DEBUG: pendingRestoreSnapshotId is null/undefined!');
                showNotificationMessage('‚ùå L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ID gi·ªè h√†ng c·∫ßn kh√¥i ph·ª•c');
                closeRestoreConfirmModal();
                return;
            }

            // Validate auto-save name if needed
            if (shouldAutoSave && !autoSaveName) {
                showNotificationMessage('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n cho gi·ªè h√†ng s·∫Ω l∆∞u');
                return;
            }

            // IMPORTANT: Save snapshotId to local variable BEFORE closing modal
            // Because closeRestoreConfirmModal() sets pendingRestoreSnapshotId = null
            const snapshotIdToRestore = pendingRestoreSnapshotId;
            console.log('DEBUG: Saved snapshotIdToRestore:', snapshotIdToRestore);

            // Close modal
            closeRestoreConfirmModal();

            // Perform restore with auto-save (use local variable)
            await performRestore(snapshotIdToRestore, shouldAutoSave, autoSaveName);
        }

        /**
         * Close restore confirm modal
         */
        function closeRestoreConfirmModal() {
            document.getElementById('restoreConfirmModal').style.display = 'none';
            pendingRestoreSnapshotId = null;
        }

        /**
         * Perform the actual restore operation
         */
        async function performRestore(snapshotId, shouldAutoSave, autoSaveName) {
            try {
                // Step 1: Auto-save current cart if needed
                if (shouldAutoSave && Object.keys(orderProducts).length > 0) {
                    showNotificationMessage('üíæ ƒêang l∆∞u gi·ªè h√†ng hi·ªán t·∫°i...');

                    const stats = calculateCartStats(orderProducts);
                    const currentSnapshot = {
                        metadata: {
                            savedAt: Date.now(),
                            name: autoSaveName,
                            description: '(T·ª± ƒë·ªông l∆∞u tr∆∞·ªõc khi kh√¥i ph·ª•c)',
                            productCount: stats.productCount,
                            totalItems: stats.totalItems,
                            visibleCount: stats.visibleCount,
                            hiddenCount: stats.hiddenCount,
                            soldItemsCount: stats.soldItemsCount,
                            remainingItemsCount: stats.remainingItemsCount
                        },
                        products: { ...orderProducts }
                    };

                    await saveCartSnapshot(database, currentSnapshot);
                    showNotificationMessage('‚úÖ ƒê√£ l∆∞u gi·ªè h√†ng hi·ªán t·∫°i');

                    // Refresh history to show the new snapshot
                    await refreshCartHistory();
                }

                // Step 2: Load snapshot to restore
                showNotificationMessage('üîÑ ƒêang t·∫£i gi·ªè h√†ng...');

                console.log('DEBUG: Restoring snapshot ID:', snapshotId);
                const snapshot = await getCartSnapshot(database, snapshotId);
                console.log('DEBUG: Snapshot loaded:', snapshot);

                if (!snapshot) {
                    console.error('DEBUG: Snapshot is null or undefined');
                    showNotificationMessage('‚ùå Kh√¥ng t√¨m th·∫•y gi·ªè h√†ng');
                    return;
                }

                if (!snapshot.products) {
                    console.error('DEBUG: Snapshot.products is missing. Snapshot structure:', snapshot);
                    showNotificationMessage('‚ùå D·ªØ li·ªáu gi·ªè h√†ng kh√¥ng h·ª£p l·ªá (thi·∫øu products)');
                    return;
                }

                const productCount = Object.keys(snapshot.products).length;
                if (productCount === 0) {
                    console.error('DEBUG: Snapshot.products is empty');
                    showNotificationMessage('‚ùå Gi·ªè h√†ng kh√¥ng c√≥ s·∫£n ph·∫©m');
                    return;
                }

                console.log('DEBUG: Snapshot has', productCount, 'products');

                // Step 3: Clear current products
                showNotificationMessage('üóëÔ∏è ƒêang x√≥a gi·ªè h√†ng hi·ªán t·∫°i...');
                await clearAllProducts(database, orderProducts);

                // Step 4: Restore products from snapshot
                showNotificationMessage('‚ôªÔ∏è ƒêang kh√¥i ph·ª•c s·∫£n ph·∫©m...');
                await restoreProductsFromSnapshot(database, snapshot.products, orderProducts);

                // Step 5: Update UI
                updateProductListPreview();

                // Close any open modals
                closeSnapshotModal();

                // Show success message
                const successMsg = shouldAutoSave
                    ? `‚úÖ ƒê√£ l∆∞u gi·ªè c≈© v√† kh√¥i ph·ª•c ${snapshot.metadata.productCount} s·∫£n ph·∫©m`
                    : `‚úÖ ƒê√£ kh√¥i ph·ª•c ${snapshot.metadata.productCount} s·∫£n ph·∫©m`;

                showNotificationMessage(successMsg);

            } catch (error) {
                console.error('Error restoring snapshot:', error);
                showNotificationMessage('‚ùå L·ªói: ' + error.message);
            }
        }

        /**
         * Delete snapshot
         */
        async function deleteSnapshot(snapshotId) {
            if (!confirm('‚ö†Ô∏è X√≥a gi·ªè h√†ng ƒë√£ l∆∞u n√†y?\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
                return;
            }

            try {
                await deleteCartSnapshot(database, snapshotId);
                await refreshCartHistory();
                showNotificationMessage('üóëÔ∏è ƒê√£ x√≥a gi·ªè h√†ng ƒë√£ l∆∞u');

            } catch (error) {
                console.error('Error deleting snapshot:', error);
                showNotificationMessage('‚ùå L·ªói: ' + error.message);
            }
        }

        /**
         * Toggle cart history section collapse/expand
         */
        function toggleCartHistory() {
            const list = document.getElementById('cartHistoryList');
            const icon = document.getElementById('cartHistoryToggleIcon');
            const dateFilter = document.getElementById('dateFilterContainer');

            if (!list || !icon) return;

            const isCollapsed = list.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand
                list.classList.remove('collapsed');
                icon.classList.add('expanded');
                if (dateFilter) dateFilter.style.display = 'block';
                // Save state to localStorage
                localStorage.setItem('cartHistoryExpanded', 'true');
            } else {
                // Collapse
                list.classList.add('collapsed');
                icon.classList.remove('expanded');
                if (dateFilter) dateFilter.style.display = 'none';
                // Save state to localStorage
                localStorage.setItem('cartHistoryExpanded', 'false');
            }
        }

        /**
         * Initialize cart history collapse state from localStorage
         */
        function initCartHistoryState() {
            const list = document.getElementById('cartHistoryList');
            const icon = document.getElementById('cartHistoryToggleIcon');
            const dateFilter = document.getElementById('dateFilterContainer');

            if (!list || !icon) return;

            // Check saved state (default is collapsed)
            const isExpanded = localStorage.getItem('cartHistoryExpanded') === 'true';

            if (isExpanded) {
                list.classList.remove('collapsed');
                icon.classList.add('expanded');
                if (dateFilter) dateFilter.style.display = 'block';
            } else {
                list.classList.add('collapsed');
                icon.classList.remove('expanded');
                if (dateFilter) dateFilter.style.display = 'none';
            }
        }

        async function getAuthToken() {
            try {
                const response = await fetch('https://tomato.tpos.vn/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'grant_type=password&username=nvkt&password=Aa%40123456789&client_id=tmtWebApp'
                });

                if (!response.ok) {
                    throw new Error('Kh√¥ng th·ªÉ x√°c th·ª±c');
                }

                const data = await response.json();
                bearerToken = data.access_token;
                tokenExpiry = Date.now() + (data.expires_in * 1000);

                localStorage.setItem('bearerToken', bearerToken);
                localStorage.setItem('tokenExpiry', tokenExpiry.toString());

                console.log('‚úÖ ƒê√£ x√°c th·ª±c th√†nh c√¥ng');
                return bearerToken;
            } catch (error) {
                console.error('‚ùå L·ªói x√°c th·ª±c:', error);
                throw error;
            }
        }

        async function getValidToken() {
            const storedToken = localStorage.getItem('bearerToken');
            const storedExpiry = localStorage.getItem('tokenExpiry');

            if (storedToken && storedExpiry) {
                const expiry = parseInt(storedExpiry);
                if (expiry > Date.now() + 300000) {
                    bearerToken = storedToken;
                    tokenExpiry = expiry;
                    console.log('‚úÖ S·ª≠ d·ª•ng token ƒë√£ l∆∞u');
                    return bearerToken;
                }
            }

            return await getAuthToken();
        }

        async function authenticatedFetch(url, options = {}) {
            const token = await getValidToken();

            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };

            const response = await fetch(url, {
                ...options,
                headers
            });

            if (response.status === 401) {
                console.log('üîÑ Token h·∫øt h·∫°n, ƒëang l·∫•y token m·ªõi...');
                const newToken = await getAuthToken();
                headers.Authorization = `Bearer ${newToken}`;

                return fetch(url, {
                    ...options,
                    headers
                });
            }

            return response;
        }

        function logoutUser() {
            if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒëƒÉng xu·∫•t?')) {
                // Clear all auth data
                localStorage.removeItem('bearerToken');
                localStorage.removeItem('tokenExpiry');
                sessionStorage.removeItem('loginindex_auth');
                localStorage.removeItem('loginindex_auth');

                // Redirect to home page
                window.location.href = 'https://nhijudyshop.github.io/n2store/';
            }
        }

        function removeVietnameseTones(str) {
            if (!str) return '';
            str = str.toLowerCase();
            str = str.replace(/√†|√°|·∫°|·∫£|√£|√¢|·∫ß|·∫•|·∫≠|·∫©|·∫´|ƒÉ|·∫±|·∫Ø|·∫∑|·∫≥|·∫µ/g, 'a');
            str = str.replace(/√®|√©|·∫π|·∫ª|·∫Ω|√™|·ªÅ|·∫ø|·ªá|·ªÉ|·ªÖ/g, 'e');
            str = str.replace(/√¨|√≠|·ªã|·ªâ|ƒ©/g, 'i');
            str = str.replace(/√≤|√≥|·ªç|·ªè|√µ|√¥|·ªì|·ªë|·ªô|·ªï|·ªó|∆°|·ªù|·ªõ|·ª£|·ªü|·ª°/g, 'o');
            str = str.replace(/√π|√∫|·ª•|·ªß|≈©|∆∞|·ª´|·ª©|·ª±|·ª≠|·ªØ/g, 'u');
            str = str.replace(/·ª≥|√Ω|·ªµ|·ª∑|·ªπ/g, 'y');
            str = str.replace(/ƒë/g, 'd');
            return str;
        }

        async function loadExcelData() {
            if (isLoadingExcel || productsData.length > 0) return;

            isLoadingExcel = true;
            const loadingIndicator = document.getElementById('loadingIndicator');
            loadingIndicator.style.display = 'block';

            try {
                const response = await authenticatedFetch('https://tomato.tpos.vn/Product/ExportFileWithVariantPrice', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: { Active: "true" },
                        ids: ""
                    })
                });

                if (!response.ok) {
                    throw new Error('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu s·∫£n ph·∫©m');
                }

                const blob = await response.blob();
                const arrayBuffer = await blob.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                productsData = jsonData.map(row => ({
                    id: row['Id s·∫£n ph·∫©m (*)'],
                    name: row['T√™n s·∫£n ph·∫©m'],
                    nameNoSign: removeVietnameseTones(row['T√™n s·∫£n ph·∫©m'] || ''),
                    code: row['M√£ s·∫£n ph·∫©m']
                }));

                console.log(`ƒê√£ load ${productsData.length} s·∫£n ph·∫©m`);
            } catch (error) {
                console.error('Error loading Excel:', error);
                alert('L·ªói khi t·∫£i d·ªØ li·ªáu s·∫£n ph·∫©m: ' + error.message);
            } finally {
                loadingIndicator.style.display = 'none';
                isLoadingExcel = false;
            }
        }

        function searchProducts(searchText) {
            if (!searchText || searchText.length < 2) return [];

            const searchLower = searchText.toLowerCase();
            const searchNoSign = removeVietnameseTones(searchText);

            // Filter products that match
            const matchedProducts = productsData.filter(product => {
                // Match in product name (no Vietnamese tones)
                const matchName = product.nameNoSign.includes(searchNoSign);

                // Match in original name (lowercase, for special chars like [Q5X1])
                const matchNameOriginal = product.name && product.name.toLowerCase().includes(searchLower);

                // Match in product code
                const matchCode = product.code && product.code.toLowerCase().includes(searchLower);

                return matchName || matchNameOriginal || matchCode;
            });

            // Sort by priority: match in [] first, then code, then name
            matchedProducts.sort((a, b) => {
                // Extract text within [] brackets
                const extractBracket = (name) => {
                    const match = name?.match(/\[([^\]]+)\]/);
                    return match ? match[1].toLowerCase().trim() : '';
                };

                const aBracket = extractBracket(a.name);
                const bBracket = extractBracket(b.name);

                // Check if search term matches in brackets
                const aMatchInBracket = aBracket && aBracket.includes(searchLower);
                const bMatchInBracket = bBracket && bBracket.includes(searchLower);

                // Priority 1: Match in brackets
                if (aMatchInBracket && !bMatchInBracket) return -1;
                if (!aMatchInBracket && bMatchInBracket) return 1;

                // Priority 2: Among bracket matches, exact match comes first
                if (aMatchInBracket && bMatchInBracket) {
                    const aExactMatch = aBracket === searchLower;
                    const bExactMatch = bBracket === searchLower;
                    if (aExactMatch && !bExactMatch) return -1;
                    if (!aExactMatch && bExactMatch) return 1;

                    // If both exact or both not exact, sort by bracket length (shorter first)
                    if (aBracket.length !== bBracket.length) {
                        return aBracket.length - bBracket.length;
                    }

                    // If same length, sort alphabetically
                    return aBracket.localeCompare(bBracket);
                }

                // Priority 3: Match in product code
                const aMatchInCode = a.code && a.code.toLowerCase().includes(searchLower);
                const bMatchInCode = b.code && b.code.toLowerCase().includes(searchLower);

                if (aMatchInCode && !bMatchInCode) return -1;
                if (!aMatchInCode && bMatchInCode) return 1;

                // Priority 4: Sort alphabetically by product name
                return a.name.localeCompare(b.name);
            });

            return matchedProducts.slice(0, 10);
        }

        function displaySuggestions(suggestions) {
            const suggestionsDiv = document.getElementById('suggestions');

            if (suggestions.length === 0) {
                suggestionsDiv.classList.remove('show');
                return;
            }

            suggestionsDiv.innerHTML = suggestions.map(product => `
                <div class="suggestion-item" data-id="${product.id}">
                    <strong>${product.code || ''}</strong> - ${product.name}
                </div>
            `).join('');

            suggestionsDiv.classList.add('show');

            suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
                item.addEventListener('click', () => {
                    const productId = item.dataset.id;
                    loadProductDetails(productId);
                    suggestionsDiv.classList.remove('show');
                    document.getElementById('productSearch').value = item.textContent.trim();
                });
            });
        }

        async function loadProductDetails(productId) {
            try {
                const response = await authenticatedFetch(
                    `https://tomato.tpos.vn/odata/Product(${productId})?$expand=UOM,Categ,UOMPO,POSCateg,AttributeValues`
                );

                if (!response.ok) {
                    throw new Error('Kh√¥ng th·ªÉ t·∫£i th√¥ng tin s·∫£n ph·∫©m');
                }

                const productData = await response.json();
                let imageUrl = productData.ImageUrl;
                let templateData = null;

                // Load template to get image and variants
                if (productData.ProductTmplId) {
                    try {
                        const templateResponse = await authenticatedFetch(
                            `https://tomato.tpos.vn/odata/ProductTemplate(${productData.ProductTmplId})?$expand=UOM,UOMCateg,Categ,UOMPO,POSCateg,Taxes,SupplierTaxes,Product_Teams,Images,UOMView,Distributor,Importer,Producer,OriginCountry,ProductVariants($expand=UOM,Categ,UOMPO,POSCateg,AttributeValues)`
                        );

                        if (templateResponse.ok) {
                            templateData = await templateResponse.json();
                            if (!imageUrl) {
                                imageUrl = templateData.ImageUrl;
                            }
                        }
                    } catch (fallbackError) {
                        console.error('Error loading template:', fallbackError);
                    }
                }

                // Check if auto-add variants is enabled and variants exist
                if (autoAddVariants && templateData && templateData.ProductVariants && templateData.ProductVariants.length > 0) {
                    // Filter only active variants (Active === true)
                    const activeVariants = templateData.ProductVariants.filter(v => v.Active === true);

                    // Sort variants by number (1), (2), (3)... and size (S), (M), (L), (XL), (XXL), (XXXL)
                    const sortedVariants = sortVariants(activeVariants);

                    // Check if there are active variants after filtering
                    if (sortedVariants.length === 0) {
                        // No active variants, fallback to single product
                        const tposQty = productData.QtyAvailable || 0;
                        const userInput = prompt(`Nh·∫≠p s·ªë l∆∞·ª£ng t·ªìn kho cho ${productData.NameGet}:`, tposQty);
                        const qtyAvailable = userInput !== null ? parseInt(userInput) || 0 : tposQty;
                        const addSuccess = await addProductToList({
                            Id: productData.Id,
                            NameGet: productData.NameGet,
                            QtyAvailable: qtyAvailable,
                            ProductTmplId: productData.ProductTmplId,
                            ListPrice: productData.ListPrice || 0,
                            PriceVariant: productData.PriceVariant || 0,
                            imageUrl: imageUrl,
                            soldQty: 0,
                            remainingQty: 0
                        }, true);

                        if (addSuccess) {
                            document.getElementById('productSearch').value = '';
                        }
                        return; // Exit early
                    }

                    // Prepare all variants for batch add
                    const variantsToAdd = sortedVariants.map(variant => {
                        const tposQty = variant.QtyAvailable || 0;
                        // Prompt user to input inventory quantity
                        const userInput = prompt(`Nh·∫≠p s·ªë l∆∞·ª£ng t·ªìn kho cho ${variant.NameGet}:`, tposQty);
                        const qtyAvailable = userInput !== null ? parseInt(userInput) || 0 : tposQty;
                        const variantImageUrl = variant.ImageUrl || imageUrl; // Use variant image or fallback to template image

                        return cleanProductForFirebase({
                            Id: variant.Id,
                            NameGet: variant.NameGet,
                            QtyAvailable: qtyAvailable,
                            ProductTmplId: productData.ProductTmplId,
                            ListPrice: variant.ListPrice || 0,
                            PriceVariant: variant.PriceVariant || 0,
                            imageUrl: variantImageUrl,
                            soldQty: 0,
                            remainingQty: 0,
                            isHidden: false // Variants are visible
                        });
                    });

                    // Use batch add helper (only variants, no main product)
                    try {
                        const result = await addProductsToFirebase(database, variantsToAdd, orderProducts);

                        updateProductListPreview();

                        const totalAdded = result.added;
                        const totalUpdated = result.updated;

                        if (totalAdded > 0 && totalUpdated > 0) {
                            showNotificationMessage(`‚úÖ ƒê√£ th√™m ${totalAdded} bi·∫øn th·ªÉ m·ªõi, c·∫≠p nh·∫≠t ${totalUpdated} bi·∫øn th·ªÉ (gi·ªØ nguy√™n s·ªë l∆∞·ª£ng ƒë√£ b√°n)`);
                        } else if (totalUpdated > 0) {
                            showNotificationMessage(`üîÑ ƒê√£ c·∫≠p nh·∫≠t ${totalUpdated} bi·∫øn th·ªÉ (gi·ªØ nguy√™n s·ªë l∆∞·ª£ng ƒë√£ b√°n)`);
                        } else if (totalAdded > 0) {
                            showNotificationMessage(`‚úÖ ƒê√£ th√™m ${totalAdded} bi·∫øn th·ªÉ s·∫£n ph·∫©m`);
                        }

                        document.getElementById('productSearch').value = '';
                    } catch (error) {
                        console.error('‚ùå Error saving variants to Firebase:', error);
                        showNotificationMessage('‚ö†Ô∏è L·ªói ƒë·ªìng b·ªô Firebase: ' + error.message);
                    }
                } else {
                    // Add single product (original behavior)
                    const tposQty = productData.QtyAvailable || 0;
                    // Prompt user to input inventory quantity
                    const userInput = prompt(`Nh·∫≠p s·ªë l∆∞·ª£ng t·ªìn kho cho ${productData.NameGet}:`, tposQty);
                    const qtyAvailable = userInput !== null ? parseInt(userInput) || 0 : tposQty;
                    const addSuccess = addProductToList({
                        Id: productData.Id,
                        NameGet: productData.NameGet,
                        QtyAvailable: qtyAvailable,
                        ProductTmplId: productData.ProductTmplId,
                        ListPrice: productData.ListPrice || 0,
                        PriceVariant: productData.PriceVariant || 0,
                        imageUrl: imageUrl,
                        soldQty: 0,
                        remainingQty: qtyAvailable
                    }, true);

                    if (addSuccess) {
                        document.getElementById('productSearch').value = '';
                    }
                }
            } catch (error) {
                console.error('Error loading product:', error);
                showNotificationMessage('‚ùå L·ªói: ' + error.message);
            }
        }

        async function addProductToList(product, showNotification = true) {
            try {
                const cleanProduct = cleanProductForFirebase(product);

                if (!isSyncingFromFirebase) {
                    const result = await addProductToFirebase(database, cleanProduct, orderProducts);

                    if (showNotification) {
                        if (result.action === 'updated') {
                            showNotificationMessage('üîÑ ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin s·∫£n ph·∫©m (gi·ªØ nguy√™n s·ªë l∆∞·ª£ng ƒë√£ b√°n)');
                        } else {
                            showNotificationMessage('‚úÖ ƒê√£ th√™m s·∫£n ph·∫©m v√†o danh s√°ch');
                        }
                    }
                } else {
                    // During sync from Firebase, just add to local object
                    const productKey = `product_${cleanProduct.Id}`;
                    const existingProduct = orderProducts[productKey];

                    if (existingProduct) {
                        orderProducts[productKey] = {
                            ...cleanProduct,
                            soldQty: existingProduct.soldQty || 0,
                            remainingQty: existingProduct.remainingQty || cleanProduct.remainingQty || 0,
                            addedAt: existingProduct.addedAt || cleanProduct.addedAt,
                            lastRefreshed: Date.now()
                        };
                    } else {
                        orderProducts[productKey] = cleanProduct;
                    }
                }

                updateProductListPreview();

                return true;
            } catch (error) {
                console.error('‚ùå L·ªói th√™m s·∫£n ph·∫©m:', error);
                showNotificationMessage('‚ùå L·ªói: ' + error.message);
                return false;
            }
        }

        function updateProductListPreview() {
            const productListSection = document.getElementById('productListSection');
            const productListPreview = document.getElementById('productListPreview');
            const productCount = document.getElementById('productCount');

            // Filter visible (not hidden) products
            const visibleProducts = Object.values(orderProducts).filter(p => !p.isHidden);

            if (visibleProducts.length === 0) {
                productListSection.style.display = 'none';
            } else {
                productListSection.style.display = 'block';
            }

            // Use filtered products if searching, otherwise use all visible products
            const productsToDisplay = listSearchKeyword ? filteredProductsInList : visibleProducts;

            productCount.textContent = listSearchKeyword
                ? `${productsToDisplay.length}/${visibleProducts.length}`
                : visibleProducts.length;

            // Group products by ProductTmplId to keep variants together
            const groupedProducts = {};
            productsToDisplay.forEach(product => {
                const tmplId = product.ProductTmplId || product.Id;
                if (!groupedProducts[tmplId]) {
                    groupedProducts[tmplId] = {
                        products: [],
                        maxAddedAt: 0
                    };
                }
                groupedProducts[tmplId].products.push(product);
                // Track latest addedAt for sorting groups
                groupedProducts[tmplId].maxAddedAt = Math.max(
                    groupedProducts[tmplId].maxAddedAt,
                    product.addedAt || 0
                );
            });

            // Sort each group's variants, then sort groups by addedAt (recent first)
            const sortedGroups = Object.values(groupedProducts)
                .map(group => ({
                    products: sortVariants(group.products),
                    maxAddedAt: group.maxAddedAt
                }))
                .sort((a, b) => b.maxAddedAt - a.maxAddedAt);

            // Flatten groups to get final sorted product list
            const recentProducts = sortedGroups.flatMap(group => group.products);

            productListPreview.innerHTML = recentProducts.map(product => {
                const imageHtml = product.imageUrl
                    ? `<img src="${product.imageUrl}" class="preview-image" alt="${product.NameGet}">`
                    : `<div class="preview-image no-image">üì¶</div>`;

                return `
                    <div class="preview-item">
                        ${imageHtml}
                        <div class="preview-info">
                            <div class="preview-name">${product.NameGet}</div>
                            <div class="preview-stats">
                                <span>üì¶ T·ªïng: <input type="number" class="editable-qty-input" value="${product.QtyAvailable}" onchange="updateProductTotalInput(${product.Id}, this.value)" min="0"></span>
                                <div class="qty-control">
                                    <button class="qty-btn" onclick="updateProductQty(${product.Id}, -1)">‚àí</button>
                                    <span class="qty-value">${product.soldQty}</span>
                                    <button class="qty-btn" onclick="updateProductQty(${product.Id}, 1)">+</button>
                                </div>
                                <span>üìù ƒê√£ ƒë·∫∑t: <input type="number" class="editable-qty-input" value="${product.remainingQty || 0}" onchange="updateProductOrderedInput(${product.Id}, this.value)" min="0"></span>
                            </div>
                        </div>
                        <div class="preview-actions">
                            <button class="btn-change-image" onclick="changeProductImage(${product.Id})">üñºÔ∏è ƒê·ªïi ·∫£nh</button>
                            <button class="btn-remove" onclick="removeProduct(${product.Id})">üóëÔ∏è X√≥a</button>
                        </div>
                    </div>
                `;
            }).join('');

            // Update hidden products list
            updateHiddenProductListPreview();
        }

        function updateHiddenProductListPreview() {
            const hiddenProductsSection = document.getElementById('hiddenProductsSection');
            const hiddenProductListPreview = document.getElementById('hiddenProductListPreview');
            const hiddenProductCount = document.getElementById('hiddenProductCount');

            // Filter hidden products
            const hiddenProducts = Object.values(orderProducts).filter(p => p.isHidden);

            if (hiddenProducts.length === 0) {
                hiddenProductsSection.style.display = 'none';
                return;
            }

            hiddenProductsSection.style.display = 'block';

            // Use filtered products if searching, otherwise use all hidden products
            const productsToDisplay = hiddenListSearchKeyword ? filteredHiddenProducts : hiddenProducts;

            hiddenProductCount.textContent = hiddenListSearchKeyword
                ? `${productsToDisplay.length}/${hiddenProducts.length}`
                : hiddenProducts.length;

            const recentProducts = [...productsToDisplay].reverse();

            hiddenProductListPreview.innerHTML = recentProducts.map(product => {
                const imageHtml = product.imageUrl
                    ? `<img src="${product.imageUrl}" class="preview-image" alt="${product.NameGet}">`
                    : `<div class="preview-image no-image">üì¶</div>`;

                return `
                    <div class="preview-item">
                        ${imageHtml}
                        <div class="preview-info">
                            <div class="preview-name">${product.NameGet}</div>
                            <div class="preview-stats">
                                <span>üì¶ T·ªïng: <input type="number" class="editable-qty-input" value="${product.QtyAvailable}" onchange="updateProductTotalInput(${product.Id}, this.value)" min="0"></span>
                                <div class="qty-control">
                                    <button class="qty-btn" onclick="updateProductQty(${product.Id}, -1)">‚àí</button>
                                    <span class="qty-value">${product.soldQty}</span>
                                    <button class="qty-btn" onclick="updateProductQty(${product.Id}, 1)">+</button>
                                </div>
                                <span>üìù ƒê√£ ƒë·∫∑t: <input type="number" class="editable-qty-input" value="${product.remainingQty || 0}" onchange="updateProductOrderedInput(${product.Id}, this.value)" min="0"></span>
                            </div>
                        </div>
                        <div class="preview-actions">
                            <button class="btn-change-image" onclick="changeProductImage(${product.Id})">üñºÔ∏è ƒê·ªïi ·∫£nh</button>
                            <button class="btn-remove" onclick="unhideProduct(${product.Id})" style="background: #28a745;">üëÅÔ∏è Hi·ªán</button>
                            <button class="btn-remove" onclick="removeProduct(${product.Id})">üóëÔ∏è X√≥a</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function unhideProduct(productId) {
            if (!isSyncingFromFirebase) {
                try {
                    await updateProductVisibility(database, productId, false, orderProducts);
                    updateProductListPreview();
                    updateHiddenProductListPreview();
                    showNotificationMessage('üëÅÔ∏è ƒê√£ hi·ªán s·∫£n ph·∫©m');
                } catch (error) {
                    console.error('‚ùå L·ªói hi·ªán s·∫£n ph·∫©m:', error);
                }
            }
        }

        async function updateProductQty(productId, change) {
            if (!isSyncingFromFirebase) {
                try {
                    await updateProductQtyInFirebase(database, productId, change, orderProducts);
                    updateProductListPreview();
                    updateHiddenProductListPreview();
                } catch (error) {
                    console.error('‚ùå L·ªói c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng:', error);
                }
            }
        }

        async function updateProductTotalInput(productId, newValue) {
            if (!isSyncingFromFirebase) {
                try {
                    const productKey = `product_${productId}`;
                    const product = orderProducts[productKey];
                    if (!product) return;

                    const newQtyAvailable = Math.max(0, parseInt(newValue) || 0);
                    if (newQtyAvailable === product.QtyAvailable) return;

                    product.QtyAvailable = newQtyAvailable;

                    // Ensure soldQty doesn't exceed new total
                    if (product.soldQty > product.QtyAvailable) {
                        product.soldQty = product.QtyAvailable;
                    }

                    await database.ref(`orderProducts/${productKey}`).update({
                        QtyAvailable: product.QtyAvailable,
                        soldQty: product.soldQty
                    });

                    updateProductListPreview();
                    updateHiddenProductListPreview();
                } catch (error) {
                    console.error('‚ùå L·ªói c·∫≠p nh·∫≠t t·ªïng s·ªë l∆∞·ª£ng:', error);
                }
            }
        }

        async function updateProductOrderedInput(productId, newValue) {
            if (!isSyncingFromFirebase) {
                try {
                    const productKey = `product_${productId}`;
                    const product = orderProducts[productKey];
                    if (!product) return;

                    const newOrderedQty = Math.max(0, parseInt(newValue) || 0);

                    if (newOrderedQty === product.remainingQty) return;

                    // Update remainingQty independently (now represents "ƒê√£ ƒë·∫∑t" - ordered quantity)
                    product.remainingQty = newOrderedQty;

                    await database.ref(`orderProducts/${productKey}`).update({
                        remainingQty: product.remainingQty
                    });

                    updateProductListPreview();
                    updateHiddenProductListPreview();
                } catch (error) {
                    console.error('‚ùå L·ªói c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ƒë√£ ƒë·∫∑t:', error);
                }
            }
        }

        async function removeProduct(productId) {
            if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a s·∫£n ph·∫©m n√†y?')) {
                try {
                    if (!isSyncingFromFirebase) {
                        await removeProductFromFirebase(database, productId, orderProducts);
                    }

                    // Re-apply search if active
                    if (listSearchKeyword) {
                        performListSearch(listSearchKeyword);
                    } else {
                        updateProductListPreview();
                    }

                    // Also update hidden products list
                    if (hiddenListSearchKeyword) {
                        performHiddenListSearch(hiddenListSearchKeyword);
                    } else {
                        updateHiddenProductListPreview();
                    }

                    showNotificationMessage('üóëÔ∏è ƒê√£ x√≥a s·∫£n ph·∫©m');
                } catch (error) {
                    console.error('‚ùå L·ªói x√≥a s·∫£n ph·∫©m:', error);
                    showNotificationMessage('‚ùå L·ªói: ' + error.message);
                }
            }
        }

        // Image Modal State
        let currentEditingProductId = null;
        let currentImageData = null; // Store base64 or URL

        function changeProductImage(productId) {
            const productKey = `product_${productId}`;
            const product = orderProducts[productKey];
            if (!product) {
                showNotificationMessage('‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
                return;
            }

            currentEditingProductId = productId;
            currentImageData = null;

            // Pre-fill link input if product has existing image
            const linkInput = document.getElementById('linkInput');
            if (linkInput && product.imageUrl) {
                linkInput.value = product.imageUrl;
                handleLinkInput({ target: linkInput });
            }

            // Open modal
            const modal = document.getElementById('imageModalOverlay');
            modal.classList.add('show');

            // Focus on paste area by default
            setTimeout(() => {
                document.getElementById('pasteArea').focus();
            }, 100);
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModalOverlay');
            modal.classList.remove('show');

            // Reset state
            currentEditingProductId = null;
            currentImageData = null;

            // Reset all tabs
            resetPasteTab();
            resetUploadTab();
            resetCameraTab();
            resetLinkTab();

            // Switch back to paste tab
            switchImageTab('paste');
        }

        function switchImageTab(tabName) {
            // Update tab buttons
            const tabs = document.querySelectorAll('.image-modal-tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Update tab contents
            const contents = document.querySelectorAll('.image-modal-content');
            contents.forEach(content => content.classList.remove('active'));

            // Activate selected tab
            if (tabName === 'paste') {
                tabs[0].classList.add('active');
                document.getElementById('pasteTab').classList.add('active');
            } else if (tabName === 'upload') {
                tabs[1].classList.add('active');
                document.getElementById('uploadTab').classList.add('active');
            } else if (tabName === 'camera') {
                tabs[2].classList.add('active');
                document.getElementById('cameraTab').classList.add('active');
            } else if (tabName === 'link') {
                tabs[3].classList.add('active');
                document.getElementById('linkTab').classList.add('active');
            }
        }

        function resetPasteTab() {
            const pasteArea = document.getElementById('pasteArea');
            const pastePreview = document.getElementById('pastePreview');
            pasteArea.classList.remove('has-image');
            pastePreview.classList.remove('show');
            pastePreview.src = '';
        }

        function resetUploadTab() {
            const uploadArea = document.getElementById('fileUploadArea');
            const uploadPreview = document.getElementById('uploadPreview');
            const fileInput = document.getElementById('fileUploadInput');
            uploadArea.classList.remove('has-image');
            uploadPreview.classList.remove('show');
            uploadPreview.src = '';
            fileInput.value = '';
        }

        function resetLinkTab() {
            const linkInput = document.getElementById('linkInput');
            const linkPreviewContainer = document.getElementById('linkPreviewContainer');
            const linkPreviewImage = document.getElementById('linkPreviewImage');
            linkInput.value = '';
            linkPreviewContainer.classList.remove('show');
            linkPreviewImage.src = '';
        }

        function resetCameraTab() {
            stopCamera();
            const cameraPreview = document.getElementById('cameraPreview');
            cameraPreview.classList.remove('show');
            cameraPreview.src = '';
        }

        // Camera functionality
        let cameraStream = null;
        let currentFacingMode = 'environment'; // 'user' for front, 'environment' for back

        async function startCamera() {
            try {
                // Request camera permission
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                };

                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Set video source
                const video = document.getElementById('cameraVideo');
                video.srcObject = cameraStream;

                // Show video, hide message
                const cameraMessage = document.getElementById('cameraMessage');
                cameraMessage.style.display = 'none';
                video.style.display = 'block';

                // Update button visibility
                document.getElementById('btnStartCamera').style.display = 'none';
                document.getElementById('btnSwitchCamera').style.display = 'flex';
                document.getElementById('btnCapturePhoto').style.display = 'flex';
                document.getElementById('btnStopCamera').style.display = 'flex';

                showNotificationMessage('‚úÖ ƒê√£ b·∫≠t camera');
            } catch (error) {
                console.error('Error accessing camera:', error);
                showNotificationMessage('‚ùå Kh√¥ng th·ªÉ truy c·∫≠p camera: ' + error.message);
            }
        }

        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;

                const video = document.getElementById('cameraVideo');
                const cameraMessage = document.getElementById('cameraMessage');

                video.style.display = 'none';
                cameraMessage.style.display = 'flex';

                // Update button visibility
                document.getElementById('btnStartCamera').style.display = 'flex';
                document.getElementById('btnSwitchCamera').style.display = 'none';
                document.getElementById('btnCapturePhoto').style.display = 'none';
                document.getElementById('btnStopCamera').style.display = 'none';
            }
        }

        async function switchCamera() {
            // Toggle facing mode
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';

            // Restart camera with new facing mode
            stopCamera();
            await startCamera();
        }

        function capturePhoto() {
            const video = document.getElementById('cameraVideo');
            const canvas = document.getElementById('cameraCanvas');
            const preview = document.getElementById('cameraPreview');

            // Set canvas dimensions to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw video frame to canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Convert to base64
            const base64 = canvas.toDataURL('image/jpeg', 0.9);
            currentImageData = base64;

            // Show preview
            preview.src = base64;
            preview.classList.add('show');

            // Stop camera after capture
            stopCamera();

            showNotificationMessage('üì∏ ƒê√£ ch·ª•p ·∫£nh th√†nh c√¥ng');
        }

        // Paste Image Handler
        function focusPasteArea() {
            const pasteArea = document.getElementById('pasteArea');
            pasteArea.focus();
        }

        // Listen for paste events in the modal
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('imageModalOverlay');

            modal.addEventListener('paste', (e) => {
                // Only handle if modal is open and paste tab is active
                const isModalOpen = modal.classList.contains('show');
                const isPasteTabActive = document.getElementById('pasteTab').classList.contains('active');

                if (!isModalOpen || !isPasteTabActive) return;

                handlePaste(e);
            });
        });

        function handlePaste(e) {
            e.preventDefault();

            const items = (e.clipboardData || e.originalEvent.clipboardData).items;

            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();

                    reader.onload = (event) => {
                        const base64 = event.target.result;
                        currentImageData = base64;

                        // Show preview
                        const pastePreview = document.getElementById('pastePreview');
                        const pasteArea = document.getElementById('pasteArea');

                        pastePreview.src = base64;
                        pastePreview.classList.add('show');
                        pasteArea.classList.add('has-image');

                        showNotificationMessage('‚úÖ ƒê√£ paste ·∫£nh th√†nh c√¥ng');
                    };

                    reader.readAsDataURL(blob);
                    return;
                }
            }

            showNotificationMessage('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ·∫£nh trong clipboard');
        }

        // Upload File Handler
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showNotificationMessage('‚ö†Ô∏è Vui l√≤ng ch·ªçn file ·∫£nh');
                return;
            }

            const reader = new FileReader();

            reader.onload = (e) => {
                const base64 = e.target.result;
                currentImageData = base64;

                // Show preview
                const uploadPreview = document.getElementById('uploadPreview');
                const uploadArea = document.getElementById('fileUploadArea');

                uploadPreview.src = base64;
                uploadPreview.classList.add('show');
                uploadArea.classList.add('has-image');

                showNotificationMessage('‚úÖ ƒê√£ ch·ªçn file th√†nh c√¥ng');
            };

            reader.readAsDataURL(file);
        }

        // Drag and Drop for Upload
        document.addEventListener('DOMContentLoaded', () => {
            const uploadArea = document.getElementById('fileUploadArea');

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');

                const file = e.dataTransfer.files[0];
                if (!file) return;

                if (!file.type.startsWith('image/')) {
                    showNotificationMessage('‚ö†Ô∏è Vui l√≤ng ch·ªçn file ·∫£nh');
                    return;
                }

                const reader = new FileReader();

                reader.onload = (event) => {
                    const base64 = event.target.result;
                    currentImageData = base64;

                    // Show preview
                    const uploadPreview = document.getElementById('uploadPreview');

                    uploadPreview.src = base64;
                    uploadPreview.classList.add('show');
                    uploadArea.classList.add('has-image');

                    showNotificationMessage('‚úÖ ƒê√£ t·∫£i ·∫£nh l√™n th√†nh c√¥ng');
                };

                reader.readAsDataURL(file);
            });
        });

        // Link Input Handler
        function handleLinkInput(event) {
            const url = event.target.value.trim();
            const linkPreviewContainer = document.getElementById('linkPreviewContainer');
            const linkPreviewImage = document.getElementById('linkPreviewImage');

            if (!url) {
                linkPreviewContainer.classList.remove('show');
                currentImageData = null;
                return;
            }

            // Set current image data to URL
            currentImageData = url;

            // Show preview
            linkPreviewImage.src = url;
            linkPreviewContainer.classList.add('show');

            // Handle image load errors
            linkPreviewImage.onerror = () => {
                showNotificationMessage('‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i ·∫£nh t·ª´ URL n√†y');
                linkPreviewContainer.classList.remove('show');
                currentImageData = null;
            };
        }

        // Save Image Change
        function saveImageChange() {
            if (!currentEditingProductId) {
                showNotificationMessage('‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
                return;
            }

            const productKey = `product_${currentEditingProductId}`;
            const product = orderProducts[productKey];
            if (!product) {
                showNotificationMessage('‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
                return;
            }

            const newImageUrl = currentImageData || null;
            const timestamp = Date.now();

            // Update the image URL (can be null, base64, or URL)
            product.imageUrl = newImageUrl;
            product.lastRefreshed = timestamp;

            // If product has a template (is a variant), update all products with same template
            let updatedCount = 1;
            const updates = {};
            updates[`orderProducts/${productKey}/imageUrl`] = newImageUrl;
            updates[`orderProducts/${productKey}/lastRefreshed`] = timestamp;

            if (product.ProductTmplId) {
                const templateId = product.ProductTmplId;

                // Find and update all products with the same ProductTmplId (including main product and all variants)
                Object.entries(orderProducts).forEach(([key, p]) => {
                    if (p.ProductTmplId === templateId && p.Id !== product.Id) {
                        p.imageUrl = newImageUrl;
                        p.lastRefreshed = timestamp;
                        updates[`orderProducts/${key}/imageUrl`] = newImageUrl;
                        updates[`orderProducts/${key}/lastRefreshed`] = timestamp;
                        updatedCount++;
                    }
                });

                console.log(`üñºÔ∏è Updated image for ${updatedCount} products with template ID ${templateId}`);
            }

            // Sync to Firebase
            if (!isSyncingFromFirebase) {
                database.ref().update(updates).then(() => {
                    console.log(`‚úÖ Updated image for product ${product.NameGet}`);
                    if (updatedCount > 1) {
                        showNotificationMessage(`üñºÔ∏è ƒê√£ c·∫≠p nh·∫≠t h√¨nh ·∫£nh cho ${updatedCount} s·∫£n ph·∫©m c√πng nh√≥m`);
                    } else {
                        showNotificationMessage('üñºÔ∏è ƒê√£ c·∫≠p nh·∫≠t h√¨nh ·∫£nh s·∫£n ph·∫©m');
                    }
                    closeImageModal();
                }).catch(error => {
                    console.error('‚ùå L·ªói sync products l√™n Firebase:', error);
                    showNotificationMessage('‚ö†Ô∏è L·ªói ƒë·ªìng b·ªô Firebase: ' + error.message);
                });
            }

            // Update UI
            updateProductListPreview();
            updateHiddenProductListPreview();
        }

        function performListSearch(keyword) {
            listSearchKeyword = keyword.trim();

            if (!listSearchKeyword) {
                filteredProductsInList = [];
                updateProductListPreview();
                return;
            }

            const searchLower = listSearchKeyword.toLowerCase();
            const searchNoSign = removeVietnameseTones(listSearchKeyword);

            // Filter visible products that match
            const visibleProducts = Object.values(orderProducts).filter(p => !p.isHidden);
            const matchedProducts = visibleProducts.filter(product => {
                // Match in product name (no Vietnamese tones)
                const nameNoSign = removeVietnameseTones(product.NameGet || '');
                const matchName = nameNoSign.includes(searchNoSign);

                // Match in original name (lowercase, for special chars like [Q5X1])
                const matchNameOriginal = product.NameGet && product.NameGet.toLowerCase().includes(searchLower);

                return matchName || matchNameOriginal;
            });

            // Sort by priority: match in [] first
            matchedProducts.sort((a, b) => {
                const extractBracket = (name) => {
                    const match = name?.match(/\[([^\]]+)\]/);
                    return match ? match[1].toLowerCase().trim() : '';
                };

                const aBracket = extractBracket(a.NameGet);
                const bBracket = extractBracket(b.NameGet);

                const aMatchInBracket = aBracket && aBracket.includes(searchLower);
                const bMatchInBracket = bBracket && bBracket.includes(searchLower);

                if (aMatchInBracket && !bMatchInBracket) return -1;
                if (!aMatchInBracket && bMatchInBracket) return 1;

                if (aMatchInBracket && bMatchInBracket) {
                    const aExactMatch = aBracket === searchLower;
                    const bExactMatch = bBracket === searchLower;
                    if (aExactMatch && !bExactMatch) return -1;
                    if (!aExactMatch && bExactMatch) return 1;

                    if (aBracket.length !== bBracket.length) {
                        return aBracket.length - bBracket.length;
                    }

                    return aBracket.localeCompare(bBracket);
                }

                return a.NameGet.localeCompare(b.NameGet);
            });

            filteredProductsInList = matchedProducts;
            updateProductListPreview();
        }

        function clearListSearch() {
            listSearchKeyword = '';
            filteredProductsInList = [];
            document.getElementById('listSearchInput').value = '';
            document.getElementById('listSearchClear').classList.remove('show');
            updateProductListPreview();
        }

        function performHiddenListSearch(keyword) {
            hiddenListSearchKeyword = keyword.trim();

            if (!hiddenListSearchKeyword) {
                filteredHiddenProducts = [];
                updateHiddenProductListPreview();
                return;
            }

            const searchLower = hiddenListSearchKeyword.toLowerCase();
            const searchNoSign = removeVietnameseTones(hiddenListSearchKeyword);

            // Filter hidden products that match
            const hiddenProducts = Object.values(orderProducts).filter(p => p.isHidden);
            const matchedProducts = hiddenProducts.filter(product => {
                // Match in product name (no Vietnamese tones)
                const nameNoSign = removeVietnameseTones(product.NameGet || '');
                const matchName = nameNoSign.includes(searchNoSign);

                // Match in original name (lowercase, for special chars like [Q5X1])
                const matchNameOriginal = product.NameGet && product.NameGet.toLowerCase().includes(searchLower);

                return matchName || matchNameOriginal;
            });

            // Sort by priority: match in [] first
            matchedProducts.sort((a, b) => {
                const extractBracket = (name) => {
                    const match = name?.match(/\[([^\]]+)\]/);
                    return match ? match[1].toLowerCase().trim() : '';
                };

                const aBracket = extractBracket(a.NameGet);
                const bBracket = extractBracket(b.NameGet);

                const aMatchInBracket = aBracket && aBracket.includes(searchLower);
                const bMatchInBracket = bBracket && bBracket.includes(searchLower);

                if (aMatchInBracket && !bMatchInBracket) return -1;
                if (!aMatchInBracket && bMatchInBracket) return 1;

                if (aMatchInBracket && bMatchInBracket) {
                    const aExactMatch = aBracket === searchLower;
                    const bExactMatch = bBracket === searchLower;
                    if (aExactMatch && !bExactMatch) return -1;
                    if (!aExactMatch && bExactMatch) return 1;

                    if (aBracket.length !== bBracket.length) {
                        return aBracket.length - bBracket.length;
                    }

                    return aBracket.localeCompare(bBracket);
                }

                return a.NameGet.localeCompare(b.NameGet);
            });

            filteredHiddenProducts = matchedProducts;
            updateHiddenProductListPreview();
        }

        function clearHiddenListSearch() {
            hiddenListSearchKeyword = '';
            filteredHiddenProducts = [];
            document.getElementById('hiddenListSearchInput').value = '';
            document.getElementById('hiddenListSearchClear').classList.remove('show');
            updateHiddenProductListPreview();
        }

        function showNotificationMessage(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // Barcode scanner detection
        let lastKeyTime = Date.now();
        let isBarcodeScan = false;
        let inputBuffer = '';
        let barcodeTimeout = null;

        document.getElementById('productSearch').addEventListener('input', (e) => {
            const searchText = e.target.value.trim();
            const currentTime = Date.now();
            const timeDiff = currentTime - lastKeyTime;
            lastKeyTime = currentTime;

            // Detect barcode scanner (very fast typing, < 50ms between keys)
            if (timeDiff < 50 && searchText.length > 2) {
                isBarcodeScan = true;
            } else if (timeDiff > 100) {
                isBarcodeScan = false;
            }

            // Clear previous timeout
            if (barcodeTimeout) {
                clearTimeout(barcodeTimeout);
            }

            // If barcode scan detected, wait for completion then auto-search
            if (isBarcodeScan) {
                barcodeTimeout = setTimeout(() => {
                    if (productsData.length === 0) {
                        loadExcelData().then(() => {
                            autoSearchExactMatch(searchText);
                        });
                    } else {
                        autoSearchExactMatch(searchText);
                    }
                    isBarcodeScan = false;
                }, 100);
            } else {
                // Manual typing - show suggestions
                if (searchText.length >= 2) {
                    if (productsData.length === 0) {
                        loadExcelData().then(() => {
                            const results = searchProducts(searchText);
                            displaySuggestions(results);
                        });
                    } else {
                        const results = searchProducts(searchText);
                        displaySuggestions(results);
                    }
                } else {
                    document.getElementById('suggestions').classList.remove('show');
                }
            }
        });

        function autoSearchExactMatch(searchText) {
            // Try exact match first
            const exactMatch = productsData.find(p =>
                p.code && p.code.toLowerCase() === searchText.toLowerCase()
            );

            if (exactMatch) {
                loadProductDetails(exactMatch.id);
                document.getElementById('suggestions').classList.remove('show');
                document.getElementById('productSearch').value = '';
            } else {
                // If no exact match, try fuzzy search
                const results = searchProducts(searchText);
                if (results.length === 1) {
                    loadProductDetails(results[0].id);
                    document.getElementById('suggestions').classList.remove('show');
                    document.getElementById('productSearch').value = '';
                } else if (results.length > 1) {
                    // Multiple results, show suggestions
                    displaySuggestions(results);
                }
            }
        }

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-wrapper')) {
                document.getElementById('suggestions').classList.remove('show');
            }
        });

        document.getElementById('productSearch').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const searchText = e.target.value.trim();
                if (searchText) {
                    const exactMatch = productsData.find(p =>
                        p.code && p.code.toLowerCase() === searchText.toLowerCase()
                    );

                    if (exactMatch) {
                        loadProductDetails(exactMatch.id);
                        document.getElementById('suggestions').classList.remove('show');
                    } else {
                        const results = searchProducts(searchText);
                        if (results.length === 1) {
                            loadProductDetails(results[0].id);
                            document.getElementById('suggestions').classList.remove('show');
                        }
                    }
                }
            }
        });

        // Auto-focus search input for barcode scanner
        document.addEventListener('keydown', (e) => {
            const productSearch = document.getElementById('productSearch');
            const activeElement = document.activeElement;

            // Ignore if already focused on an input/textarea or if modifier keys are pressed
            if (activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                e.ctrlKey ||
                e.altKey ||
                e.metaKey) {
                return;
            }

            // Ignore special keys (arrows, function keys, etc.)
            if (e.key.length > 1 && e.key !== 'Enter' && e.key !== 'Backspace') {
                return;
            }

            // Auto-focus the search input
            productSearch.focus();
        });

        async function loadSettings() {
            try {
                const snapshot = await database.ref('orderDisplaySettings').once('value');
                const settings = snapshot.val();
                if (settings) {
                    // Frame Display settings
                    document.getElementById('settingNameLineClamp').value = settings.nameLineClamp || 1;

                    // Layout settings
                    document.getElementById('settingColumns').value = settings.columns || 4;
                    document.getElementById('settingRows').value = settings.rows || 2;
                    document.getElementById('settingGap').value = settings.gap || 15;
                    document.getElementById('settingItemHeight').value = settings.itemHeight || 500;

                    // Image settings
                    document.getElementById('settingImageBorderRadius').value = settings.imageBorderRadius || 8;
                    document.getElementById('settingImageBorderWidth').value = settings.imageBorderWidth || 2;
                    document.getElementById('settingImageMarginBottom').value = settings.imageMarginBottom || 4;

                    // Name settings
                    document.getElementById('settingNameFontSize').value = settings.nameFontSize || 13;
                    document.getElementById('settingNameFontWeight').value = settings.nameFontWeight || 700;
                    document.getElementById('settingNameMargin').value = settings.nameMargin || 3;
                    document.getElementById('settingNameLineHeight').value = settings.nameLineHeight || 1.2;

                    // Stats settings
                    document.getElementById('settingStatsValueSize').value = settings.statsValueSize || 16;
                    document.getElementById('settingStatsLabelSize').value = settings.statsLabelSize || 9;
                    document.getElementById('settingStatsPadding').value = settings.statsPadding || 3;
                    document.getElementById('settingStatsGap').value = settings.statsGap || 4;
                    document.getElementById('settingStatsBorderRadius').value = settings.statsBorderRadius || 6;
                    document.getElementById('settingStatsMarginTop').value = settings.statsMarginTop || 4;

                    // Load autoAddVariants setting
                    autoAddVariants = settings.autoAddVariants !== undefined ? settings.autoAddVariants : true;
                    document.getElementById('toggleAutoVariants').checked = autoAddVariants;
                }

                // Load Hidden Products Display Settings
                const hiddenSnapshot = await database.ref('hiddenProductsDisplaySettings').once('value');
                const hiddenSettings = hiddenSnapshot.val();
                if (hiddenSettings) {
                    document.getElementById('settingHiddenColumns').value = hiddenSettings.columns || 4;
                    document.getElementById('settingHiddenRows').value = hiddenSettings.rows || 2;
                    document.getElementById('settingHiddenGap').value = hiddenSettings.gap || 15;
                }
            } catch (error) {
                console.error('‚ùå Error loading settings from Firebase:', error);
            }
        }

        function applySettings() {
            // Frame Display settings
            const nameLineClamp = parseInt(document.getElementById('settingNameLineClamp').value) || 1;

            // Layout settings
            const columns = parseInt(document.getElementById('settingColumns').value) || 4;
            const rows = parseInt(document.getElementById('settingRows').value) || 2;
            const gap = parseInt(document.getElementById('settingGap').value) || 15;
            const itemHeight = parseInt(document.getElementById('settingItemHeight').value) || 500;

            // Image settings
            const imageBorderRadius = parseInt(document.getElementById('settingImageBorderRadius').value) || 8;
            const imageBorderWidth = parseInt(document.getElementById('settingImageBorderWidth').value) || 2;
            const imageMarginBottom = parseInt(document.getElementById('settingImageMarginBottom').value) || 4;

            // Name settings
            const nameFontSize = parseInt(document.getElementById('settingNameFontSize').value) || 13;
            const nameFontWeight = parseInt(document.getElementById('settingNameFontWeight').value) || 700;
            const nameMargin = parseInt(document.getElementById('settingNameMargin').value) || 3;
            const nameLineHeight = parseFloat(document.getElementById('settingNameLineHeight').value) || 1.2;

            // Stats settings
            const statsValueSize = parseInt(document.getElementById('settingStatsValueSize').value) || 16;
            const statsLabelSize = parseInt(document.getElementById('settingStatsLabelSize').value) || 9;
            const statsPadding = parseInt(document.getElementById('settingStatsPadding').value) || 3;
            const statsGap = parseInt(document.getElementById('settingStatsGap').value) || 4;
            const statsBorderRadius = parseInt(document.getElementById('settingStatsBorderRadius').value) || 6;
            const statsMarginTop = parseInt(document.getElementById('settingStatsMarginTop').value) || 4;

            const settings = {
                // Frame Display
                nameLineClamp: nameLineClamp,

                // Layout
                columns: columns,
                rows: rows,
                gap: gap,
                itemHeight: itemHeight,
                itemsPerPage: columns * rows,

                // Image
                imageBorderRadius: imageBorderRadius,
                imageBorderWidth: imageBorderWidth,
                imageMarginBottom: imageMarginBottom,

                // Name
                nameFontSize: nameFontSize,
                nameFontWeight: nameFontWeight,
                nameMargin: nameMargin,
                nameLineHeight: nameLineHeight,

                // Stats
                statsValueSize: statsValueSize,
                statsLabelSize: statsLabelSize,
                statsPadding: statsPadding,
                statsGap: statsGap,
                statsBorderRadius: statsBorderRadius,
                statsMarginTop: statsMarginTop,

                // Other
                autoAddVariants: autoAddVariants
            };

            if (!isSyncingFromFirebase) {
                database.ref('orderDisplaySettings').set(settings).catch(error => {
                    console.error('‚ùå L·ªói sync settings l√™n Firebase:', error);
                });
            }

            if (window.settingsChannel) {
                window.settingsChannel.postMessage({ type: 'settingsChanged', settings: settings });
            }

            showNotificationMessage('üíæ ƒê√£ l∆∞u c√†i ƒë·∫∑t th√†nh c√¥ng!');
        }

        function toggleAutoVariants() {
            autoAddVariants = document.getElementById('toggleAutoVariants').checked;
            
            // Auto save when toggle changes
            const settings = {
                columns: parseInt(document.getElementById('settingColumns').value) || 4,
                rows: parseInt(document.getElementById('settingRows').value) || 2,
                gap: parseInt(document.getElementById('settingGap').value) || 15,
                itemHeight: parseInt(document.getElementById('settingItemHeight').value) || 500,
                nameMargin: parseInt(document.getElementById('settingNameMargin').value) || 3,
                itemsPerPage: (parseInt(document.getElementById('settingColumns').value) || 4) * (parseInt(document.getElementById('settingRows').value) || 2),
                autoAddVariants: autoAddVariants
            };

            if (!isSyncingFromFirebase) {
                database.ref('orderDisplaySettings').set(settings).catch(error => {
                    console.error('‚ùå L·ªói sync settings l√™n Firebase:', error);
                });
            }

            const status = autoAddVariants ? 'B·∫¨T' : 'T·∫ÆT';
            showNotificationMessage(`üîÑ ƒê√£ ${status} ch·∫ø ƒë·ªô t·ª± ƒë·ªông th√™m t·∫•t c·∫£ bi·∫øn th·ªÉ`);
        }

        window.settingsChannel = new BroadcastChannel('order-settings');

        function setupFirebaseListeners() {
            // Setup listeners for displaySettings
            database.ref('orderDisplaySettings').on('value', (snapshot) => {
                const settings = snapshot.val();
                if (settings && !isSyncingFromFirebase) {
                    isSyncingFromFirebase = true;
                    console.log('üî• Settings synced from Firebase');

                    // Update autoAddVariants from Firebase
                    if (settings.autoAddVariants !== undefined) {
                        autoAddVariants = settings.autoAddVariants;
                        document.getElementById('toggleAutoVariants').checked = autoAddVariants;
                    }

                    if (window.settingsChannel) {
                        window.settingsChannel.postMessage({ type: 'settingsChanged', settings: settings });
                    }

                    setTimeout(() => { isSyncingFromFirebase = false; }, 100);
                }
            });

            // Setup child listeners for products (realtime sync)
            setupFirebaseChildListeners(database, orderProducts, {
                onProductAdded: (product) => {
                    if (!isSyncingFromFirebase) {
                        console.log('üî• Product added from Firebase:', product.NameGet);
                        updateProductListPreview();
                    }
                },
                onProductChanged: (product) => {
                    if (!isSyncingFromFirebase) {
                        console.log('üî• Product updated from Firebase:', product.NameGet);
                        updateProductListPreview();
                    }
                },
                onProductRemoved: (product) => {
                    if (!isSyncingFromFirebase) {
                        console.log('üî• Product removed from Firebase:', product.NameGet);
                        updateProductListPreview();
                    }
                },
                onInitialLoadComplete: () => {
                    console.log('‚úÖ Firebase listeners setup complete');
                }
            });
        }

        async function loadInitialData() {
            try {
                orderProducts = await loadAllProductsFromFirebase(database);
                console.log('üî• Loaded from Firebase:', Object.keys(orderProducts).length, 'products');

                updateProductListPreview();
            } catch (error) {
                console.error('‚ùå Error loading from Firebase:', error);
                orderProducts = {};
            }
        }

        window.addEventListener('load', async () => {
            checkSyncMode();

            try {
                await getValidToken();
                await loadExcelData();

                // Load initial data from Firebase FIRST
                await loadInitialData();

                // THEN setup Firebase listeners for realtime sync
                setupFirebaseListeners();

                // Cleanup products older than 7 days
                cleanupOldProductsLocal();

                // Always update preview to ensure correct visibility
                updateProductListPreview();

                loadSettings();

                // Load cart history
                refreshCartHistory();

                // Initialize cart history collapse state
                initCartHistoryState();

                // Setup list search event listener
                const listSearchInput = document.getElementById('listSearchInput');
                const listSearchClear = document.getElementById('listSearchClear');

                if (listSearchInput) {
                    listSearchInput.addEventListener('input', (e) => {
                        const value = e.target.value;

                        // Show/hide clear button
                        if (value) {
                            listSearchClear.classList.add('show');
                        } else {
                            listSearchClear.classList.remove('show');
                        }

                        // Perform search
                        performListSearch(value);
                    });

                    // Handle Escape key to clear search
                    listSearchInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            clearListSearch();
                        }
                    });
                }

                // Setup hidden list search event listener
                const hiddenListSearchInput = document.getElementById('hiddenListSearchInput');
                const hiddenListSearchClear = document.getElementById('hiddenListSearchClear');

                if (hiddenListSearchInput) {
                    hiddenListSearchInput.addEventListener('input', (e) => {
                        const value = e.target.value;

                        // Show/hide clear button
                        if (value) {
                            hiddenListSearchClear.classList.add('show');
                        } else {
                            hiddenListSearchClear.classList.remove('show');
                        }

                        // Perform search
                        performHiddenListSearch(value);
                    });

                    // Handle Escape key to clear search
                    hiddenListSearchInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            clearHiddenListSearch();
                        }
                    });
                }
            } catch (error) {
                console.error('L·ªói kh·ªüi t·∫°o:', error);
                alert('Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn h·ªá th·ªëng. Vui l√≤ng th·ª≠ l·∫°i sau.');
            }
        });

        window.addEventListener('hashchange', () => {
            checkSyncMode();
        });

        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        function toggleSettingsSidebar() {
            const sidebar = document.getElementById('settingsSidebar');
            const overlay = document.getElementById('settingsSidebarOverlay');

            if (sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
                overlay.classList.remove('show');
                document.body.style.overflow = '';
            } else {
                sidebar.classList.add('open');
                overlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            }
        }

        function toggleHiddenProductsSettings() {
            const sidebar = document.getElementById('hiddenSettingsSidebar');
            const overlay = document.getElementById('hiddenSettingsSidebarOverlay');

            if (sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
                overlay.classList.remove('show');
                document.body.style.overflow = '';
            } else {
                sidebar.classList.add('open');
                overlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            }
        }

        function openHiddenProductsSettings() {
            toggleHiddenProductsSettings();
        }

        function applyHiddenProductsSettings() {
            const hiddenColumns = parseInt(document.getElementById('settingHiddenColumns').value) || 4;
            const hiddenRows = parseInt(document.getElementById('settingHiddenRows').value) || 2;
            const hiddenGap = parseInt(document.getElementById('settingHiddenGap').value) || 15;

            const hiddenSettings = {
                columns: hiddenColumns,
                rows: hiddenRows,
                gap: hiddenGap,
                itemsPerPage: hiddenColumns * hiddenRows
            };

            if (!isSyncingFromFirebase) {
                database.ref('hiddenProductsDisplaySettings').set(hiddenSettings).catch(error => {
                    console.error('‚ùå L·ªói sync hidden products settings l√™n Firebase:', error);
                });
            }

            showNotificationMessage('üíæ ƒê√£ l∆∞u c√†i ƒë·∫∑t Danh S√°ch ·∫®n th√†nh c√¥ng!');
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const sidebar = document.getElementById('settingsSidebar');
                const hiddenSidebar = document.getElementById('hiddenSettingsSidebar');

                if (sidebar.classList.contains('open')) {
                    toggleSettingsSidebar();
                }
                if (hiddenSidebar && hiddenSidebar.classList.contains('open')) {
                    toggleHiddenProductsSettings();
                }
            }
        });
    </script>

    <!-- Settings Sidebar -->
    <div class="settings-sidebar-overlay" id="settingsSidebarOverlay" onclick="toggleSettingsSidebar()"></div>
    <div class="settings-sidebar" id="settingsSidebar">
        <div class="settings-sidebar-header">
            <h2>‚öôÔ∏è C√†i ƒë·∫∑t Hi·ªÉn th·ªã</h2>
            <button class="btn-close-sidebar" onclick="toggleSettingsSidebar()">√ó</button>
        </div>
        <div class="settings-sidebar-content">
            <!-- Toggle Auto Add Variants -->
            <div class="toggle-container">
                <div class="toggle-label">
                    <span class="toggle-label-text">üîÑ T·ª± ƒë·ªông th√™m t·∫•t c·∫£ bi·∫øn th·ªÉ</span>
                    <span class="toggle-description">Khi b·∫≠t, s·∫Ω t·ª± ƒë·ªông th√™m t·∫•t c·∫£ m√†u/size c·ªßa s·∫£n ph·∫©m</span>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="toggleAutoVariants" checked onchange="toggleAutoVariants()">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <!-- Clear All Products Button -->
            <div style="margin-bottom: 20px;">
                <button class="btn-apply-settings" onclick="clearAllProductsLocal(); toggleSettingsSidebar();" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);">
                    üóëÔ∏è X√≥a T·∫•t C·∫£ S·∫£n Ph·∫©m
                </button>
                <div class="setting-description" style="text-align: center; margin-top: 10px;">X√≥a to√†n b·ªô danh s√°ch s·∫£n ph·∫©m ƒë√£ th√™m</div>
            </div>

            <!-- Save Cart & Refresh Button -->
            <div style="margin-bottom: 20px;">
                <button class="btn-apply-settings" onclick="saveCartAndRefresh(); toggleSettingsSidebar();" style="background: linear-gradient(135deg, #28a745 0%, #218838 100%);">
                    üíæ L∆∞u Gi·ªè H√†ng v√† L√†m m·ªõi
                </button>
                <div class="setting-description" style="text-align: center; margin-top: 10px;">L∆∞u snapshot gi·ªè h√†ng hi·ªán t·∫°i v√† x√≥a s·∫°ch ƒë·ªÉ l√†m gi·ªè m·ªõi</div>
            </div>

            <!-- Cart History Section -->
            <div class="cart-history-section" style="margin-bottom: 20px;">
                <div class="cart-history-header" onclick="toggleCartHistory()" style="cursor: pointer;">
                    <h3 style="color: #667eea; margin-bottom: 0; font-size: 16px; border-bottom: 2px solid #667eea; padding-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                        <span style="display: flex; align-items: center; gap: 8px;">
                            <span id="cartHistoryToggleIcon" class="toggle-icon">‚ñ∂</span>
                            üìö L·ªãch S·ª≠ Gi·ªè H√†ng
                        </span>
                        <button class="btn-refresh-history" onclick="event.stopPropagation(); refreshCartHistory()" title="L√†m m·ªõi" style="background: none; border: none; font-size: 18px; cursor: pointer; padding: 5px;">üîÑ</button>
                    </h3>
                </div>

                <!-- Date Filter -->
                <div class="date-filter-container" style="padding: 10px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; display: none;" id="dateFilterContainer">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <label style="font-weight: 500; color: #495057;">üìÖ L·ªçc theo ng√†y:</label>
                        <input type="date" id="snapshotDateFilter" onchange="filterCartHistoryByDate()" style="padding: 6px 10px; border: 1px solid #ced4da; border-radius: 4px; flex: 1;">
                        <button onclick="clearDateFilter()" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">‚úñÔ∏è X√≥a l·ªçc</button>
                    </div>
                </div>

                <div id="cartHistoryList" class="cart-history-list collapsed">
                    <div class="no-history">ƒêang t·∫£i...</div>
                </div>
            </div>

            <!-- Logout Button -->
            <div style="margin-bottom: 20px;">
                <button class="btn-apply-settings" onclick="logoutUser();" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);">
                    üö™ ƒêƒÉng Xu·∫•t
                </button>
                <div class="setting-description" style="text-align: center; margin-top: 10px;">X√≥a to√†n b·ªô th√¥ng tin x√°c th·ª±c v√† quay v·ªÅ trang ch√≠nh</div>
            </div>

            <!-- Frame Display Settings -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #28a745; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #28a745; padding-bottom: 8px;">üñºÔ∏è C√†i ƒë·∫∑t Khung hi·ªÉn th·ªã</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">üìù S·ªë d√≤ng t√™n s·∫£n ph·∫©m</label>
                        <input type="number" class="setting-input" id="settingNameLineClamp" value="1" min="1" max="4">
                        <div class="setting-description">S·ªë d√≤ng hi·ªÉn th·ªã t√™n s·∫£n ph·∫©m (1-4 d√≤ng)</div>
                    </div>
                </div>
                <div class="setting-description" style="margin-top: 10px; padding: 10px; background: rgba(40, 167, 69, 0.1); border-radius: 8px;">
                    ‚ÑπÔ∏è T·ª∑ l·ªá khung: H√¨nh ·∫£nh 40%, T√™n 10%, Stats 50%
                </div>
            </div>

            <!-- Layout Settings -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #667eea; padding-bottom: 8px;">üìê C√†i ƒë·∫∑t B·ªë c·ª•c</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">üìä S·ªë C·ªôt</label>
                        <input type="number" class="setting-input" id="settingColumns" value="4" min="1" max="8">
                        <div class="setting-description">S·ªë c·ªôt hi·ªÉn th·ªã tr√™n m·ªói trang</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìã S·ªë H√†ng</label>
                        <input type="number" class="setting-input" id="settingRows" value="2" min="1" max="6">
                        <div class="setting-description">S·ªë h√†ng hi·ªÉn th·ªã tr√™n m·ªói trang</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìè Kho·∫£ng C√°ch (px)</label>
                        <input type="number" class="setting-input" id="settingGap" value="15" min="5" max="50">
                        <div class="setting-description">Kho·∫£ng c√°ch gi·ªØa c√°c s·∫£n ph·∫©m</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìê Chi·ªÅu Cao C·ªôt (px)</label>
                        <input type="number" class="setting-input" id="settingItemHeight" value="500" min="200" max="1000">
                        <div class="setting-description">Chi·ªÅu cao c·ªßa m·ªói √¥ s·∫£n ph·∫©m</div>
                    </div>
                </div>
            </div>

            <!-- Image Settings -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #667eea; padding-bottom: 8px;">üñºÔ∏è C√†i ƒë·∫∑t H√¨nh ·∫£nh</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">üî≤ Border Radius (px)</label>
                        <input type="number" class="setting-input" id="settingImageBorderRadius" value="8" min="0" max="30">
                        <div class="setting-description">Bo g√≥c h√¨nh ·∫£nh</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üì¶ Border Width (px)</label>
                        <input type="number" class="setting-input" id="settingImageBorderWidth" value="2" min="0" max="10">
                        <div class="setting-description">ƒê·ªô d√†y vi·ªÅn h√¨nh ·∫£nh</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">‚¨áÔ∏è Margin Bottom (px)</label>
                        <input type="number" class="setting-input" id="settingImageMarginBottom" value="4" min="0" max="20">
                        <div class="setting-description">Kho·∫£ng c√°ch d∆∞·ªõi h√¨nh ·∫£nh</div>
                    </div>
                </div>
            </div>

            <!-- Name Settings -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #667eea; padding-bottom: 8px;">üìù C√†i ƒë·∫∑t T√™n s·∫£n ph·∫©m</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">üî§ Font Size (px)</label>
                        <input type="number" class="setting-input" id="settingNameFontSize" value="13" min="8" max="24">
                        <div class="setting-description">C·ª° ch·ªØ t√™n s·∫£n ph·∫©m</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üí™ Font Weight</label>
                        <input type="number" class="setting-input" id="settingNameFontWeight" value="700" min="400" max="900" step="100">
                        <div class="setting-description">ƒê·ªô ƒë·∫≠m ch·ªØ (400-900)</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">‚¨áÔ∏è Margin Bottom (px)</label>
                        <input type="number" class="setting-input" id="settingNameMargin" value="3" min="0" max="20">
                        <div class="setting-description">Kho·∫£ng c√°ch d∆∞·ªõi t√™n</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìè Line Height</label>
                        <input type="number" class="setting-input" id="settingNameLineHeight" value="1.2" min="1" max="2" step="0.1">
                        <div class="setting-description">Kho·∫£ng c√°ch d√≤ng (1.0-2.0)</div>
                    </div>
                </div>
            </div>

            <!-- Stats Settings -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #667eea; padding-bottom: 8px;">üìä C√†i ƒë·∫∑t Th·ªëng k√™ (Stats)</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">üî¢ Stats Value Size (px)</label>
                        <input type="number" class="setting-input" id="settingStatsValueSize" value="16" min="10" max="32">
                        <div class="setting-description">C·ª° ch·ªØ s·ªë li·ªáu</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üè∑Ô∏è Stats Label Size (px)</label>
                        <input type="number" class="setting-input" id="settingStatsLabelSize" value="9" min="6" max="16">
                        <div class="setting-description">C·ª° ch·ªØ nh√£n (T·ªïng, B√°n, C√≤n)</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üì¶ Stats Padding (px)</label>
                        <input type="number" class="setting-input" id="settingStatsPadding" value="3" min="0" max="15">
                        <div class="setting-description">Padding b√™n trong stats box</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìè Stats Gap (px)</label>
                        <input type="number" class="setting-input" id="settingStatsGap" value="4" min="0" max="15">
                        <div class="setting-description">Kho·∫£ng c√°ch gi·ªØa c√°c stats</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üî≤ Stats Border Radius (px)</label>
                        <input type="number" class="setting-input" id="settingStatsBorderRadius" value="6" min="0" max="20">
                        <div class="setting-description">Bo g√≥c stats box</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">‚¨ÜÔ∏è Stats Margin Top (px)</label>
                        <input type="number" class="setting-input" id="settingStatsMarginTop" value="4" min="0" max="20">
                        <div class="setting-description">Kho·∫£ng c√°ch tr√™n stats</div>
                    </div>
                </div>
            </div>

            <!-- Apply Button -->
            <div class="setting-item" style="grid-column: 1 / -1;">
                <button class="btn-apply-settings" onclick="applySettings(); toggleSettingsSidebar();">
                    üíæ L∆∞u T·∫•t C·∫£ C√†i ƒê·∫∑t
                </button>
                <div class="setting-description" style="text-align: center; margin-top: 10px;">√Åp d·ª•ng cho trang danh s√°ch v√† l∆∞u v√†o Firebase</div>
            </div>
        </div>
    </div>

    <!-- Hidden Products Settings Sidebar -->
    <div class="settings-sidebar-overlay" id="hiddenSettingsSidebarOverlay" onclick="toggleHiddenProductsSettings()"></div>
    <div class="settings-sidebar" id="hiddenSettingsSidebar">
        <div class="settings-sidebar-header">
            <h2>‚öôÔ∏è C√†i ƒë·∫∑t Danh S√°ch ·∫®n</h2>
            <button class="btn-close-sidebar" onclick="toggleHiddenProductsSettings()">√ó</button>
        </div>
        <div class="settings-sidebar-content">
            <!-- Hidden Products Layout Settings -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #ff9800; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #ff9800; padding-bottom: 8px;">üìê C√†i ƒë·∫∑t B·ªë c·ª•c</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">üìä S·ªë C·ªôt</label>
                        <input type="number" class="setting-input" id="settingHiddenColumns" value="4" min="1" max="8">
                        <div class="setting-description">S·ªë c·ªôt hi·ªÉn th·ªã trong trang Danh S√°ch ·∫®n</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìã S·ªë H√†ng</label>
                        <input type="number" class="setting-input" id="settingHiddenRows" value="2" min="1" max="6">
                        <div class="setting-description">S·ªë h√†ng hi·ªÉn th·ªã trong trang Danh S√°ch ·∫®n</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">üìè Kho·∫£ng C√°ch (px)</label>
                        <input type="number" class="setting-input" id="settingHiddenGap" value="15" min="5" max="50">
                        <div class="setting-description">Kho·∫£ng c√°ch gi·ªØa c√°c s·∫£n ph·∫©m</div>
                    </div>
                </div>
            </div>

            <!-- Save Button -->
            <div class="setting-item" style="grid-column: 1 / -1;">
                <button class="btn-apply-settings" onclick="applyHiddenProductsSettings(); toggleHiddenProductsSettings();" style="background: linear-gradient(135deg, #ff9800 0%, #ff5722 100%); border-color: #ff9800;">
                    üíæ L∆∞u C√†i ƒê·∫∑t
                </button>
                <div class="setting-description" style="text-align: center; margin-top: 10px;">√Åp d·ª•ng cho trang Danh S√°ch ·∫®n v√† l∆∞u v√†o Firebase</div>
            </div>
        </div>
    </div>

    <!-- Restore Confirmation Modal -->
    <div id="restoreConfirmModal" class="modal-overlay" style="display: none;">
        <div class="modal-container modal-small">
            <div class="modal-header-custom">
                <h3>‚ö†Ô∏è Kh√¥i ph·ª•c gi·ªè h√†ng</h3>
            </div>

            <div class="modal-body-custom">
                <div class="warning-message">
                    Gi·ªè h√†ng hi·ªán t·∫°i c√≥ <strong id="currentCartCount">0</strong> s·∫£n ph·∫©m
                </div>

                <div class="auto-save-option">
                    <label class="checkbox-label">
                        <input type="checkbox" id="autoSaveBeforeRestore" checked onchange="toggleAutoSaveInput()">
                        <span>‚úÖ T·ª± ƒë·ªông l∆∞u gi·ªè h√†ng hi·ªán t·∫°i tr∆∞·ªõc khi kh√¥i ph·ª•c</span>
                    </label>
                </div>

                <div id="autoSaveNameInput" class="auto-save-name-input">
                    <label>T√™n gi·ªè h√†ng s·∫Ω l∆∞u:</label>
                    <input type="text"
                           id="autoSaveName"
                           placeholder="Gi·ªè h√†ng tr∆∞·ªõc khi kh√¥i ph·ª•c..."
                           value="">
                </div>

                <div class="info-message">
                    ‚ÑπÔ∏è B·ªè tick n·∫øu b·∫°n kh√¥ng mu·ªën l∆∞u gi·ªè hi·ªán t·∫°i (d·ªØ li·ªáu s·∫Ω b·ªã m·∫•t)
                </div>
            </div>

            <div class="modal-footer-custom">
                <button onclick="confirmRestore()" class="btn-primary-custom">
                    ‚ôªÔ∏è Kh√¥i ph·ª•c
                </button>
                <button onclick="closeRestoreConfirmModal()" class="btn-secondary-custom">
                    H·ªßy
                </button>
            </div>
        </div>
    </div>

    <!-- Snapshot View Modal -->
    <div id="snapshotViewModal" class="modal-overlay" style="display: none;">
        <div class="modal-container modal-fullscreen">
            <div class="modal-header-custom">
                <h2 id="snapshotModalTitle">Chi ti·∫øt gi·ªè h√†ng</h2>
                <button onclick="closeSnapshotModal()" class="btn-close-modal">‚úñÔ∏è</button>
            </div>

            <div class="modal-body-custom">
                <!-- Snapshot Info -->
                <div id="snapshotModalInfo" class="snapshot-info-grid">
                    <!-- Dynamic content -->
                </div>

                <!-- Product Grid -->
                <div class="snapshot-products-grid" id="snapshotProductsGrid">
                    <!-- Dynamic content -->
                </div>
            </div>

            <div class="modal-footer-custom">
                <button onclick="restoreSnapshotFromModal()" class="btn-primary-custom">
                    ‚ôªÔ∏è Kh√¥i ph·ª•c gi·ªè h√†ng n√†y
                </button>
                <button onclick="closeSnapshotModal()" class="btn-secondary-custom">
                    ƒê√≥ng
                </button>
            </div>
        </div>
    </div>
</body>
</html>
