<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Product Encoding</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #2d2d2d;
            border-left: 3px solid #4caf50;
        }
        .success { color: #4caf50; }
        .error { color: #f44336; }
        .info { color: #2196f3; }
        pre {
            background: #1e1e1e;
            padding: 10px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>üß™ Test Product Encoding - NEW FORMAT</h1>
    <button onclick="runTests()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">Run Tests</button>
    <div id="results"></div>

    <script>
        // =====================================================
        // COPY C√ÅC H√ÄM T·ª™ tab-upload-tpos.js
        // =====================================================
        const ENCODE_KEY = 'live';
        const BASE_TIME = 1704067200000; // 2024-01-01 00:00:00 UTC

        function base64UrlEncode(str) {
            return btoa(String.fromCharCode(...new TextEncoder().encode(str)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        function base64UrlDecode(str) {
            const padding = '='.repeat((4 - str.length % 4) % 4);
            const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;
            const binary = atob(base64);
            return new TextDecoder().decode(
                Uint8Array.from(binary, c => c.charCodeAt(0))
            );
        }

        function shortChecksum(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash).toString(36).substring(0, 6);
        }

        function xorEncrypt(text, key) {
            const textBytes = new TextEncoder().encode(text);
            const keyBytes = new TextEncoder().encode(key);
            const encrypted = new Uint8Array(textBytes.length);
            for (let i = 0; i < textBytes.length; i++) {
                encrypted[i] = textBytes[i] ^ keyBytes[i % keyBytes.length];
            }
            return btoa(String.fromCharCode(...encrypted));
        }

        function xorDecrypt(encoded, key) {
            const encrypted = Uint8Array.from(atob(encoded), c => c.charCodeAt(0));
            const keyBytes = new TextEncoder().encode(key);
            const decrypted = new Uint8Array(encrypted.length);
            for (let i = 0; i < encrypted.length; i++) {
                decrypted[i] = encrypted[i] ^ keyBytes[i % keyBytes.length];
            }
            return new TextDecoder().decode(decrypted);
        }

        function encodeProductLine(orderId, productCode, quantity, price, timestamp = null) {
            const ts = timestamp || Date.now();
            const relativeTime = Math.floor((ts - BASE_TIME) / 1000);
            const data = `${orderId},${productCode},${quantity},${price},${relativeTime}`;
            const checksum = shortChecksum(data);
            const fullData = `${data},${checksum}`;
            const encrypted = xorEncrypt(fullData, ENCODE_KEY);
            return base64UrlEncode(encrypted);
        }

        function decodeProductLine(encoded, expectedOrderId = null) {
            try {
                const isNewFormat = encoded.includes('-') || encoded.includes('_') ||
                    (!encoded.includes('+') && !encoded.includes('/') && !encoded.includes('='));

                if (isNewFormat) {
                    try {
                        const decrypted = base64UrlDecode(encoded);
                        const fullData = xorDecrypt(decrypted, ENCODE_KEY);
                        const parts = fullData.split(',');
                        if (parts.length !== 6) throw new Error('Not new format');

                        const [orderId, productCode, quantity, price, relativeTime, checksum] = parts;
                        const data = `${orderId},${productCode},${quantity},${price},${relativeTime}`;

                        if (checksum !== shortChecksum(data)) {
                            console.warn('‚ö†Ô∏è Checksum mismatch');
                            return null;
                        }

                        if (expectedOrderId !== null && orderId !== expectedOrderId.toString()) {
                            console.warn(`‚ö†Ô∏è OrderId mismatch: encoded=${orderId}, expected=${expectedOrderId}`);
                            return null;
                        }

                        const timestamp = parseInt(relativeTime) * 1000 + BASE_TIME;
                        return {
                            orderId: parseInt(orderId),
                            productCode,
                            quantity: parseInt(quantity),
                            price: parseFloat(price),
                            timestamp
                        };
                    } catch (e) {
                        console.log('New format decode failed, trying old format...');
                    }
                }

                // Old format fallback
                const decoded = xorDecrypt(encoded, ENCODE_KEY);
                const parts = decoded.split('|');
                if (parts.length !== 3 && parts.length !== 4) return null;

                const result = {
                    productCode: parts[0],
                    quantity: parseInt(parts[1]),
                    price: parseFloat(parts[2])
                };

                if (parts.length === 4) {
                    result.timestamp = parseInt(parts[3]);
                }

                return result;
            } catch (error) {
                console.error('Decode error:', error);
                return null;
            }
        }

        // =====================================================
        // TEST FUNCTIONS
        // =====================================================
        function runTests() {
            const results = document.getElementById('results');
            results.innerHTML = '';

            const testOrderId = 12345;
            const testProducts = [
                { productCode: 'SP001', quantity: 5, price: 100000 },
                { productCode: 'SP002', quantity: 3, price: 150000 },
                { productCode: 'ABC-123', quantity: 10, price: 50000 }
            ];

            let html = '';

            // Test 1: Encoding
            html += `<div class="test-section">
                <h2>‚úÖ Test 1: Encoding</h2>
                <p class="info">Order ID: ${testOrderId}</p>
                <pre>`;

            const encoded = [];
            testProducts.forEach(p => {
                const enc = encodeProductLine(testOrderId, p.productCode, p.quantity, p.price);
                encoded.push(enc);
                const oldLength = 60; // Approximate old format length
                const savings = ((oldLength - enc.length) / oldLength * 100).toFixed(1);
                html += `${p.productCode} ‚Üí ${enc}\n`;
                html += `  Length: ${enc.length} chars (saved ~${savings}% vs Base64)\n`;
            });
            html += `</pre></div>`;

            // Test 2: Decoding with correct orderId
            html += `<div class="test-section">
                <h2>‚úÖ Test 2: Decoding (Correct Order ID)</h2>
                <pre>`;

            let allMatch = true;
            encoded.forEach((enc, i) => {
                const decoded = decodeProductLine(enc, testOrderId);
                const original = testProducts[i];
                const match = decoded &&
                    decoded.orderId === testOrderId &&
                    decoded.productCode === original.productCode &&
                    decoded.quantity === original.quantity &&
                    decoded.price === original.price;
                allMatch = allMatch && match;
                html += `${enc}\n`;
                html += `  ‚Üí ${JSON.stringify(decoded)}\n`;
                html += `  <span class="${match ? 'success' : 'error'}">${match ? '‚úÖ Match' : '‚ùå Mismatch'}</span>\n\n`;
            });
            html += `</pre>
                <p class="${allMatch ? 'success' : 'error'}">${allMatch ? '‚úÖ All tests passed!' : '‚ùå Some tests failed!'}</p>
            </div>`;

            // Test 3: Decoding with wrong orderId
            html += `<div class="test-section">
                <h2>üîí Test 3: Security - Wrong Order ID (Should Fail)</h2>
                <pre>`;

            const wrongOrderId = 99999;
            let allFailed = true;
            encoded.forEach((enc, i) => {
                const decoded = decodeProductLine(enc, wrongOrderId);
                const shouldBeNull = decoded === null;
                allFailed = allFailed && shouldBeNull;
                html += `Trying to decode with orderId=${wrongOrderId}:\n`;
                html += `  Result: ${decoded === null ? 'null (rejected)' : JSON.stringify(decoded)}\n`;
                html += `  <span class="${shouldBeNull ? 'success' : 'error'}">${shouldBeNull ? '‚úÖ Correctly rejected' : '‚ùå Should be rejected'}</span>\n\n`;
            });
            html += `</pre>
                <p class="${allFailed ? 'success' : 'error'}">${allFailed ? '‚úÖ Security test passed!' : '‚ùå Security test failed!'}</p>
            </div>`;

            // Test 4: Checksum verification
            html += `<div class="test-section">
                <h2>üîê Test 4: Checksum Integrity</h2>
                <pre>`;

            const testEnc = encodeProductLine(testOrderId, 'TEST', 1, 1000);
            html += `Original: ${testEnc}\n`;

            // Try to tamper (change one character)
            const tampered = testEnc.substring(0, 10) + (testEnc[10] === 'A' ? 'B' : 'A') + testEnc.substring(11);
            html += `Tampered: ${tampered}\n`;

            const decodedTampered = decodeProductLine(tampered, testOrderId);
            html += `Decode result: ${decodedTampered === null ? 'null (rejected)' : JSON.stringify(decodedTampered)}\n`;
            html += `<span class="${decodedTampered === null ? 'success' : 'error'}">${decodedTampered === null ? '‚úÖ Tampering detected!' : '‚ùå Tampering not detected!'}</span>`;
            html += `</pre></div>`;

            // Summary
            const allTestsPassed = allMatch && allFailed && (decodedTampered === null);
            html += `<div class="test-section">
                <h2 class="${allTestsPassed ? 'success' : 'error'}">
                    ${allTestsPassed ? 'üéâ ALL TESTS PASSED!' : '‚ö†Ô∏è SOME TESTS FAILED!'}
                </h2>
                <p>Format: Base64URL + Compact data + OrderId + Checksum</p>
                <p>Security: ‚úÖ OrderId verification, ‚úÖ Checksum integrity, ‚úÖ Tamper detection</p>
            </div>`;

            results.innerHTML = html;
        }
    </script>
</body>
</html>
