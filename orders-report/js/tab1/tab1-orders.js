/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                           TAB1-ORDERS.JS                                      â•‘
 * â•‘                   Order Management Module - Main Logic                        â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘                                                                              â•‘
 * â•‘  ğŸ“– Äá»ŒC FILE ARCHITECTURE.md TRÆ¯á»šC Äá»‚ HIá»‚U Cáº¤U TRÃšC Tá»”NG QUAN               â•‘
 * â•‘                                                                              â•‘
 * â•‘  ğŸ“ KHI THÃŠM HÃ€M Má»šI:                                                        â•‘
 * â•‘     1. ThÃªm vÃ o Ä‘Ãºng SECTION/REGION bÃªn dÆ°á»›i                                 â•‘
 * â•‘     2. Cáº­p nháº­t TABLE OF CONTENTS náº¿u lÃ  hÃ m quan trá»ng                      â•‘
 * â•‘     3. Cáº­p nháº­t ARCHITECTURE.md náº¿u thÃªm section má»›i                         â•‘
 * â•‘                                                                              â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘                         TABLE OF CONTENTS                                     â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 1]  GLOBAL VARIABLES .......................... search: #GLOBAL    â•‘
 * â•‘               - State: allData, filteredData, displayedData                  â•‘
 * â•‘               - formatTimeVN() - Format thá»i gian Viá»‡t Nam                   â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 2]  FIREBASE & REALTIME TAG SYNC .............. search: #FIREBASE  â•‘
 * â•‘               - emitTagUpdateToFirebase() - Gá»­i tag lÃªn Firebase             â•‘
 * â•‘               - setupTagRealtimeListeners() - Láº¯ng nghe tag realtime         â•‘
 * â•‘               - handleRealtimeTagUpdate() - Xá»­ lÃ½ cáº­p nháº­t tag               â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 3]  INITIALIZATION ............................ search: #INIT      â•‘
 * â•‘               - DOMContentLoaded event                                        â•‘
 * â•‘               - Auto-load campaigns                                           â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 4]  EMPLOYEE RANGE MANAGEMENT ................. search: #EMPLOYEE  â•‘
 * â•‘               - loadAndRenderEmployeeTable()                                  â•‘
 * â•‘               - applyEmployeeRanges()                                         â•‘
 * â•‘               - getEmployeeName()                                             â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 5]  TAG MANAGEMENT ............................ search: #TAG       â•‘
 * â•‘               - loadAvailableTags() - Táº£i danh sÃ¡ch tag                      â•‘
 * â•‘               - openTagModal() - Má»Ÿ modal gÃ¡n tag                            â•‘
 * â•‘               - saveOrderTags() - LÆ°u tag Ä‘Æ¡n hÃ ng                           â•‘
 * â•‘               - quickAssignTag() - GÃ¡n tag nhanh                             â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 6]  BULK TAG MODAL ............................ search: #BULK-TAG  â•‘
 * â•‘               - parseBulkSTTInput() - Parse STT input                        â•‘
 * â•‘               - showBulkTagModal() - Hiá»ƒn thá»‹ modal gÃ¡n tag hÃ ng loáº¡t       â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 7]  TABLE SEARCH & FILTERING .................. search: #SEARCH    â•‘
 * â•‘               - handleTableSearch() - TÃ¬m kiáº¿m báº£ng                          â•‘
 * â•‘               - performTableSearch() - Thá»±c hiá»‡n tÃ¬m kiáº¿m                    â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 8]  TABLE RENDERING ........................... search: #RENDER    â•‘
 * â•‘               - renderTable() - Render báº£ng chÃ­nh                            â•‘
 * â•‘               - createRowHTML() - Táº¡o HTML hÃ ng                              â•‘
 * â•‘               - renderMessagesColumn() - Render cá»™t tin nháº¯n                 â•‘
 * â•‘               - renderCommentsColumn() - Render cá»™t bÃ¬nh luáº­n                â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 9]  MERGED ORDER COLUMNS ...................... search: #MERGED    â•‘
 * â•‘               - renderMergedMessagesColumn()                                  â•‘
 * â•‘               - renderMergedQuantityColumn()                                  â•‘
 * â•‘               - renderMergedTotalColumn()                                     â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 10] EDIT MODAL ................................ search: #EDIT      â•‘
 * â•‘               - openEditModal() - Má»Ÿ modal sá»­a Ä‘Æ¡n                           â•‘
 * â•‘               - saveOrderChanges() - LÆ°u thay Ä‘á»•i                            â•‘
 * â•‘               - prepareOrderPayload() - Chuáº©n bá»‹ payload API                 â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 11] INLINE PRODUCT SEARCH ..................... search: #PRODUCT   â•‘
 * â•‘               - initInlineProductSearch()                                     â•‘
 * â•‘               - performInlineSearch()                                         â•‘
 * â•‘               - addProductToOrderFromInline()                                 â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 12] CHAT MODAL & MESSAGING .................... search: #CHAT      â•‘
 * â•‘               - openChatModal() - Má»Ÿ modal chat                              â•‘
 * â•‘               - sendMessage() - Gá»­i tin nháº¯n                                 â•‘
 * â•‘               - sendComment() - Gá»­i bÃ¬nh luáº­n                                â•‘
 * â•‘               - Image upload & paste handling                                 â•‘
 * â•‘               - setupRealtimeMessages() - Realtime via Facebook API         â•‘
 * â•‘               - fetchMessagesFromFacebookAPI() - Láº¥y tin nháº¯n tá»« FB         â•‘
 * â•‘               - cleanupRealtimeMessages() - Cleanup listeners                â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 13] INFINITE SCROLL ........................... search: #SCROLL    â•‘
 * â•‘               - setupChatInfiniteScroll()                                     â•‘
 * â•‘               - loadMoreMessages()                                            â•‘
 * â•‘               - loadMoreComments()                                            â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 14] NOTE ENCODING/DECODING .................... search: #ENCODE    â•‘
 * â•‘               - base64UrlDecode()                                             â•‘
 * â•‘               - xorDecrypt()                                                  â•‘
 * â•‘               - decodeProductLine()                                           â•‘
 * â•‘               - hasValidEncodedProducts()                                     â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 15] ORDER MERGE FUNCTIONS ..................... search: #MERGE     â•‘
 * â•‘               - getOrderDetails()                                             â•‘
 * â•‘               - executeMergeOrderProducts()                                   â•‘
 * â•‘               - executeBulkMergeOrderProducts()                               â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 16] ADDRESS LOOKUP ............................ search: #ADDRESS   â•‘
 * â•‘               - handleAddressLookup()                                         â•‘
 * â•‘               - handleFullAddressLookup()                                     â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 17] QR CODE & DEBT FUNCTIONS .................. search: #QR-DEBT   â•‘
 * â•‘               - renderQRColumn() - Render cá»™t QR                             â•‘
 * â•‘               - renderDebtColumn() - Render cá»™t cÃ´ng ná»£                      â•‘
 * â•‘               - fetchDebtForPhone() - Láº¥y cÃ´ng ná»£ theo SÄT                   â•‘
 * â•‘               - connectDebtRealtime() - Káº¿t ná»‘i SSE cáº­p nháº­t cÃ´ng ná»£         â•‘
 * â•‘                                                                              â•‘
 * â•‘  [SECTION 18] SALE MODAL - PRODUCT SEARCH ............... search: #SALE-PROD â•‘
 * â•‘               - initSaleProductSearch() - Khá»Ÿi táº¡o search (~7300)            â•‘
 * â•‘               - performSaleProductSearch() - TÃ¬m kiáº¿m SP                     â•‘
 * â•‘               - displaySaleProductResults() - Hiá»ƒn thá»‹ káº¿t quáº£               â•‘
 * â•‘               - addProductToSaleFromSearch() - ThÃªm SP + API update (~2214)  â•‘
 * â•‘               - updateSaleOrderWithAPI() - PUT API update order (~15687)     â•‘
 * â•‘               - updateSaleItemQuantityFromAPI() - Update SL + API            â•‘
 * â•‘               - removeSaleItemFromAPI() - XÃ³a SP + API                       â•‘
 * â•‘               - recalculateSaleTotals() - TÃ­nh láº¡i tá»•ng (~7273)              â•‘
 * â•‘                                                                              â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                        SECTION 1: GLOBAL VARIABLES                          â•‘
// â•‘                            search: #GLOBAL                                  â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// GLOBAL VARIABLES #GLOBAL
// =====================================================

/**
 * Format time to Vietnam timezone (GMT+7) with relative display
 * @param {string|Date} dateInput - Date string or Date object (UTC or any timezone)
 * @param {boolean} showFullDate - If true, always show full date instead of relative time
 * @returns {string} Formatted time string in Vietnamese
 */
window.formatTimeVN = function (dateInput, showFullDate = false) {
    if (!dateInput) return '';

    // Parse input date
    let date;
    if (typeof dateInput === 'string') {
        // Handle ISO string without timezone (assume UTC)
        if (!dateInput.includes('Z') && !dateInput.includes('+') && !dateInput.includes('-', 10)) {
            date = new Date(dateInput + 'Z');
        } else {
            date = new Date(dateInput);
        }
    } else {
        date = new Date(dateInput);
    }

    if (isNaN(date.getTime())) return '';

    // Vietnam timezone offset: UTC+7
    const vnOffset = 7 * 60 * 60 * 1000; // 7 hours in milliseconds
    const vnDate = new Date(date.getTime() + vnOffset);

    // Current time in Vietnam
    const nowVN = new Date(Date.now() + vnOffset);

    // Calculate difference
    const diffMs = nowVN - vnDate;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    // Show relative time if not showFullDate and within 7 days
    if (!showFullDate) {
        if (diffMins < 0) return 'Vá»«a xong'; // Future time (clock sync issue)
        if (diffMins < 1) return 'Vá»«a xong';
        if (diffMins < 60) return `${diffMins} phÃºt trÆ°á»›c`;
        if (diffHours < 24) return `${diffHours} giá» trÆ°á»›c`;
        if (diffDays < 7) return `${diffDays} ngÃ y trÆ°á»›c`;
    }

    // Format full date in Vietnam timezone
    // Format: dd/MM/yyyy HH:mm
    const day = String(vnDate.getUTCDate()).padStart(2, '0');
    const month = String(vnDate.getUTCMonth() + 1).padStart(2, '0');
    const year = vnDate.getUTCFullYear();
    const hours = String(vnDate.getUTCHours()).padStart(2, '0');
    const minutes = String(vnDate.getUTCMinutes()).padStart(2, '0');

    return `${day}/${month}/${year} ${hours}:${minutes}`;
};

// Global variables
let allData = [];
let filteredData = [];
let displayedData = [];
let currentPage = 1;
const itemsPerPage = 50;
let selectedOrderIds = new Set();
let isLoading = false;
let loadingAborted = false;
let isRendering = false; // Flag to prevent duplicate renders during scroll
let employeeRanges = []; // Employee STT ranges

// Table Sorting State
let currentSortColumn = null; // 'phone', 'address', 'debt', 'total', 'quantity'
let currentSortDirection = null; // 'asc', 'desc', null

// Expose data for other modules
window.getAllOrders = () => allData;

// Search State
let searchQuery = "";
let searchTimeout = null;

// Tag Management State
let availableTags = [];
let currentEditingOrderId = null;


// Edit Modal State
let currentEditOrderData = null;
let currentChatOrderDetails = [];
let currentChatOrderId = null;

// Getter/Setter for currentChatOrderDetails - used by external modules
window.getChatOrderDetails = function () {
    return currentChatOrderDetails;
};
window.setChatOrderDetails = function (details) {
    currentChatOrderDetails = details;
};
let currentChatProductsRef = null;
let currentOrderTags = [];
let pendingDeleteTagIndex = -1; // Track which tag is pending deletion on backspace
let currentUserIdentifier = null; // User identifier for quick tag feature
let currentPastedImage = null; // Track pasted image for chat reply (deprecated - use array below)
let uploadedImagesData = []; // Track uploaded images data (array for multiple images)

// KPI BASE Status Cache - stores order IDs that have BASE saved
let ordersWithKPIBase = new Set();

// Order Details Cache - stores fetched order details for chat modal (TTL: 5 minutes)
const ORDER_DETAILS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes in ms
const orderDetailsCache = new Map(); // Map<orderId, { data, timestamp }>

/**
 * Get order details from cache if valid
 * @param {string} orderId - Order ID
 * @returns {Object|null} - Cached order data or null if expired/not found
 */
function getOrderDetailsFromCache(orderId) {
    const cached = orderDetailsCache.get(orderId);
    if (cached && (Date.now() - cached.timestamp) < ORDER_DETAILS_CACHE_TTL) {
        console.log(`[CACHE] âœ… Order details cache HIT for ${orderId}`);
        return cached.data;
    }
    if (cached) {
        console.log(`[CACHE] â° Order details cache EXPIRED for ${orderId}`);
        orderDetailsCache.delete(orderId);
    }
    return null;
}

/**
 * Save order details to cache
 * @param {string} orderId - Order ID
 * @param {Object} data - Order data to cache
 */
function saveOrderDetailsToCache(orderId, data) {
    orderDetailsCache.set(orderId, { data, timestamp: Date.now() });
    console.log(`[CACHE] ğŸ’¾ Order details cached for ${orderId} (TTL: ${ORDER_DETAILS_CACHE_TTL / 1000}s)`);

    // Clean up old entries (keep max 50 entries)
    if (orderDetailsCache.size > 50) {
        const oldestKey = orderDetailsCache.keys().next().value;
        orderDetailsCache.delete(oldestKey);
        console.log(`[CACHE] ğŸ§¹ Evicted oldest cache entry`);
    }
}

// Purchase Comment Highlight State
window.purchaseCommentId = null; // Store the Facebook_CommentId from the order to highlight in comment modal
window.purchaseFacebookPostId = null; // Store Facebook_PostId
window.purchaseFacebookASUserId = null; // Store Facebook_ASUserId

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                   SECTION 2: FIREBASE & REALTIME TAG SYNC                   â•‘
// â•‘                            search: #FIREBASE                                â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// FIREBASE DATABASE REFERENCE FOR NOTE TRACKING #FIREBASE
// =====================================================
// Note: Firebase is already initialized in config.js which loads before this file
let database = null;
try {
    database = firebase.database();
    console.log('[NOTE-TRACKER] Firebase database reference obtained');
} catch (error) {
    console.error('[NOTE-TRACKER] Firebase database reference error:', error);
}

// =====================================================
// FILTER PREFERENCES - Firebase Sync #FIREBASE
// =====================================================

/**
 * Get current user ID for filter preferences (per-user storage)
 * @returns {string} - User ID from Firebase auth or localStorage fallback
 */
function getFilterPrefsUserId() {
    // Try to get from Firebase auth
    if (typeof firebase !== 'undefined' && firebase.auth && firebase.auth().currentUser) {
        return firebase.auth().currentUser.uid;
    }
    // Try to get from window.campaignManager (initialized in HTML)
    if (window.campaignManager && window.campaignManager.currentUserId) {
        return window.campaignManager.currentUserId;
    }
    // Fallback to localStorage
    let userId = localStorage.getItem('campaign_user_id');
    if (!userId) {
        userId = 'user_' + Date.now();
        localStorage.setItem('campaign_user_id', userId);
    }
    return userId;
}

/**
 * Get filter preferences Firebase path for current user
 * @returns {string} - Firebase path like "user_preferences/{userId}/filter_preferences"
 */
function getFilterPrefsPath() {
    const userId = getFilterPrefsUserId();
    return `user_preferences/${userId}/filter_preferences`;
}

/**
 * [DEPRECATED] Save filter preferences to Firebase (per-user)
 * Dates are now stored in campaign objects directly.
 * This function is kept as a no-op stub for backward compatibility.
 */
async function saveFilterPreferencesToFirebase(prefs) {
    // No-op: Dates are now stored in campaign objects
    console.log('[FILTER-PREFS] âš ï¸ DEPRECATED - Dates stored in campaign now');
    return;
}

/**
 * [DEPRECATED] Load filter preferences from Firebase (per-user)
 * Dates are now loaded from campaign objects directly.
 * This function is kept as a no-op stub for backward compatibility.
 */
async function loadFilterPreferencesFromFirebase() {
    // No-op: Dates are now loaded from campaign objects
    console.log('[FILTER-PREFS] âš ï¸ DEPRECATED - Dates loaded from campaign now');
    return null;
}

// =====================================================
// REALTIME TAG SYNC - Firebase & WebSocket #FIREBASE
// =====================================================
let tagListenersSetup = false; // Flag to prevent duplicate listener setup

/**
 * Emit TAG update to Firebase for realtime sync across users
 */
async function emitTagUpdateToFirebase(orderId, tags) {
    if (!database) {
        console.warn('[TAG-REALTIME] Firebase not available, skipping emit');
        return;
    }

    try {
        // Get current order data
        const order = allData.find(o => o.Id === orderId);
        if (!order) {
            console.warn('[TAG-REALTIME] Order not found in allData:', orderId);
            return;
        }

        // Get current user display name from authManager
        let userName = 'Unknown User';
        const auth = window.authManager ? window.authManager.getAuthState() : null;
        if (auth && auth.displayName) {
            userName = auth.displayName;
        }

        // âœ… Validate and normalize tags array
        const normalizedTags = Array.isArray(tags) ? tags : [];

        console.log('[TAG-REALTIME] Preparing to emit:', {
            orderId,
            orderCode: order.Code,
            STT: order.SessionIndex,
            tagsCount: normalizedTags.length,
            tags: normalizedTags,
            updatedBy: userName
        });

        // Emit to Firebase
        const updateData = {
            orderId: orderId,
            orderCode: order.Code || 'Unknown',
            STT: order.SessionIndex || 0,
            tags: normalizedTags, // Array of tag objects (can be empty array)
            updatedBy: userName,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };

        // Write to Firebase path: /tag_updates/{orderId}
        const refPath = `tag_updates/${orderId}`;
        await database.ref(refPath).set(updateData);

        console.log('[TAG-REALTIME] âœ… Tag update emitted successfully to Firebase:', refPath);
        console.log('[TAG-REALTIME] Data written:', updateData);
    } catch (error) {
        console.error('[TAG-REALTIME] âŒ Error emitting tag update:', error);
        console.error('[TAG-REALTIME] Error stack:', error.stack);
    }
}

/**
 * Setup Firebase & WebSocket listeners for realtime TAG updates
 */
function setupTagRealtimeListeners() {
    // Prevent duplicate setup
    if (tagListenersSetup) {
        console.log('[TAG-REALTIME] Listeners already setup, skipping...');
        return;
    }

    // 1. Setup Firebase listener
    if (database) {
        const refPath = `tag_updates`;
        console.log('[TAG-REALTIME] Setting up Firebase listener on:', refPath);

        // Get current user name
        const auth = window.authManager ? window.authManager.getAuthState() : null;
        const currentUserName = auth && auth.displayName ? auth.displayName : 'Unknown';
        console.log('[TAG-REALTIME] Current user:', currentUserName);

        // Listen for tag updates
        database.ref(refPath).on('child_changed', (snapshot) => {
            const updateData = snapshot.val();
            console.log('[TAG-REALTIME] Firebase tag update received:', updateData);

            // Only process if update is from another user
            if (updateData.updatedBy !== currentUserName) {
                handleRealtimeTagUpdate(updateData, 'firebase');
            } else {
                console.log('[TAG-REALTIME] Skipping own update');
            }
        });

        database.ref(refPath).on('child_added', (snapshot) => {
            const updateData = snapshot.val();

            // Only process if timestamp is recent (within last 5 seconds)
            // This prevents showing notifications for old data when first connecting
            if (updateData.timestamp && (Date.now() - updateData.timestamp < 5000)) {
                console.log('[TAG-REALTIME] Firebase new tag update:', updateData);

                // Only process if update is from another user
                if (updateData.updatedBy !== currentUserName) {
                    handleRealtimeTagUpdate(updateData, 'firebase');
                } else {
                    console.log('[TAG-REALTIME] Skipping own update');
                }
            }
        });

        tagListenersSetup = true;
        console.log('[TAG-REALTIME] âœ… Firebase listeners setup complete');
    }

    // 2. Setup WebSocket listener (for future backend support)
    window.addEventListener('realtimeOrderTagsUpdate', (event) => {
        const updateData = event.detail;
        console.log('[TAG-REALTIME] WebSocket tag update received:', updateData);
        handleRealtimeTagUpdate(updateData, 'websocket');
    });
}

/**
 * Handle realtime TAG update from Firebase or WebSocket
 */
function handleRealtimeTagUpdate(updateData, source) {
    const { orderId, orderCode, STT, tags, updatedBy } = updateData;

    console.log(`[TAG-REALTIME] Processing update from ${source}:`, updateData);

    // âœ… Validate tags - treat undefined/null as empty array for "delete all tags" case
    const normalizedTags = tags === undefined || tags === null ? [] : tags;
    if (!Array.isArray(normalizedTags)) {
        console.error('[TAG-REALTIME] Invalid tags data (not an array):', tags);
        console.error('[TAG-REALTIME] Full updateData:', updateData);
        return;
    }

    console.log('[TAG-REALTIME] Normalized tags:', normalizedTags);

    // âœ… FIX SCROLL ISSUE: Check if order is in DISPLAYED data (after employee filter)
    // This prevents unnecessary re-renders for orders not in current user's view
    const orderInDisplayed = displayedData.find(o => o.Id === orderId);
    if (!orderInDisplayed) {
        console.log('[TAG-REALTIME] Order not in displayed data (not my range), skipping update');
        // Still update allData silently for data consistency
        const indexInAll = allData.findIndex(o => o.Id === orderId);
        if (indexInAll !== -1) {
            allData[indexInAll].Tags = JSON.stringify(normalizedTags);
        }
        return;
    }

    // ğŸš¨ CONFLICT RESOLUTION: Check if user is currently editing this order's tags
    if (currentEditingOrderId === orderId) {
        console.warn('[TAG-REALTIME] Conflict detected: User is editing this order!');

        // Close modal and show warning
        const modal = document.getElementById('tagModal');
        if (modal && modal.style.display !== 'none') {
            closeTagModal();
        }
    }

    // âœ… SIMPLIFIED: Always update TAG cell realtime (removed tag filter check)
    // updateTagCellOnly() only updates innerHTML of cell - NO scroll jump
    // Data arrays are updated inside updateTagCellOnly()
    updateTagCellOnly(orderId, orderCode, normalizedTags);
}

/**
 * Update only the TAG cell in DOM without re-rendering entire table
 * This preserves scroll position when realtime tag updates occur
 */
function updateTagCellOnly(orderId, orderCode, tags) {
    console.log('[TAG-REALTIME] Updating only TAG cell for order:', orderId);

    // 1. Update data arrays first
    const tagsJson = JSON.stringify(tags);

    const indexInAll = allData.findIndex(order => order.Id === orderId);
    if (indexInAll !== -1) {
        allData[indexInAll].Tags = tagsJson;
    }

    const indexInFiltered = filteredData.findIndex(order => order.Id === orderId);
    if (indexInFiltered !== -1) {
        filteredData[indexInFiltered].Tags = tagsJson;
    }

    const indexInDisplayed = displayedData.findIndex(order => order.Id === orderId);
    if (indexInDisplayed !== -1) {
        displayedData[indexInDisplayed].Tags = tagsJson;
    }

    // 2. Find the row in DOM by checkbox value
    const checkbox = document.querySelector(`#tableBody input[type="checkbox"][value="${orderId}"]`);
    if (!checkbox) {
        // Order might be in employee section tables
        const allCheckboxes = document.querySelectorAll(`input[type="checkbox"][value="${orderId}"]`);
        if (allCheckboxes.length === 0) {
            console.log('[TAG-REALTIME] Row not found in DOM, skipping cell update');
            return;
        }
    }

    const row = checkbox ? checkbox.closest('tr') : document.querySelector(`input[type="checkbox"][value="${orderId}"]`)?.closest('tr');
    if (!row) {
        console.log('[TAG-REALTIME] Row not found in DOM');
        return;
    }

    // 3. Find the TAG cell
    const tagCell = row.querySelector('td[data-column="tag"]');
    if (!tagCell) {
        console.log('[TAG-REALTIME] TAG cell not found');
        return;
    }

    // 4. Generate new tag HTML
    const tagsHTML = parseOrderTags(tagsJson, orderId, orderCode);

    // 5. Update only the tag cell content (preserve buttons)
    tagCell.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 4px; align-items: flex-start;">
            <div style="display: flex; gap: 2px;">
                <button class="tag-icon-btn" onclick="openTagModal('${orderId}', '${orderCode}'); event.stopPropagation();" title="Quáº£n lÃ½ tag" style="padding: 2px 6px;">
                    <i class="fas fa-tags"></i>
                </button>
                <button class="quick-tag-btn" onclick="quickAssignTag('${orderId}', '${orderCode}', 'xá»­ lÃ½'); event.stopPropagation();" title="Xá»­ lÃ½ + Ä‘á»‹nh danh">
                    <i class="fas fa-clock"></i>
                </button>
                <button class="quick-tag-btn quick-tag-ok" onclick="quickAssignTag('${orderId}', '${orderCode}', 'ok'); event.stopPropagation();" title="OK + Ä‘á»‹nh danh">
                    <i class="fas fa-check"></i>
                </button>
            </div>
            ${tagsHTML}
        </div>
    `;

    console.log('[TAG-REALTIME] âœ“ TAG cell updated successfully (no scroll change)');
}

/**
 * Cleanup Firebase listeners when changing campaign
 */
function cleanupTagRealtimeListeners() {
    if (database) {
        const refPath = `tag_updates`;
        database.ref(refPath).off();
        console.log('[TAG-REALTIME] Cleaned up Firebase listeners for:', refPath);
    }
}

/**
 * TEST FUNCTION - Check if TAG listeners are working
 * Call from Console: testTagListeners()
 */
window.testTagListeners = function () {
    console.log('=== TAG REALTIME LISTENER TEST ===');
    console.log('1. Firebase:', database ? 'âœ… Available' : 'âŒ Not available');
    console.log('2. Listeners setup:', tagListenersSetup ? 'âœ… Yes' : 'âŒ No');

    const auth = window.authManager ? window.authManager.getAuthState() : null;
    const currentUser = auth && auth.displayName ? auth.displayName : 'Unknown';
    console.log('3. Current user:', currentUser);

    console.log('4. Orders loaded:', allData ? allData.length : 0);

    if (database) {
        console.log('\nğŸ”¥ Setting up test listener...');

        // Add a one-time listener to test
        database.ref('tag_updates').once('value', (snapshot) => {
            console.log('âœ… Firebase connection working!');
            console.log('Total TAG updates in database:', snapshot.numChildren());
        });

        // Listen for any changes
        const testRef = database.ref('tag_updates');
        const testListener = (snapshot) => {
            console.log('ğŸ”¥ğŸ”¥ğŸ”¥ FIREBASE EVENT TRIGGERED! ğŸ”¥ğŸ”¥ğŸ”¥');
            console.log('Event type: child_changed');
            console.log('Data:', snapshot.val());
        };

        testRef.on('child_changed', testListener);
        console.log('âœ… Test listener attached');
        console.log('Now save a TAG and watch for ğŸ”¥ events...');

        // Cleanup after 30 seconds
        setTimeout(() => {
            testRef.off('child_changed', testListener);
            console.log('ğŸ§¹ Test listener removed');
        }, 30000);
    }

    console.log('\n=== TEST COMPLETE ===');
};

// =====================================================
// KPI BASE STATUS PRELOAD #FIREBASE
// =====================================================

/**
 * Preload KPI BASE status for all orders
 * This allows synchronous checking in createRowHTML
 */
async function preloadKPIBaseStatus() {
    if (!database) {
        console.warn('[KPI-BASE] Firebase database not available');
        return;
    }

    try {
        const snapshot = await database.ref('kpi_base').once('value');
        const allBases = snapshot.val() || {};

        // Clear and rebuild the cache
        ordersWithKPIBase.clear();
        for (const orderId in allBases) {
            ordersWithKPIBase.add(orderId);
        }

        console.log(`[KPI-BASE] Preloaded ${ordersWithKPIBase.size} orders with BASE`);

        // Re-render table if data is already loaded
        if (allData && allData.length > 0) {
            performTableSearch();
        }
    } catch (error) {
        console.error('[KPI-BASE] Error preloading BASE status:', error);
    }
}

/**
 * Setup realtime listener for KPI BASE changes
 */
function setupKPIBaseRealtimeListener() {
    if (!database) return;

    database.ref('kpi_base').on('child_added', (snapshot) => {
        const orderId = snapshot.key;
        ordersWithKPIBase.add(orderId);
        console.log('[KPI-BASE] BASE added for order:', orderId);

        // Update the specific row if visible
        updateKPIBaseIndicator(orderId, true);
    });

    database.ref('kpi_base').on('child_removed', (snapshot) => {
        const orderId = snapshot.key;
        ordersWithKPIBase.delete(orderId);
        console.log('[KPI-BASE] BASE removed for order:', orderId);

        // Update the specific row if visible
        updateKPIBaseIndicator(orderId, false);
    });

    console.log('[KPI-BASE] Realtime listener setup complete');
}

/**
 * Update KPI BASE indicator for a specific order row
 */
function updateKPIBaseIndicator(orderId, hasBase) {
    // Find the row by order ID
    const checkbox = document.querySelector(`input[type="checkbox"][value="${orderId}"]`);
    if (!checkbox) return;

    const row = checkbox.closest('tr');
    if (!row) return;

    const sttCell = row.querySelector('td[data-column="stt"]');
    if (!sttCell) return;

    // Check if indicator already exists
    let indicator = sttCell.querySelector('.kpi-base-indicator');

    if (hasBase && !indicator) {
        // Add indicator
        const div = sttCell.querySelector('div') || sttCell;
        const indicatorEl = document.createElement('span');
        indicatorEl.className = 'kpi-base-indicator';
        indicatorEl.title = 'ÄÃ£ lÆ°u BASE tÃ­nh KPI';
        indicatorEl.innerHTML = '<i class="fas fa-lock" style="color: #10b981; font-size: 10px;"></i>';
        indicatorEl.style.marginLeft = '4px';
        div.appendChild(indicatorEl);
    } else if (!hasBase && indicator) {
        // Remove indicator
        indicator.remove();
    }
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                        SECTION 3: INITIALIZATION                            â•‘
// â•‘                            search: #INIT                                    â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// INITIALIZATION #INIT
// =====================================================
window.addEventListener("DOMContentLoaded", async function () {
    // Apply orders table font size from settings
    const ordersTableFontSize = localStorage.getItem("ordersTableFontSize") || "14";
    document.documentElement.style.setProperty("--orders-table-font-size", `${ordersTableFontSize}px`);

    // Listen for font size changes from parent window
    window.addEventListener("storage", (e) => {
        if (e.key === "ordersTableFontSize") {
            document.documentElement.style.setProperty("--orders-table-font-size", `${e.newValue}px`);
        }
    });

    // ğŸ§¹ Clean up localStorage if near quota to prevent QuotaExceededError
    (function cleanupLocalStorageIfNeeded() {
        try {
            // Estimate current localStorage usage
            let totalSize = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    totalSize += localStorage[key].length + key.length;
                }
            }
            const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
            console.log(`[STORAGE] Current localStorage usage: ${totalSizeMB} MB`);

            // If over 4MB (localStorage limit is usually 5-10MB), clean up
            if (totalSize > 4 * 1024 * 1024) {
                console.warn('[STORAGE] âš ï¸ localStorage near quota, cleaning up...');

                // Keys to clean (low priority / can be regenerated)
                const keysToClean = [];
                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        // Clean Firebase websocket failure logs
                        if (key.startsWith('firebase:')) {
                            keysToClean.push(key);
                        }
                        // Clean old standard price cache (large data)
                        if (key === 'standard_price_cache' && localStorage[key].length > 500000) {
                            keysToClean.push(key);
                        }
                        // Clean old product cache
                        if (key === 'product_excel_cache' && localStorage[key].length > 500000) {
                            keysToClean.push(key);
                        }
                    }
                }

                keysToClean.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`[STORAGE] Removed: ${key}`);
                });

                console.log(`[STORAGE] âœ… Cleaned ${keysToClean.length} items`);
            }
        } catch (e) {
            console.warn('[STORAGE] Error checking localStorage:', e);
        }
    })();

    console.log("[CACHE] Clearing all cache on page load...");
    if (window.cacheManager) {
        window.cacheManager.clear("orders");
        window.cacheManager.clear("campaigns");
    }

    // Check and complete any pending held products cleanup from previous session
    if (typeof window.checkPendingHeldCleanup === 'function') {
        window.checkPendingHeldCleanup();
    }

    // âš ï¸ QUAN TRá»ŒNG: Set default dates TRÆ¯á»šC KHI load campaigns
    // VÃ¬ auto-load cáº§n dates Ä‘á»ƒ fetch orders
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    document.getElementById("endDate").value = formatDateTimeLocal(now);
    document.getElementById("startDate").value =
        formatDateTimeLocal(thirtyDaysAgo);

    // Event listeners
    document
        .getElementById("loadCampaignsBtn")
        .addEventListener("click", handleLoadCampaigns);
    document
        .getElementById("clearCacheBtn")
        .addEventListener("click", handleClearCache);
    document
        .getElementById("selectAll")
        .addEventListener("change", handleSelectAll);
    document
        .getElementById("campaignFilter")
        .addEventListener("change", handleCampaignChange);

    // ğŸ¯ Event listener for custom date filter - auto-search when date changes
    document
        .getElementById("customStartDate")
        .addEventListener("change", handleCustomDateChange);

    // ğŸ¯ Event listener for custom end date - trigger search when manually changed
    const customEndDateInput = document.getElementById("customEndDate");
    if (customEndDateInput) {
        customEndDateInput.addEventListener("change", handleCustomEndDateChange);
    }

    // Event listener for employee campaign selector
    const employeeCampaignSelector = document.getElementById('employeeCampaignSelector');
    if (employeeCampaignSelector) {
        employeeCampaignSelector.addEventListener('change', function (e) {
            const selectedOption = e.target.options[e.target.selectedIndex];
            if (selectedOption && selectedOption.dataset.campaign) {
                const campaign = JSON.parse(selectedOption.dataset.campaign);
                console.log(`[EMPLOYEE] Campaign changed in drawer, loading ranges for: ${campaign.displayName}`);
                loadEmployeeRangesForCampaign(campaign.displayName);
            } else {
                console.log('[EMPLOYEE] Loading general employee ranges');
                loadEmployeeRangesForCampaign(null);
            }
        });
    }

    // Initialize TPOS Token Manager Firebase connection
    if (window.tokenManager) {
        console.log('[TOKEN] Retrying Firebase initialization for TokenManager...');
        if (window.tokenManager.retryFirebaseInit()) {
            console.log('[TOKEN] âœ… Firebase connection established');
        } else {
            console.warn('[TOKEN] âš ï¸ Firebase still not available, using localStorage only');
        }
    }

    // Initialize Pancake Token Manager & Data Manager
    // âš¡ OPTIMIZED: Start Pancake init in PARALLEL with orders loading
    // Chat columns will show "-" initially, then re-render when Pancake is ready
    let pancakeInitPromise = null;
    if (window.pancakeTokenManager && window.pancakeDataManager) {
        console.log('[PANCAKE] Initializing Pancake managers (background)...');

        // Initialize token manager first (sync)
        window.pancakeTokenManager.initialize();

        // Start data manager init but DON'T WAIT - run in parallel with orders loading
        pancakeInitPromise = window.pancakeDataManager.initialize()
            .then(success => {
                if (success) {
                    console.log('[PANCAKE] âœ… PancakeDataManager initialized (background)');
                    // Set chatDataManager alias for compatibility
                    window.chatDataManager = window.pancakeDataManager;
                } else {
                    console.warn('[PANCAKE] âš ï¸ PancakeDataManager initialization failed');
                    console.warn('[PANCAKE] Please set JWT token in Pancake Settings');
                }
                return success;
            })
            .catch(error => {
                console.error('[PANCAKE] âŒ Error initializing PancakeDataManager:', error);
                return false;
            });
    } else {
        console.warn('[PANCAKE] âš ï¸ Pancake managers not available');
    }
    // Initialize Realtime Manager
    if (window.RealtimeManager) {
        console.log('[REALTIME] Initializing RealtimeManager...');
        window.realtimeManager = new RealtimeManager();
        window.realtimeManager.initialize();
    } else {
        console.warn('[REALTIME] âš ï¸ RealtimeManager class not found');
    }

    // âš¡ OPTIMIZATION FIX: Defer TAG/KPI BASE listeners to reduce initial blocking
    // Previous: Setup immediately, blocking DOMContentLoaded
    // New: Defer by 1 second to allow UI to render first
    if (database) {
        setTimeout(() => {
            console.log('[TAG-REALTIME] Setting up Firebase TAG listeners (deferred)...');
            setupTagRealtimeListeners();

            // TEMPORARILY DISABLED - KPI BASE feature
            // console.log('[KPI-BASE] Setting up KPI BASE listeners (deferred)...');
            // setupKPIBaseRealtimeListener();
            // preloadKPIBaseStatus(); // Preload BASE status for all orders
        }, 1000); // Defer 1 second
    } else {
        console.warn('[TAG-REALTIME] Firebase not available, listeners not setup');
    }

    // Scroll to top button
    const scrollBtn = document.getElementById("scrollToTopBtn");
    const tableWrapper = document.getElementById("tableWrapper");

    tableWrapper.addEventListener("scroll", function () {
        if (tableWrapper.scrollTop > 300) {
            scrollBtn.classList.add("show");
        } else {
            scrollBtn.classList.remove("show");
        }
    });

    scrollBtn.addEventListener("click", function () {
        tableWrapper.scrollTo({ top: 0, behavior: "smooth" });
    });

    // ğŸ¯ ÄÆ N GIáº¢N HÃ“A: DÃ¹ng Campaign System má»›i (merged)
    // Flow: Load campaigns â†’ Check active â†’ Fetch orders (1 láº§n duy nháº¥t)
    console.log('[AUTO-LOAD] Khá»Ÿi táº¡o App...');
    console.log('[AUTO-LOAD] chatDataManager available:', !!window.chatDataManager);

    // âš¡ OPTIMIZATION FIX: Make initializeApp() non-blocking
    // Previous: await initializeApp() blocked everything
    // New: Run in background, show loading indicator
    initializeApp().then(() => {
        console.log('[APP] âœ… Initialization complete');
    }).catch(err => {
        console.error('[APP] âŒ Initialization failed:', err);
        alert('Lá»—i khá»Ÿi táº¡o á»©ng dá»¥ng. Vui lÃ²ng refresh láº¡i trang.');
    });

    // âš¡ PHASE 1 OPTIMIZATION: After orders loaded, wait for Pancake and re-render chat columns
    if (pancakeInitPromise) {
        pancakeInitPromise.then(success => {
            if (success && allData.length > 0 && window.chatDataManager) {
                console.log('[PANCAKE] Re-rendering table with chat data after background init...');
                // Re-render table to show chat columns now that chatDataManager is ready
                performTableSearch();
            }
        });
    }

    // Search functionality
    const searchInput = document.getElementById("tableSearchInput");
    const searchClearBtn = document.getElementById("searchClearBtn");

    searchInput.addEventListener("input", function (e) {
        handleTableSearch(e.target.value);
    });

    searchClearBtn.addEventListener("click", function () {
        searchInput.value = "";
        handleTableSearch("");
        searchInput.focus();
    });

    // Clear search on Escape
    searchInput.addEventListener("keydown", function (e) {
        if (e.key === "Escape") {
            searchInput.value = "";
            handleTableSearch("");
        }
    });

    // Load employee table from Firestore
    // loadAndRenderEmployeeTable(); // Moved to syncEmployeeRanges

    // Check admin permission
    checkAdminPermission();

    // âš ï¸ DISABLED: syncEmployeeRanges() - No longer needed!
    // Employee ranges are now loaded per-campaign in handleCampaignChange()
    // syncEmployeeRanges() would overwrite campaign-specific ranges with general config
    // syncEmployeeRanges();

    // Close modals when clicking outside
    window.addEventListener('click', function (event) {
        const tagModal = document.getElementById('tagModal');
        if (event.target === tagModal) {
            closeTagModal();
            if (window.quickTagManager) {
                window.quickTagManager.closeAllDropdowns();
            }
        }
    });

    // âš¡ NEW: Listen for token requests from Overview tab (via main.html)
    window.addEventListener('message', async function(event) {
        if (event.data.type === 'REQUEST_TOKEN') {
            console.log('[TAB1] ğŸ”‘ Token requested, responding...');
            try {
                if (!window.tokenManager) {
                    throw new Error('tokenManager not available');
                }
                const token = await window.tokenManager.getToken();
                window.parent.postMessage({
                    type: 'TOKEN_RESPONSE',
                    requestId: event.data.requestId,
                    token: token
                }, '*');
                console.log('[TAB1] âœ… Token sent successfully');
            } catch (error) {
                console.error('[TAB1] âŒ Error getting token:', error);
                window.parent.postMessage({
                    type: 'TOKEN_RESPONSE',
                    requestId: event.data.requestId,
                    error: error.message
                }, '*');
            }
        }
    });

    // Keyboard shortcuts for tag modal
    document.addEventListener('keydown', function (event) {
        const tagModal = document.getElementById('tagModal');
        if (tagModal && tagModal.classList.contains('show')) {
            // Ctrl+Enter to save tags
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                saveOrderTags();
            }
            // ESC to close without saving
            else if (event.key === 'Escape') {
                event.preventDefault();
                closeTagModal();
            }
            // Tab to save and close
            else if (event.key === 'Tab') {
                const tagSearchInput = document.getElementById('tagSearchInput');
                // Only trigger if we're at the input and no dropdown is focused
                if (document.activeElement === tagSearchInput || !document.activeElement || document.activeElement === document.body) {
                    event.preventDefault();
                    saveOrderTags();
                }
            }
        }
    });
});

// =====================================================
// INITIALIZE APP (MERGED & OPTIMIZED FLOW)
// =====================================================
/**
 * HÃ m khá»Ÿi táº¡o tá»‘i Æ°u - Load campaign trÆ°á»›c, sau Ä‘Ã³ fetch orders 1 láº§n duy nháº¥t
 * Flow:
 *   1. Wait for Firebase
 *   2. Load data parallel (campaigns, activeCampaignId, employeeRanges)
 *   3. Check active campaign FIRST (fast path)
 *   4. If no dates â†’ show modal
 *   5. Fetch orders 1 láº§n duy nháº¥t
 */
let appInitialized = false; // Guard flag
// âš¡ OPTIMIZATION FIX: Track Firebase wait attempts to prevent infinite loops
let firebaseWaitAttempts = 0;
const MAX_FIREBASE_WAIT_ATTEMPTS = 20; // 20 Ã— 500ms = 10 seconds max

async function initializeApp() {
    // Prevent duplicate initialization
    if (appInitialized) {
        console.log('[APP] Already initialized, skipping...');
        return;
    }
    appInitialized = true;

    try {
        console.log('[APP] ğŸš€ Initializing...');

        // 1. Wait for Firebase to be ready (with timeout)
        if (typeof firebase === 'undefined' || !firebase.database) {
            firebaseWaitAttempts++;

            if (firebaseWaitAttempts >= MAX_FIREBASE_WAIT_ATTEMPTS) {
                console.error('[APP] âŒ Firebase failed to load after 10 seconds');
                appInitialized = false;
                alert('KhÃ´ng thá»ƒ káº¿t ná»‘i Firebase. Vui lÃ²ng kiá»ƒm tra káº¿t ná»‘i máº¡ng vÃ  refresh láº¡i trang.');
                return;
            }

            console.log(`[APP] Waiting for Firebase... (attempt ${firebaseWaitAttempts}/${MAX_FIREBASE_WAIT_ATTEMPTS})`);
            appInitialized = false; // Reset flag so it can retry
            setTimeout(initializeApp, 500);
            return;
        }

        // Reset counter on successful Firebase connection
        firebaseWaitAttempts = 0;

        // Set current user ID
        window.campaignManager = window.campaignManager || {
            allCampaigns: {},
            activeCampaignId: null,
            activeCampaign: null,
            currentUserId: null,
            initialized: false
        };
        window.campaignManager.currentUserId = getCurrentUserId();
        console.log('[APP] User ID:', window.campaignManager.currentUserId);

        // 2. Load data in PARALLEL for speed
        console.log('[APP] Loading data in parallel...');
        const [campaigns, activeCampaignId, _] = await Promise.all([
            loadAllCampaigns(),
            loadActiveCampaignId(),
            loadEmployeeRangesForCampaign(null) // Load employee ranges in parallel
        ]);
        console.log('[APP] Data loaded - Campaigns:', Object.keys(campaigns).length, 'Active:', activeCampaignId);

        // 3. â­ CHECK ACTIVE CAMPAIGN FIRST (Fast path)
        if (activeCampaignId && campaigns[activeCampaignId]) {
            const campaign = campaigns[activeCampaignId];
            console.log('[APP] Found active campaign:', campaign.name);

            // Check if campaign has dates
            if (campaign.customStartDate) {
                // âœ… Happy path - Load ngay!
                console.log('[APP] âœ… Fast path - Campaign has dates, loading orders...');
                await continueAfterCampaignSelect(activeCampaignId);
                return;
            } else {
                // âŒ Campaign doesn't have dates
                console.log('[APP] âš ï¸ Campaign has no dates, showing modal...');
                showCampaignNoDatesModal(activeCampaignId);
                return;
            }
        }

        // 4. No active campaign â†’ Check localStorage fallback first
        const savedFilterData = localStorage.getItem('tab1_filter_data');
        if (savedFilterData) {
            try {
                const filterData = JSON.parse(savedFilterData);
                if (filterData.startDate && filterData.endDate) {
                    console.log('[APP] Found saved filter data in localStorage, using it...');

                    // Convert UTC dates to local datetime-local format
                    const startDate = new Date(filterData.startDate);
                    const endDate = new Date(filterData.endDate);

                    // Set date inputs
                    document.getElementById('customStartDate').value = formatDateTimeLocal(startDate);
                    document.getElementById('customEndDate').value = formatDateTimeLocal(endDate);

                    // Update label with date range or campaign name
                    const label = document.getElementById('activeCampaignLabel');
                    if (label) {
                        if (filterData.campaignName) {
                            label.innerHTML = `<i class="fas fa-bullhorn"></i> ${filterData.campaignName}`;
                        } else {
                            const startDisplay = startDate.toLocaleDateString('vi-VN');
                            const endDisplay = endDate.toLocaleDateString('vi-VN');
                            label.innerHTML = `<i class="fas fa-calendar-check"></i> ${startDisplay} - ${endDisplay}`;
                        }
                    }

                    // Fetch orders with saved dates (use window.fetchOrders from tab1-campaign.js)
                    if (typeof window.fetchOrders === 'function') {
                        await window.fetchOrders();
                    } else if (typeof fetchOrders === 'function') {
                        await fetchOrders();
                    }
                    return;
                }
            } catch (e) {
                console.warn('[APP] Error parsing saved filter data:', e);
            }
        }

        if (Object.keys(campaigns).length === 0) {
            // No campaigns exist
            console.log('[APP] No campaigns found, showing create modal...');
            showNoCampaignsModal();
            return;
        }

        // 5. Auto-select the most recent campaign (by creation time or name)
        const campaignEntries = Object.entries(campaigns);
        // Sort by timestamp in ID (campaign_TIMESTAMP) or by customStartDate
        campaignEntries.sort((a, b) => {
            // Extract timestamp from ID if format is campaign_TIMESTAMP
            const timestampA = parseInt(a[0].replace('campaign_', '')) || 0;
            const timestampB = parseInt(b[0].replace('campaign_', '')) || 0;
            return timestampB - timestampA; // Most recent first
        });

        const [latestCampaignId, latestCampaign] = campaignEntries[0];
        console.log('[APP] Auto-selecting most recent campaign:', latestCampaign.name);

        // Check if campaign has dates
        if (latestCampaign.customStartDate) {
            // Save as active and load
            await saveActiveCampaign(latestCampaignId);
            await continueAfterCampaignSelect(latestCampaignId);
        } else {
            // Campaign doesn't have dates, show modal to set dates
            console.log('[APP] Most recent campaign has no dates, showing modal...');
            showCampaignNoDatesModal(latestCampaignId);
        }

    } catch (error) {
        console.error('[APP] âŒ Initialization error:', error);
        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i khá»Ÿi táº¡o: ' + error.message);
        }
    }
}

/**
 * Get current user ID (helper)
 */
function getCurrentUserId() {
    // Try to get from Firebase auth
    if (typeof firebase !== 'undefined' && firebase.auth && firebase.auth().currentUser) {
        return firebase.auth().currentUser.uid;
    }
    // Fallback to localStorage or generate one
    let userId = localStorage.getItem('campaign_user_id');
    if (!userId) {
        userId = 'user_' + Date.now();
        localStorage.setItem('campaign_user_id', userId);
    }
    return userId;
}

/**
 * Load active campaign ID from Firebase
 */
async function loadActiveCampaignId() {
    try {
        const db = firebase.database();
        const userId = window.campaignManager.currentUserId;
        const snapshot = await db.ref(`user_preferences/${userId}/activeCampaignId`).once('value');
        const activeCampaignId = snapshot.val();

        window.campaignManager.activeCampaignId = activeCampaignId;
        if (activeCampaignId && window.campaignManager.allCampaigns[activeCampaignId]) {
            window.campaignManager.activeCampaign = window.campaignManager.allCampaigns[activeCampaignId];
        }

        return activeCampaignId;
    } catch (error) {
        console.error('[APP] Error loading active campaign:', error);
        return null;
    }
}

/**
 * Continue after user selects/creates a campaign
 * This function handles:
 * - Setting dates from campaign
 * - Updating UI
 * - Fetching orders (1 time only)
 * - Connecting realtime
 */
async function continueAfterCampaignSelect(campaignId) {
    try {
        console.log('[APP] continueAfterCampaignSelect:', campaignId);

        const campaign = window.campaignManager.allCampaigns[campaignId];
        if (!campaign) {
            console.error('[APP] Campaign not found:', campaignId);
            return;
        }

        // Set global state
        window.campaignManager.activeCampaignId = campaignId;
        window.campaignManager.activeCampaign = campaign;
        window.campaignManager.initialized = true;

        // Get dates from campaign
        const startDate = campaign.customStartDate;
        const endDate = campaign.customEndDate || '';

        // Set dates to all input fields
        const customStartDateInput = document.getElementById('customStartDate');
        const customEndDateInput = document.getElementById('customEndDate');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const modalCustomStartDate = document.getElementById('modalCustomStartDate');
        const modalCustomEndDate = document.getElementById('modalCustomEndDate');

        if (customStartDateInput) customStartDateInput.value = startDate;
        if (customEndDateInput) customEndDateInput.value = endDate;
        if (startDateInput) startDateInput.value = startDate;
        if (endDateInput) endDateInput.value = endDate;
        if (modalCustomStartDate) modalCustomStartDate.value = startDate;
        if (modalCustomEndDate) modalCustomEndDate.value = endDate;

        console.log('[APP] Dates set:', startDate, '->', endDate);

        // Set selectedCampaign to custom mode
        selectedCampaign = { isCustom: true };

        // Update UI label
        updateActiveCampaignLabel(campaign.name);

        // Update modal dropdown
        const modalSelect = document.getElementById('modalUserCampaignSelect');
        if (modalSelect) {
            modalSelect.value = campaignId;
        }

        // Show notification
        if (window.notificationManager) {
            const startDisplay = new Date(startDate).toLocaleDateString('vi-VN');
            const endDisplay = endDate ? new Date(endDate).toLocaleDateString('vi-VN') : 'N/A';
            window.notificationManager.info(
                `Äang táº£i Ä‘Æ¡n hÃ ng: ${startDisplay} - ${endDisplay}`,
                2000
            );
        }

        // â­ FETCH ORDERS (1 láº§n duy nháº¥t)
        console.log('[APP] â­ Fetching orders...');
        await handleSearch();

        // Connect realtime
        if (window.realtimeManager) {
            console.log('[APP] Connecting to Realtime Server...');
            window.realtimeManager.connectServerMode();
        }

        console.log('[APP] âœ… Initialization complete for campaign:', campaign.name);

    } catch (error) {
        console.error('[APP] âŒ Error in continueAfterCampaignSelect:', error);
        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i táº£i chiáº¿n dá»‹ch: ' + error.message);
        }
    }
}

/**
 * Update active campaign label in UI
 */
function updateActiveCampaignLabel(name) {
    const label = document.getElementById('activeCampaignLabel');
    if (label) {
        label.innerHTML = `<i class="fas fa-bullhorn"></i> ${name}`;
    }
}
// Export to window for inline HTML scripts
window.updateActiveCampaignLabel = updateActiveCampaignLabel;

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                   SECTION 4: EMPLOYEE RANGE MANAGEMENT                      â•‘
// â•‘                            search: #EMPLOYEE                                â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// EMPLOYEE RANGE MANAGEMENT FUNCTIONS #EMPLOYEE
// =====================================================
async function loadAndRenderEmployeeTable() {
    try {
        // Initialize user loader
        if (window.userEmployeeLoader) {
            await window.userEmployeeLoader.initialize();
            const users = await window.userEmployeeLoader.loadUsers();

            if (users.length > 0) {
                renderEmployeeTable(users);
            } else {
                console.warn('[EMPLOYEE] No users found');
                const tbody = document.getElementById('employeeAssignmentBody');
                tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: #ef4444;"><i class="fas fa-exclamation-triangle"></i> KhÃ´ng tÃ¬m tháº¥y nhÃ¢n viÃªn nÃ o</td></tr>';
            }
        } else {
            console.error('[EMPLOYEE] userEmployeeLoader not available');
        }
    } catch (error) {
        console.error('[EMPLOYEE] Error loading employee table:', error);
        const tbody = document.getElementById('employeeAssignmentBody');
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: #ef4444;">Lá»—i táº£i danh sÃ¡ch nhÃ¢n viÃªn</td></tr>';
    }
}

function renderEmployeeTable(users) {
    const tbody = document.getElementById('employeeAssignmentBody');

    // Use global employeeRanges which is synced from Firebase
    let savedRanges = {};
    if (employeeRanges && employeeRanges.length > 0) {
        employeeRanges.forEach(range => {
            savedRanges[range.name] = { start: range.start, end: range.end };
        });
    }

    // Render table rows
    let html = '';
    users.forEach(user => {
        const savedRange = savedRanges[user.displayName] || { start: '', end: '' };

        html += `
            <tr>
                <td style="padding: 8px;">${user.displayName}</td>
                <td style="padding: 8px; text-align: center;">
                    <input type="number"
                        class="employee-range-input"
                        data-user-id="${user.id}"
                        data-user-name="${user.displayName}"
                        data-field="start"
                        value="${savedRange.start}"
                        placeholder="Tá»«"
                        style="width: 80px; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 4px; text-align: center;">
                </td>
                <td style="padding: 8px; text-align: center;">
                    <input type="number"
                        class="employee-range-input"
                        data-user-id="${user.id}"
                        data-user-name="${user.displayName}"
                        data-field="end"
                        value="${savedRange.end}"
                        placeholder="Äáº¿n"
                        style="width: 80px; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 4px; text-align: center;">
                </td>
            </tr>
        `;
    });

    tbody.innerHTML = html;
}

// Sanitize campaign name for Firebase path (remove invalid chars: . $ # [ ] /)
function sanitizeCampaignName(campaignName) {
    if (!campaignName) return null;
    // Replace invalid Firebase key characters with underscore
    // Note: Forward slash (/) must be replaced to match tab-overview.html sanitization
    return campaignName
        .replace(/[.$#\[\]\/]/g, '_')
        .trim();
}

function applyEmployeeRanges() {
    const inputs = document.querySelectorAll('.employee-range-input');
    const rangesMap = {};

    // Collect ranges from inputs
    inputs.forEach(input => {
        const userName = input.getAttribute('data-user-name');
        const field = input.getAttribute('data-field');
        const value = input.value.trim();

        if (!rangesMap[userName]) {
            rangesMap[userName] = {};
        }

        rangesMap[userName][field] = value ? parseInt(value) : null;
    });

    // Build employee ranges array
    const newRanges = [];

    Object.keys(rangesMap).forEach(userName => {
        const range = rangesMap[userName];

        // Only include if both start and end are filled
        if (range.start !== null && range.end !== null && range.start > 0 && range.end > 0) {
            // Find user ID from input attribute
            const input = document.querySelector(`.employee-range-input[data-user-name="${userName}"]`);
            const userId = input ? input.getAttribute('data-user-id') : null;

            newRanges.push({
                id: userId,
                name: userName,
                start: range.start,
                end: range.end
            });
        }
    });

    // Determine save logic based on selected campaign
    const campaignSelector = document.getElementById('employeeCampaignSelector');
    let campaignInfo = '(cáº¥u hÃ¬nh chung)';

    if (campaignSelector && campaignSelector.value) {
        // Get selected campaign data
        const selectedOption = campaignSelector.options[campaignSelector.selectedIndex];
        if (selectedOption && selectedOption.dataset.campaign) {
            const campaign = JSON.parse(selectedOption.dataset.campaign);
            const sanitizedName = sanitizeCampaignName(campaign.displayName);
            campaignInfo = `cho chiáº¿n dá»‹ch "${campaign.displayName}"`;

            console.log(`[EMPLOYEE] Saving ranges for campaign: ${campaign.displayName} (key: ${sanitizedName})`);

            // Load current campaign configs, update the specific campaign, then save
            if (database) {
                database.ref('settings/employee_ranges_by_campaign').once('value')
                    .then((snapshot) => {
                        const allCampaignRanges = snapshot.val() || {};

                        // Update this campaign's ranges
                        allCampaignRanges[sanitizedName] = newRanges;

                        // Save back to Firebase
                        return database.ref('settings/employee_ranges_by_campaign').set(allCampaignRanges);
                    })
                    .then(() => {
                        if (window.notificationManager) {
                            window.notificationManager.show(`âœ… ÄÃ£ lÆ°u phÃ¢n chia cho ${newRanges.length} nhÃ¢n viÃªn ${campaignInfo}`, 'success');
                        } else {
                            alert(`âœ… ÄÃ£ lÆ°u phÃ¢n chia cho ${newRanges.length} nhÃ¢n viÃªn ${campaignInfo}`);
                        }
                        toggleEmployeeDrawer();
                    })
                    .catch((error) => {
                        console.error('[EMPLOYEE] Error saving ranges to Firebase:', error);
                        alert('âŒ Lá»—i khi lÆ°u lÃªn Firebase: ' + error.message);
                    });
            } else {
                alert('âŒ Lá»—i: KhÃ´ng thá»ƒ káº¿t ná»‘i Firebase');
            }
            return; // Exit early for campaign-specific save
        }
    }

    // Save general config (default path)
    if (database) {
        database.ref('settings/employee_ranges').set(newRanges)
            .then(() => {
                if (window.notificationManager) {
                    window.notificationManager.show(`âœ… ÄÃ£ lÆ°u phÃ¢n chia cho ${newRanges.length} nhÃ¢n viÃªn ${campaignInfo}`, 'success');
                } else {
                    alert(`âœ… ÄÃ£ lÆ°u phÃ¢n chia cho ${newRanges.length} nhÃ¢n viÃªn ${campaignInfo}`);
                }
                toggleEmployeeDrawer();
            })
            .catch((error) => {
                console.error('[EMPLOYEE] Error saving ranges to Firebase:', error);
                alert('âŒ Lá»—i khi lÆ°u lÃªn Firebase: ' + error.message);
            });
    } else {
        alert('âŒ Lá»—i: KhÃ´ng thá»ƒ káº¿t ná»‘i Firebase');
    }
}

function getEmployeeName(stt) {
    if (!stt || employeeRanges.length === 0) return null;

    const sttNum = parseInt(stt);
    if (isNaN(sttNum)) return null;

    for (const range of employeeRanges) {
        if (sttNum >= range.start && sttNum <= range.end) {
            return range.name;
        }
    }

    return null;
}

function populateEmployeeCampaignSelector() {
    const select = document.getElementById('employeeCampaignSelector');
    if (!select) return;

    // Get campaigns from the main campaign filter
    const mainCampaignSelect = document.getElementById('campaignFilter');
    if (!mainCampaignSelect) {
        console.log('[EMPLOYEE] Main campaign filter not found');
        return;
    }

    // Clear and add default option
    select.innerHTML = '<option value="">Cáº¥u hÃ¬nh chung (táº¥t cáº£ chiáº¿n dá»‹ch)</option>';

    // Copy campaigns from main filter
    const options = mainCampaignSelect.querySelectorAll('option');
    options.forEach(option => {
        if (option.value !== '') {
            const newOption = document.createElement('option');
            newOption.value = option.value;
            newOption.textContent = option.textContent;
            newOption.dataset.campaign = option.dataset.campaign;
            select.appendChild(newOption);
        }
    });

    console.log(`[EMPLOYEE] Populated campaign selector with ${select.options.length - 1} campaigns`);
}

function toggleEmployeeDrawer() {
    const drawer = document.getElementById('employeeDrawer');
    const overlay = document.getElementById('employeeDrawerOverlay');

    if (drawer && overlay) {
        const isActive = drawer.classList.contains('active');

        if (isActive) {
            // Close drawer
            drawer.classList.remove('active');
            overlay.classList.remove('active');
        } else {
            // Open drawer - Reload table to show latest data
            populateEmployeeCampaignSelector();
            loadAndRenderEmployeeTable();
            drawer.classList.add('active');
            overlay.classList.add('active');
        }
    }
}

function toggleControlBar() {
    const controlBar = document.getElementById('controlBar');
    const btn = document.getElementById('toggleControlBarBtn');

    if (controlBar && btn) {
        const isHidden = controlBar.style.display === 'none';

        if (isHidden) {
            controlBar.style.display = 'flex'; // Or 'block' depending on layout, but flex is used in inline style in html sometimes. Let's check original css. 
            // The original div.filter-section likely has display: flex in CSS. 
            // Let's assume removing style.display will revert to CSS class definition, or set to '' to clear inline style.
            controlBar.style.display = '';

            btn.innerHTML = '<i class="fas fa-sliders-h"></i> áº¨n bá»™ lá»c';
        } else {
            controlBar.style.display = 'none';
            btn.innerHTML = '<i class="fas fa-sliders-h"></i> Hiá»ƒn thá»‹ bá»™ lá»c';
        }
    }
}

function checkAdminPermission() {
    const btn = document.getElementById('employeeSettingsBtn');
    if (btn) {
        // Check if user has admin permissions via detailedPermissions
        const auth = window.authManager ? window.authManager.getAuthState() : null;
        const hasAdminAccess = auth?.detailedPermissions?.['baocaosaleonline']?.['viewRevenue'] === true ||
            auth?.roleTemplate === 'admin';
        if (!hasAdminAccess) {
            btn.style.display = 'none';
        } else {
            btn.style.display = 'inline-flex';
        }
    }
}

// Helper function to convert Firebase object to array if needed
function normalizeEmployeeRanges(data) {
    if (!data) return [];

    // If already an array, return it
    if (Array.isArray(data)) {
        return data;
    }

    // If it's an object, convert to array
    if (typeof data === 'object') {
        const result = [];
        // Get all numeric keys and sort them
        const keys = Object.keys(data).filter(k => !isNaN(k)).sort((a, b) => Number(a) - Number(b));
        for (const key of keys) {
            result.push(data[key]);
        }
        console.log(`[EMPLOYEE] Converted object with ${keys.length} keys to array`);
        return result;
    }

    return [];
}

function loadEmployeeRangesForCampaign(campaignName = null) {
    if (!database) {
        console.log('[EMPLOYEE] Database not initialized');
        return Promise.resolve();
    }

    if (campaignName) {
        // Load from campaign-specific config (object with campaign names as keys)
        const sanitizedName = sanitizeCampaignName(campaignName);
        console.log(`[EMPLOYEE] Loading ranges for campaign: ${campaignName} (key: ${sanitizedName})`);

        return database.ref('settings/employee_ranges_by_campaign').once('value')
            .then((snapshot) => {
                const allCampaignRanges = snapshot.val() || {};
                const data = allCampaignRanges[sanitizedName];
                const normalized = normalizeEmployeeRanges(data);

                if (normalized.length > 0) {
                    employeeRanges = normalized;
                    console.log(`[EMPLOYEE] âœ… Loaded ${employeeRanges.length} ranges for campaign: ${campaignName}`);
                } else {
                    // If no campaign-specific ranges found, fall back to general config
                    console.log('[EMPLOYEE] No campaign-specific ranges found, falling back to general config');
                    return database.ref('settings/employee_ranges').once('value')
                        .then((snapshot) => {
                            employeeRanges = normalizeEmployeeRanges(snapshot.val());
                            console.log(`[EMPLOYEE] âœ… Loaded ${employeeRanges.length} ranges from general config (fallback)`);
                        });
                }

                // Update employee table if drawer is open
                const drawer = document.getElementById('employeeDrawer');
                if (drawer && drawer.classList.contains('active')) {
                    loadAndRenderEmployeeTable();
                }
            })
            .catch((error) => {
                console.error('[EMPLOYEE] Error loading ranges:', error);
            });
    } else {
        // Load general config
        console.log('[EMPLOYEE] Loading general employee ranges');

        return database.ref('settings/employee_ranges').once('value')
            .then((snapshot) => {
                employeeRanges = normalizeEmployeeRanges(snapshot.val());
                console.log(`[EMPLOYEE] âœ… Loaded ${employeeRanges.length} ranges from general config`);

                // Update employee table if drawer is open
                const drawer = document.getElementById('employeeDrawer');
                if (drawer && drawer.classList.contains('active')) {
                    loadAndRenderEmployeeTable();
                }
            })
            .catch((error) => {
                console.error('[EMPLOYEE] Error loading ranges:', error);
            });
    }
}

function syncEmployeeRanges() {
    if (!database) return;

    const rangesRef = database.ref('settings/employee_ranges');
    rangesRef.on('value', (snapshot) => {
        const data = snapshot.val();
        employeeRanges = normalizeEmployeeRanges(data);
        console.log(`[EMPLOYEE] Synced ${employeeRanges.length} ranges from Firebase`);

        // Re-apply filter to current view
        performTableSearch();
    });
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                        SECTION 5: TAG MANAGEMENT                            â•‘
// â•‘                            search: #TAG                                     â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// TAG MANAGEMENT FUNCTIONS #TAG
// =====================================================

// Helper function to fetch all tags with pagination (TPOS max $top=1000)
async function fetchAllTagsWithPagination(headers) {
    const PAGE_SIZE = 1000;
    let allTags = [];
    let skip = 0;
    let totalCount = 0;

    // First request to get count and first batch
    const firstResponse = await API_CONFIG.smartFetch(
        `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag?$top=${PAGE_SIZE}&$skip=0&$count=true`,
        {
            method: "GET",
            headers: {
                ...headers,
                accept: "application/json",
                "content-type": "application/json",
            },
        },
    );

    if (!firstResponse.ok) {
        throw new Error(`HTTP ${firstResponse.status}`);
    }

    const firstData = await firstResponse.json();
    allTags = firstData.value || [];
    totalCount = firstData["@odata.count"] || allTags.length;

    console.log(`[TAG] First batch: ${allTags.length} tags, total count: ${totalCount}`);

    // If more tags exist, fetch remaining with pagination
    if (totalCount > PAGE_SIZE) {
        skip = PAGE_SIZE;

        while (skip < totalCount) {
            console.log(`[TAG] Fetching more tags with skip=${skip}...`);

            const response = await API_CONFIG.smartFetch(
                `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag?$top=${PAGE_SIZE}&$skip=${skip}&$count=true`,
                {
                    method: "GET",
                    headers: {
                        ...headers,
                        accept: "application/json",
                        "content-type": "application/json",
                    },
                },
            );

            if (!response.ok) {
                throw new Error(`HTTP ${response.status} at skip=${skip}`);
            }

            const data = await response.json();
            const batchTags = data.value || [];

            if (batchTags.length === 0) {
                break; // No more tags
            }

            allTags = allTags.concat(batchTags);
            skip += PAGE_SIZE;

            console.log(`[TAG] Fetched ${batchTags.length} more tags, total now: ${allTags.length}`);
        }
    }

    console.log(`[TAG] Pagination complete: ${allTags.length}/${totalCount} tags fetched`);
    return allTags;
}

async function loadAvailableTags() {
    try {
        const cached = window.cacheManager.get("tags", "tags");
        if (cached) {
            console.log("[TAG] Using cached tags");
            availableTags = cached;
            window.availableTags = availableTags; // Export to window
            populateTagFilter(); // Populate filter dropdown
            return;
        }

        console.log("[TAG] Loading tags from API...");
        const headers = await window.tokenManager.getAuthHeader();

        // Use pagination helper to fetch all tags
        availableTags = await fetchAllTagsWithPagination(headers);

        window.availableTags = availableTags; // Export to window
        window.cacheManager.set("tags", availableTags, "tags");
        console.log(`[TAG] Loaded ${availableTags.length} tags from API`);
        populateTagFilter(); // Populate filter dropdown
    } catch (error) {
        console.error("[TAG] Error loading tags:", error);
        availableTags = [];
        window.availableTags = availableTags; // Export to window
    }
}

async function refreshTags() {
    const btn = document.querySelector('.tag-btn-refresh');
    const icon = btn ? btn.querySelector('i') : null;

    try {
        if (btn) btn.disabled = true;
        if (icon) icon.classList.add('fa-spin');

        console.log("[TAG] Refreshing tags from TPOS...");
        const headers = await window.tokenManager.getAuthHeader();

        // Use pagination helper to fetch all tags (TPOS max $top=1000)
        const newTags = await fetchAllTagsWithPagination(headers);

        console.log(`[TAG] Fetched ${newTags.length} tags from TPOS`);

        // Save to Firebase
        if (database) {
            await database.ref('settings/tags').set(newTags);
            console.log('[TAG] Saved tags to Firebase settings/tags');
        }

        // Update local state
        availableTags = newTags;
        window.availableTags = availableTags;
        window.cacheManager.set("tags", availableTags, "tags");

        // Update UI
        populateTagFilter();

        // Clear search input and render full tag list
        const searchInput = document.getElementById("tagSearchInput");
        if (searchInput) {
            searchInput.value = "";
        }

        // Update current order tags with new tag info (if modal is open)
        if (currentOrderTags && currentOrderTags.length > 0) {
            currentOrderTags = currentOrderTags.map(selectedTag => {
                const updatedTag = newTags.find(t => t.Id === selectedTag.Id);
                return updatedTag ? { Id: updatedTag.Id, Name: updatedTag.Name, Color: updatedTag.Color } : selectedTag;
            });
            updateSelectedTagsDisplay();
        }

        // Render tag list without search filter
        renderTagList("");

        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ cáº­p nháº­t ${newTags.length} tags thÃ nh cÃ´ng!`);
        } else {
            alert(`âœ… ÄÃ£ cáº­p nháº­t ${newTags.length} tags thÃ nh cÃ´ng!`);
        }

    } catch (error) {
        console.error("[TAG] Error refreshing tags:", error);
        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i cáº­p nháº­t tags: ${error.message}`);
        } else {
            alert(`âŒ Lá»—i cáº­p nháº­t tags: ${error.message}`);
        }
    } finally {
        if (btn) btn.disabled = false;
        if (icon) icon.classList.remove('fa-spin');
    }
}

// Open Create Tag Modal
function openCreateTagModal() {
    const modal = document.getElementById('createTagModal');
    if (modal) {
        modal.style.display = 'flex';

        // Reset form
        document.getElementById('newTagName').value = '';
        document.getElementById('newTagColor').value = '#3b82f6';
        document.getElementById('newTagColorHex').value = '#3b82f6';
        document.getElementById('colorPreview').style.background = '#3b82f6';

        // Hide status message
        const status = document.getElementById('createTagStatus');
        if (status) {
            status.style.display = 'none';
        }

        // Setup color input sync (only once)
        const colorInput = document.getElementById('newTagColor');
        if (colorInput && !colorInput.dataset.listenerAdded) {
            colorInput.addEventListener('input', function () {
                const color = this.value;
                document.getElementById('newTagColorHex').value = color;
                document.getElementById('colorPreview').style.background = color;
            });
            colorInput.dataset.listenerAdded = 'true';
        }

        // Focus on name input
        setTimeout(() => {
            document.getElementById('newTagName').focus();
        }, 100);
    }
}

// Close Create Tag Modal
function closeCreateTagModal() {
    const modal = document.getElementById('createTagModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Generate Random Color for auto-create tag
function generateRandomColor() {
    const colors = [
        '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
        '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9',
        '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
        '#ec4899', '#f43f5e', '#78716c', '#737373', '#71717a'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
}

// Auto-create tag when search yields no results and user presses Enter
async function autoCreateAndAddTag(tagName) {
    if (!tagName || tagName.trim() === '') return;

    const name = tagName.trim().toUpperCase(); // Convert to uppercase for consistency
    const color = generateRandomColor();

    try {
        // Show loading notification
        if (window.notificationManager) {
            window.notificationManager.info(`Äang táº¡o tag "${name}"...`);
        }

        console.log('[AUTO-CREATE-TAG] Creating tag:', { name, color });

        // Get auth headers
        const headers = await window.tokenManager.getAuthHeader();

        // Create tag via API
        const response = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag',
            {
                method: 'POST',
                headers: {
                    ...headers,
                    'accept': 'application/json, text/plain, */*',
                    'content-type': 'application/json;charset=UTF-8',
                },
                body: JSON.stringify({
                    Name: name,
                    Color: color
                })
            }
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const newTag = await response.json();
        console.log('[AUTO-CREATE-TAG] Tag created successfully:', newTag);

        // Remove @odata.context from newTag (Firebase doesn't allow keys with dots)
        if (newTag['@odata.context']) {
            delete newTag['@odata.context'];
        }

        // Update local tags list
        if (Array.isArray(availableTags)) {
            availableTags.push(newTag);
            window.availableTags = availableTags;
            window.cacheManager.set("tags", availableTags, "tags");
        }

        // Save to Firebase
        if (database) {
            await database.ref('settings/tags').set(availableTags);
            console.log('[AUTO-CREATE-TAG] Saved updated tags to Firebase');
        }

        // Update filter dropdowns
        populateTagFilter();

        // Add the new tag to current selection
        currentOrderTags.push({
            Id: newTag.Id,
            Name: newTag.Name,
            Color: newTag.Color
        });

        // Clear search input and update UI
        const searchInput = document.getElementById("tagSearchInput");
        if (searchInput) {
            searchInput.value = "";
        }
        updateSelectedTagsDisplay();
        renderTagList("");

        // Show success notification
        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ táº¡o vÃ  thÃªm tag "${name}"!`);
        }

        console.log('[AUTO-CREATE-TAG] Tag added to order selection');

    } catch (error) {
        console.error('[AUTO-CREATE-TAG] Error creating tag:', error);
        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i táº¡o tag: ' + error.message);
        }
    }
}

// =====================================================
// QUICK TAG FEATURE - Load user identifier and quick assign
// =====================================================

/**
 * Load current user identifier from Firestore
 */
async function loadCurrentUserIdentifier() {
    try {
        const auth = window.authManager ? window.authManager.getAuthState() : null;
        if (!auth || !auth.username) {
            console.warn('[QUICK-TAG] No auth or username available');
            return;
        }

        // Get Firestore instance
        const db = firebase.firestore();
        if (!db) {
            console.warn('[QUICK-TAG] Firestore not available');
            return;
        }

        // Load user data from Firestore
        const userDoc = await db.collection('users').doc(auth.username).get();
        if (userDoc.exists) {
            const userData = userDoc.data();
            currentUserIdentifier = userData.identifier || null;
            console.log('[QUICK-TAG] Loaded user identifier:', currentUserIdentifier);
        } else {
            console.warn('[QUICK-TAG] User document not found:', auth.username);
        }
    } catch (error) {
        console.error('[QUICK-TAG] Error loading user identifier:', error);
    }
}

/**
 * Quick assign tag to order
 * @param {string} orderId - Order ID
 * @param {string} orderCode - Order code for display
 * @param {string} tagPrefix - Tag prefix ("xá»­ lÃ½" or "ok")
 */
async function quickAssignTag(orderId, orderCode, tagPrefix) {
    // Check if identifier is loaded
    if (!currentUserIdentifier) {
        if (window.notificationManager) {
            window.notificationManager.warning('ChÆ°a cÃ³ tÃªn Ä‘á»‹nh danh. Vui lÃ²ng cáº­p nháº­t trong Quáº£n lÃ½ User.');
        }
        return;
    }

    const tagName = `${tagPrefix} ${currentUserIdentifier}`.toUpperCase();

    try {
        // Show loading
        if (window.notificationManager) {
            window.notificationManager.info(`Äang gÃ¡n tag "${tagName}"...`);
        }

        // Check if tag exists in availableTags
        let existingTag = availableTags.find(t => t.Name.toUpperCase() === tagName);

        // If tag doesn't exist in local cache, fetch fresh tags from API first
        if (!existingTag) {
            console.log('[QUICK-TAG] Tag not found in local cache, fetching fresh tags from API...');
            const headers = await window.tokenManager.getAuthHeader();

            // Fetch fresh tags to ensure we have the latest list
            try {
                const tagsResponse = await API_CONFIG.smartFetch(
                    'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag?$format=json&$count=true&$top=1000',
                    {
                        method: 'GET',
                        headers: {
                            ...headers,
                            'accept': 'application/json',
                            'content-type': 'application/json',
                        },
                    }
                );

                if (tagsResponse.ok) {
                    const tagsData = await tagsResponse.json();
                    availableTags = tagsData.value || [];
                    window.availableTags = availableTags;
                    window.cacheManager.set("tags", availableTags, "tags");
                    console.log(`[QUICK-TAG] Refreshed ${availableTags.length} tags from API`);

                    // Check again after refresh
                    existingTag = availableTags.find(t => t.Name.toUpperCase() === tagName);
                    if (existingTag) {
                        console.log('[QUICK-TAG] Found tag after refresh:', existingTag.Name);
                    }
                }
            } catch (fetchError) {
                console.warn('[QUICK-TAG] Failed to fetch fresh tags:', fetchError);
            }
        }

        // If tag still doesn't exist after refresh, create it
        if (!existingTag) {
            console.log('[QUICK-TAG] Tag not found after refresh, creating:', tagName);
            const color = generateRandomColor();
            const headers = await window.tokenManager.getAuthHeader();

            const createResponse = await API_CONFIG.smartFetch(
                'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag',
                {
                    method: 'POST',
                    headers: {
                        ...headers,
                        'accept': 'application/json, text/plain, */*',
                        'content-type': 'application/json;charset=UTF-8',
                    },
                    body: JSON.stringify({
                        Name: tagName,
                        Color: color
                    })
                }
            );

            if (!createResponse.ok) {
                throw new Error(`Lá»—i táº¡o tag: ${createResponse.status}`);
            }

            existingTag = await createResponse.json();

            // Remove @odata.context
            if (existingTag['@odata.context']) {
                delete existingTag['@odata.context'];
            }

            // Update local tags list
            availableTags.push(existingTag);
            window.availableTags = availableTags;
            window.cacheManager.set("tags", availableTags, "tags");

            // Save to Firebase
            if (database) {
                await database.ref('settings/tags').set(availableTags);
            }

            // Update dropdowns
            populateTagFilter();

            console.log('[QUICK-TAG] Created new tag:', existingTag);
        }

        // Get current order from data
        const order = allData.find(o => o.Id === orderId);
        if (!order) {
            throw new Error('KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng');
        }

        // Parse existing tags
        let orderTags = [];
        try {
            if (order.Tags) {
                orderTags = JSON.parse(order.Tags);
                if (!Array.isArray(orderTags)) orderTags = [];
            }
        } catch (e) {
            orderTags = [];
        }

        // Remove opposite tag if exists (xá»­ lÃ½ <-> ok)
        const oppositePrefix = tagPrefix.toLowerCase() === 'xá»­ lÃ½' ? 'OK' : 'Xá»¬ LÃ';
        const oppositeTagName = `${oppositePrefix} ${currentUserIdentifier}`.toUpperCase();
        const oppositeTagIndex = orderTags.findIndex(t => t.Name && t.Name.toUpperCase() === oppositeTagName);

        if (oppositeTagIndex !== -1) {
            const removedTag = orderTags[oppositeTagIndex];
            orderTags.splice(oppositeTagIndex, 1);
            console.log('[QUICK-TAG] Removed opposite tag:', removedTag.Name);
        }

        // Check if tag already assigned
        if (orderTags.some(t => t.Id === existingTag.Id)) {
            if (window.notificationManager) {
                window.notificationManager.info(`Tag "${tagName}" Ä‘Ã£ Ä‘Æ°á»£c gÃ¡n cho Ä‘Æ¡n nÃ y rá»“i.`);
            }
            return;
        }

        // Add new tag to order tags
        orderTags.push({
            Id: existingTag.Id,
            Name: existingTag.Name,
            Color: existingTag.Color
        });

        // Assign tag via API
        const headers = await window.tokenManager.getAuthHeader();
        const assignResponse = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag',
            {
                method: 'POST',
                headers: {
                    ...headers,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                },
                body: JSON.stringify({
                    Tags: orderTags.map(t => ({ Id: t.Id, Color: t.Color, Name: t.Name })),
                    OrderId: orderId
                })
            }
        );

        if (!assignResponse.ok) {
            throw new Error(`Lá»—i gÃ¡n tag: ${assignResponse.status}`);
        }

        // Update order in table
        const updatedData = { Tags: JSON.stringify(orderTags) };
        updateOrderInTable(orderId, updatedData);

        // Emit Firebase realtime update
        await emitTagUpdateToFirebase(orderId, orderTags);

        // Clear cache
        window.cacheManager.clear("orders");

        // Success notification
        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ gÃ¡n tag "${tagName}" cho Ä‘Æ¡n ${orderCode}!`, 2000);
        }

        console.log('[QUICK-TAG] Tag assigned successfully:', tagName, 'to order:', orderCode);

    } catch (error) {
        console.error('[QUICK-TAG] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i: ${error.message}`);
        }
    }
}

/**
 * Quick remove tag from order
 * @param {string} orderId - Order ID
 * @param {string} orderCode - Order code for display
 * @param {string} tagId - Tag ID to remove
 */
async function quickRemoveTag(orderId, orderCode, tagId) {
    try {
        console.log('[QUICK-TAG] Removing tag:', { orderId, orderCode, tagId });

        // Get current order from data
        const order = allData.find(o => o.Id === orderId);
        if (!order) {
            throw new Error('KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng');
        }

        // Parse existing tags
        let orderTags = [];
        try {
            if (order.Tags) {
                orderTags = JSON.parse(order.Tags);
                if (!Array.isArray(orderTags)) orderTags = [];
            }
        } catch (e) {
            orderTags = [];
        }

        console.log('[QUICK-TAG] Current tags:', orderTags);

        // Find tag to remove (compare as string to handle both number and string IDs)
        const tagIdStr = String(tagId);
        const tagToRemove = orderTags.find(t => String(t.Id) === tagIdStr);
        if (!tagToRemove) {
            console.warn('[QUICK-TAG] Tag not found in order:', tagId, 'Available:', orderTags.map(t => t.Id));
            return;
        }

        // Remove tag from list
        orderTags = orderTags.filter(t => String(t.Id) !== tagIdStr);

        // Show loading
        if (window.notificationManager) {
            window.notificationManager.info(`Äang xÃ³a tag "${tagToRemove.Name}"...`);
        }

        // Assign updated tags via API
        const headers = await window.tokenManager.getAuthHeader();
        const assignResponse = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag',
            {
                method: 'POST',
                headers: {
                    ...headers,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                },
                body: JSON.stringify({
                    Tags: orderTags.map(t => ({ Id: t.Id, Color: t.Color, Name: t.Name })),
                    OrderId: orderId
                })
            }
        );

        if (!assignResponse.ok) {
            throw new Error(`Lá»—i xÃ³a tag: ${assignResponse.status}`);
        }

        // Update order in table
        const updatedData = { Tags: JSON.stringify(orderTags) };
        updateOrderInTable(orderId, updatedData);

        // Emit Firebase realtime update
        await emitTagUpdateToFirebase(orderId, orderTags);

        // Clear cache
        window.cacheManager.clear("orders");

        // Success notification
        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ xÃ³a tag "${tagToRemove.Name}" khá»i Ä‘Æ¡n ${orderCode}!`, 2000);
        }

        console.log('[QUICK-TAG] Tag removed successfully:', tagToRemove.Name, 'from order:', orderCode);

    } catch (error) {
        console.error('[QUICK-TAG] Error removing tag:', error);
        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i: ${error.message}`);
        }
    }
}

// Update Color Preview
function updateColorPreview() {
    const hexInput = document.getElementById('newTagColorHex');
    const colorInput = document.getElementById('newTagColor');
    const preview = document.getElementById('colorPreview');

    let hex = hexInput.value.trim();

    // Add # if missing
    if (hex && !hex.startsWith('#')) {
        hex = '#' + hex;
    }

    // Validate hex color (3 or 6 digits)
    const validHex = /^#([0-9A-F]{3}){1,2}$/i.test(hex);

    if (validHex) {
        colorInput.value = hex;
        preview.style.background = hex;
        hexInput.style.borderColor = '#d1d5db';
    } else if (hex === '#') {
        // Just started typing
        hexInput.style.borderColor = '#d1d5db';
    } else {
        // Invalid hex
        hexInput.style.borderColor = '#ef4444';
    }
}

// Select Preset Color
function selectPresetColor(color) {
    document.getElementById('newTagColor').value = color;
    document.getElementById('newTagColorHex').value = color;
    document.getElementById('colorPreview').style.background = color;
}

// Create New Tag
async function createNewTag() {
    const nameInput = document.getElementById('newTagName');
    const colorInput = document.getElementById('newTagColor');
    const statusDiv = document.getElementById('createTagStatus');
    const createBtn = document.getElementById('createTagBtn');

    const name = nameInput.value.trim();
    const color = colorInput.value;

    // Validate
    if (!name) {
        statusDiv.innerHTML = '<i class="fas fa-exclamation-circle"></i> Vui lÃ²ng nháº­p tÃªn tag';
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#fef3c7';
        statusDiv.style.color = '#92400e';
        nameInput.focus();
        return;
    }

    // Validate color
    const validHex = /^#([0-9A-F]{3}){1,2}$/i.test(color);
    if (!validHex) {
        statusDiv.innerHTML = '<i class="fas fa-exclamation-circle"></i> MÃ u khÃ´ng há»£p lá»‡';
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#fef3c7';
        statusDiv.style.color = '#92400e';
        return;
    }

    try {
        // Disable button
        createBtn.disabled = true;
        createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Äang táº¡o...';

        // Show loading status
        statusDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Äang táº¡o tag...';
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#dbeafe';
        statusDiv.style.color = '#1e40af';

        console.log('[CREATE-TAG] Creating tag:', { name, color });

        // Get auth headers
        const headers = await window.tokenManager.getAuthHeader();

        // Create tag via API (through Cloudflare proxy)
        const response = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag',
            {
                method: 'POST',
                headers: {
                    ...headers,
                    'accept': 'application/json, text/plain, */*',
                    'content-type': 'application/json;charset=UTF-8',
                },
                body: JSON.stringify({
                    Name: name,
                    Color: color
                })
            }
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const newTag = await response.json();
        console.log('[CREATE-TAG] Tag created successfully:', newTag);

        // Remove @odata.context from newTag (Firebase doesn't allow keys with dots)
        if (newTag['@odata.context']) {
            delete newTag['@odata.context'];
            console.log('[CREATE-TAG] Removed @odata.context from newTag');
        }

        // Show success status
        statusDiv.innerHTML = '<i class="fas fa-check-circle"></i> Táº¡o tag thÃ nh cÃ´ng!';
        statusDiv.style.background = '#d1fae5';
        statusDiv.style.color = '#065f46';

        // Update local tags list
        if (Array.isArray(availableTags)) {
            availableTags.push(newTag);
            window.availableTags = availableTags;
            window.cacheManager.set("tags", availableTags, "tags");
        }

        // Save to Firebase
        if (database) {
            await database.ref('settings/tags').set(availableTags);
            console.log('[CREATE-TAG] Saved updated tags to Firebase');
        }

        // Update UI
        populateTagFilter();

        // Clear search and render updated tag list
        const searchInput = document.getElementById("tagSearchInput");
        if (searchInput) {
            searchInput.value = "";
        }
        renderTagList("");

        // Show notification
        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ táº¡o tag "${name}" thÃ nh cÃ´ng!`);
        }

        // Close modal after 1 second
        setTimeout(() => {
            closeCreateTagModal();
        }, 1000);

    } catch (error) {
        console.error('[CREATE-TAG] Error creating tag:', error);
        statusDiv.innerHTML = '<i class="fas fa-exclamation-circle"></i> Lá»—i: ' + error.message;
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#fee2e2';
        statusDiv.style.color = '#991b1b';

        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i táº¡o tag: ' + error.message);
        }
    } finally {
        // Re-enable button
        createBtn.disabled = false;
        createBtn.innerHTML = '<i class="fas fa-check"></i> Táº¡o tag';
    }
}

function populateTagFilter() {
    // Call the inline script function if available
    if (typeof populateTagFilterOptions === 'function') {
        populateTagFilterOptions();
    }
    console.log('[TAG-FILTER] populateTagFilter called');
}

function openTagModal(orderId, orderCode) {
    currentEditingOrderId = orderId;
    const order = allData.find((o) => o.Id === orderId);
    currentOrderTags = order && order.Tags ? JSON.parse(order.Tags) : [];

    renderTagList();
    updateSelectedTagsDisplay();
    document.getElementById("tagModal").classList.add("show");

    // Auto-refresh tags when modal opens
    refreshTags();

    // Focus on search input
    setTimeout(() => {
        document.getElementById("tagSearchInput").focus();
    }, 100);
}

function closeTagModal() {
    document.getElementById("tagModal").classList.remove("show");
    document.getElementById("tagSearchInput").value = "";
    currentEditingOrderId = null;
    currentOrderTags = [];
    pendingDeleteTagIndex = -1;
}

function renderTagList(searchQuery = "") {
    const tagList = document.getElementById("tagList");
    if (availableTags.length === 0) {
        tagList.innerHTML = `<div class="no-tags-message"><i class="fas fa-exclamation-circle"></i><p>KhÃ´ng cÃ³ tag nÃ o</p></div>`;
        return;
    }

    // Filter out selected tags and apply search query
    const filteredTags = availableTags.filter((tag) => {
        // Don't show already selected tags
        const isSelected = currentOrderTags.some((t) => t.Id === tag.Id);
        if (isSelected) return false;

        // Apply search filter
        if (!searchQuery) return true;
        const query = searchQuery.toLowerCase();
        return (
            tag.Name.toLowerCase().includes(query) ||
            tag.NameNosign.toLowerCase().includes(query)
        );
    });

    if (filteredTags.length === 0) {
        tagList.innerHTML = `<div class="no-tags-message"><i class="fas fa-search"></i><p>KhÃ´ng tÃ¬m tháº¥y tag phÃ¹ há»£p</p></div>`;
        return;
    }

    tagList.innerHTML = filteredTags
        .map((tag, index) => {
            const isFirstItem = index === 0;
            return `
            <div class="tag-dropdown-item ${isFirstItem ? 'highlighted' : ''}" onclick="toggleTag(${tag.Id})" data-tag-id="${tag.Id}">
                <div class="tag-item-name">${tag.Name}</div>
            </div>`;
        })
        .join("");
}

function toggleTag(tagId) {
    const tag = availableTags.find((t) => t.Id === tagId);
    if (!tag) return;

    const existingIndex = currentOrderTags.findIndex((t) => t.Id === tagId);
    if (existingIndex >= 0) {
        currentOrderTags.splice(existingIndex, 1);
    } else {
        currentOrderTags.push({ Id: tag.Id, Name: tag.Name, Color: tag.Color });
    }

    updateSelectedTagsDisplay();
    renderTagList(document.getElementById("tagSearchInput").value);
}

function updateSelectedTagsDisplay() {
    const container = document.getElementById("selectedTagsPills");
    if (currentOrderTags.length === 0) {
        container.innerHTML = '';
        pendingDeleteTagIndex = -1;
        return;
    }
    container.innerHTML = currentOrderTags
        .map(
            (tag, index) => {
                const isPendingDelete = index === pendingDeleteTagIndex;
                const bgColor = isPendingDelete ? '#ef4444' : '#3b82f6'; // Red if pending delete, blue otherwise
                return `
        <span class="selected-tag-pill ${isPendingDelete ? 'deletion-pending' : ''}" style="background-color: ${bgColor}" data-tag-index="${index}">
            ${tag.Name}
            <button class="selected-tag-remove" onclick="event.stopPropagation(); removeTag(${index})" title="XÃ³a tag">
                âœ•
            </button>
        </span>`;
            }
        )
        .join("");
}

function filterTags() {
    renderTagList(document.getElementById("tagSearchInput").value);
}

function removeTag(index) {
    if (index >= 0 && index < currentOrderTags.length) {
        currentOrderTags.splice(index, 1);
        pendingDeleteTagIndex = -1;
        updateSelectedTagsDisplay();
        renderTagList(document.getElementById("tagSearchInput").value);
    }
}

function handleTagInputKeydown(event) {
    const inputValue = document.getElementById("tagSearchInput").value;

    if (event.key === 'Enter') {
        event.preventDefault();

        // Find the highlighted tag (first one in the list)
        const highlightedTag = document.querySelector('.tag-dropdown-item.highlighted');
        if (highlightedTag) {
            const tagId = highlightedTag.getAttribute('data-tag-id');
            if (tagId) {
                toggleTag(parseInt(tagId));
                // Clear search input after selecting
                document.getElementById("tagSearchInput").value = "";
                // Re-render to show all available tags again
                renderTagList("");
                pendingDeleteTagIndex = -1;
            }
        } else if (inputValue.trim() !== '') {
            // No matching tag found - auto-create new tag with the search term
            autoCreateAndAddTag(inputValue);
        }
    } else if (event.key === 'Backspace' && inputValue === '') {
        event.preventDefault();

        if (currentOrderTags.length === 0) return;

        if (pendingDeleteTagIndex >= 0) {
            // Second backspace - delete the tag
            removeTag(pendingDeleteTagIndex);
        } else {
            // First backspace - mark last tag for deletion
            pendingDeleteTagIndex = currentOrderTags.length - 1;
            updateSelectedTagsDisplay();
        }
    } else {
        // Any other key resets the pending delete
        if (pendingDeleteTagIndex >= 0) {
            pendingDeleteTagIndex = -1;
            updateSelectedTagsDisplay();
        }
    }
}

function toggleQuickAccess(tagName, buttonElement) {
    if (!window.quickTagManager) {
        console.error('[TAG] Quick tag manager not available');
        return;
    }

    const isActive = window.quickTagManager.toggleQuickTag(tagName);

    // Update button state
    if (isActive) {
        buttonElement.classList.add('active');
        buttonElement.title = 'Bá» khá»i chá»n nhanh';
        if (window.notificationManager) {
            window.notificationManager.show(`â­ ÄÃ£ thÃªm "${tagName}" vÃ o chá»n nhanh`, 'success');
        }
    } else {
        buttonElement.classList.remove('active');
        buttonElement.title = 'ThÃªm vÃ o chá»n nhanh';
        if (window.notificationManager) {
            window.notificationManager.show(`ÄÃ£ bá» "${tagName}" khá»i chá»n nhanh`, 'info');
        }
    }

    console.log(`[TAG] Quick access toggled for "${tagName}": ${isActive ? 'ADDED' : 'REMOVED'}`);
}

async function saveOrderTags() {
    if (!currentEditingOrderId) return;
    try {
        showLoading(true);
        const payload = {
            Tags: currentOrderTags.map((tag) => ({
                Id: tag.Id,
                Color: tag.Color,
                Name: tag.Name,
            })),
            OrderId: currentEditingOrderId,
        };
        const headers = await window.tokenManager.getAuthHeader();
        const response = await API_CONFIG.smartFetch(
            "https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag",
            {
                method: "POST",
                headers: {
                    ...headers,
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(payload),
            },
        );
        if (!response.ok)
            throw new Error(
                `HTTP ${response.status}: ${await response.text()}`,
            );

        // ğŸ”„ Cáº­p nháº­t tags trong data
        const updatedData = { Tags: JSON.stringify(currentOrderTags) };
        updateOrderInTable(currentEditingOrderId, updatedData);

        // ğŸ”¥ Emit TAG update to Firebase for realtime sync
        await emitTagUpdateToFirebase(currentEditingOrderId, currentOrderTags);

        window.cacheManager.clear("orders");
        showLoading(false);
        closeTagModal();

        if (window.notificationManager) {
            window.notificationManager.success(
                `ÄÃ£ gÃ¡n ${currentOrderTags.length} tag cho Ä‘Æ¡n hÃ ng thÃ nh cÃ´ng!`,
                2000
            );
        } else {
            showInfoBanner(
                `âœ… ÄÃ£ gÃ¡n ${currentOrderTags.length} tag cho Ä‘Æ¡n hÃ ng thÃ nh cÃ´ng!`,
            );
        }
    } catch (error) {
        console.error("[TAG] Error saving tags:", error);
        showLoading(false);

        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i khi lÆ°u tag: ${error.message}`, 4000);
        } else {
            alert(`Lá»—i khi lÆ°u tag:\n${error.message}`);
        }
    }
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                     SECTION 6: BULK TAG ASSIGNMENT                          â•‘
// â•‘                            search: #BULK-TAG                                â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// BULK TAG ASSIGNMENT FUNCTIONS #BULK-TAG
// =====================================================

/**
 * Parse STT input string into array of numbers
 * Supports formats: "1, 2, 3", "1-5", "1, 5-10, 15"
 */
function parseBulkSTTInput(input) {
    const sttNumbers = new Set();

    if (!input || !input.trim()) {
        return sttNumbers;
    }

    // Split by comma or space
    const parts = input.split(/[,\s]+/).filter(p => p.trim());

    parts.forEach(part => {
        part = part.trim();

        // Check if it's a range (e.g., "5-10")
        if (part.includes('-')) {
            const [start, end] = part.split('-').map(n => parseInt(n.trim()));
            if (!isNaN(start) && !isNaN(end) && start <= end) {
                for (let i = start; i <= end; i++) {
                    sttNumbers.add(i);
                }
            }
        } else {
            // Single number
            const num = parseInt(part);
            if (!isNaN(num)) {
                sttNumbers.add(num);
            }
        }
    });

    return sttNumbers;
}

// =====================================================
// BULK TAG MODAL FUNCTIONS
// =====================================================

// State variables for bulk tag modal
// Each tag item: {tagId, tagName, tagColor, sttList: Array (giá»¯ thá»© tá»± nháº­p), errorMessage: string|null}
let bulkTagModalData = [];
let selectedBulkTagModalRows = new Set(); // Set of selected tag IDs

// LocalStorage key for bulk tag modal draft
const BULK_TAG_DRAFT_KEY = 'bulkTagModalDraft';

// ===== LocalStorage Functions =====

// Save bulk tag modal data to localStorage
function saveBulkTagToLocalStorage() {
    try {
        const dataToSave = bulkTagModalData.map(tag => ({
            tagId: tag.tagId,
            tagName: tag.tagName,
            tagColor: tag.tagColor,
            sttList: tag.sttList || [],
            errorMessage: tag.errorMessage || null
        }));
        localStorage.setItem(BULK_TAG_DRAFT_KEY, JSON.stringify(dataToSave));
        console.log("[BULK-TAG-MODAL] Saved draft to localStorage:", dataToSave);
    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error saving to localStorage:", error);
    }
}

// Load bulk tag modal data from localStorage
function loadBulkTagFromLocalStorage() {
    try {
        const savedData = localStorage.getItem(BULK_TAG_DRAFT_KEY);
        if (!savedData) return false;

        const parsedData = JSON.parse(savedData);
        if (!Array.isArray(parsedData) || parsedData.length === 0) return false;

        bulkTagModalData = parsedData.map(tag => ({
            tagId: tag.tagId,
            tagName: tag.tagName,
            tagColor: tag.tagColor,
            sttList: tag.sttList || [],
            errorMessage: tag.errorMessage || null
        }));

        // Auto-select tags with STTs
        selectedBulkTagModalRows.clear();
        bulkTagModalData.forEach(tag => {
            if (tag.sttList.length > 0) {
                selectedBulkTagModalRows.add(tag.tagId);
            }
        });

        console.log("[BULK-TAG-MODAL] Loaded draft from localStorage:", bulkTagModalData);
        return true;
    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error loading from localStorage:", error);
        return false;
    }
}

// Clear bulk tag localStorage
function clearBulkTagLocalStorage() {
    try {
        localStorage.removeItem(BULK_TAG_DRAFT_KEY);
        console.log("[BULK-TAG-MODAL] Cleared localStorage draft");
    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error clearing localStorage:", error);
    }
}

// Show bulk tag modal
async function showBulkTagModal() {
    console.log("[BULK-TAG-MODAL] Opening bulk tag modal");

    // Try to load from localStorage first
    const hasStoredData = loadBulkTagFromLocalStorage();

    if (!hasStoredData) {
        // Reset state if no stored data
        bulkTagModalData = [];
        selectedBulkTagModalRows.clear();
    }

    // Update UI
    updateBulkTagModalTable();
    updateBulkTagModalRowCount();
    updateSelectAllCheckbox();
    document.getElementById('bulkTagModalSearchInput').value = '';

    // Load tags for dropdown
    await loadBulkTagModalOptions();

    // Show modal
    document.getElementById('bulkTagModal').classList.add('show');
}

// Close bulk tag modal
function closeBulkTagModal() {
    // Save current state to localStorage before closing
    if (bulkTagModalData.length > 0) {
        saveBulkTagToLocalStorage();
    }

    document.getElementById('bulkTagModal').classList.remove('show');
    document.getElementById('bulkTagModalSearchDropdown').classList.remove('show');
    // Don't clear data - keep in memory for when modal reopens
}

// Load tag options for search dropdown
async function loadBulkTagModalOptions() {
    try {
        // Use existing availableTags or fetch from API
        if (!availableTags || availableTags.length === 0) {
            await loadAvailableTags();
        }
        populateBulkTagModalDropdown();
    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error loading tags:", error);
    }
}

// Populate dropdown with tag options
function populateBulkTagModalDropdown() {
    const dropdown = document.getElementById('bulkTagModalSearchDropdown');
    const searchValue = document.getElementById('bulkTagModalSearchInput').value.toLowerCase().trim();

    // Use window.availableTags (from HTML) or local availableTags (from JS)
    const tags = window.availableTags || availableTags || [];

    console.log("[BULK-TAG-MODAL] Populating dropdown, tags count:", tags.length);

    // Check if tags is loaded
    if (!tags || tags.length === 0) {
        dropdown.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #9ca3af;">
                <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
                Äang táº£i danh sÃ¡ch tag...
                <br><br>
                <button onclick="refreshBulkTagModalDropdown()" style="padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    <i class="fas fa-sync-alt"></i> Táº£i láº¡i
                </button>
            </div>
        `;
        return;
    }

    // Filter tags by search
    const filteredTags = tags.filter(tag =>
        tag.Name && tag.Name.toLowerCase().includes(searchValue)
    );

    if (filteredTags.length === 0) {
        const escapedSearch = searchValue.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        dropdown.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #9ca3af;">
                KhÃ´ng tÃ¬m tháº¥y tag "${escapedSearch}" - <b style="color: #10b981;">Nháº¥n Enter Ä‘á»ƒ táº¡o</b>
            </div>
        `;
        return;
    }

    // Check which tags are already added
    const addedTagIds = new Set(bulkTagModalData.map(t => t.tagId));

    // Limit display to first 100 tags for performance
    const displayTags = filteredTags.slice(0, 100);

    // Track first available (not added) tag for highlighting
    let firstAvailableFound = false;

    dropdown.innerHTML = displayTags.map(tag => {
        const isAdded = addedTagIds.has(tag.Id);
        const tagName = tag.Name.replace(/'/g, "\\'").replace(/"/g, "&quot;");

        // Highlight first tag that is NOT already added
        let isHighlighted = false;
        if (!isAdded && !firstAvailableFound) {
            isHighlighted = true;
            firstAvailableFound = true;
        }

        return `
            <div class="bulk-tag-search-option ${isAdded ? 'disabled' : ''} ${isHighlighted ? 'highlighted' : ''}"
                 data-tag-id="${tag.Id}"
                 data-tag-name="${tagName}"
                 data-tag-color="${tag.Color || '#6b7280'}"
                 onclick="${isAdded ? '' : `addTagToBulkTagModal('${tag.Id}', '${tagName}', '${tag.Color || '#6b7280'}')`}">
                <span class="tag-color-dot" style="background-color: ${tag.Color || '#6b7280'}"></span>
                <span class="tag-name">${tag.Name}</span>
                ${isAdded ? '<span class="tag-added">ÄÃ£ thÃªm</span>' : ''}
            </div>
        `;
    }).join('');

    // Show count if there are more tags
    if (filteredTags.length > 100) {
        dropdown.innerHTML += `
            <div style="padding: 10px 14px; text-align: center; color: #9ca3af; font-size: 12px; border-top: 1px solid #e5e7eb;">
                Hiá»ƒn thá»‹ 100/${filteredTags.length} tag. Nháº­p tá»« khÃ³a Ä‘á»ƒ lá»c.
            </div>
        `;
    }
}

// Show bulk tag modal dropdown (on focus)
function showBulkTagModalDropdown() {
    const dropdown = document.getElementById('bulkTagModalSearchDropdown');
    populateBulkTagModalDropdown();
    dropdown.classList.add('show');
}

// Refresh bulk tag modal dropdown (used by "Táº£i láº¡i" button)
async function refreshBulkTagModalDropdown() {
    const dropdown = document.getElementById('bulkTagModalSearchDropdown');

    // Show loading state
    dropdown.innerHTML = `
        <div style="padding: 16px; text-align: center; color: #9ca3af;">
            <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
            Äang táº£i danh sÃ¡ch tag...
        </div>
    `;

    try {
        // Force reload tags from API
        await loadAvailableTags();
        populateBulkTagModalDropdown();
    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error refreshing tags:", error);
        dropdown.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #ef4444;">
                <i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                Lá»—i táº£i danh sÃ¡ch tag
                <br><br>
                <button onclick="refreshBulkTagModalDropdown()" style="padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    <i class="fas fa-sync-alt"></i> Thá»­ láº¡i
                </button>
            </div>
        `;
    }
}

// Filter bulk tag modal options based on search input
function filterBulkTagModalOptions() {
    const dropdown = document.getElementById('bulkTagModalSearchDropdown');
    populateBulkTagModalDropdown();
    dropdown.classList.add('show');
}

// Handle keydown on search input
function handleBulkTagModalSearchKeydown(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        const searchValue = document.getElementById('bulkTagModalSearchInput').value.trim();

        // Find highlighted tag (first available tag)
        const highlightedTag = document.querySelector('.bulk-tag-search-option.highlighted');

        if (highlightedTag) {
            // Has highlighted tag â†’ select it
            const tagId = highlightedTag.getAttribute('data-tag-id');
            const tagName = highlightedTag.getAttribute('data-tag-name');
            const tagColor = highlightedTag.getAttribute('data-tag-color');
            addTagToBulkTagModal(tagId, tagName, tagColor);
        } else if (searchValue !== '') {
            // No matching tag â†’ create new tag
            autoCreateAndAddTagToBulkModal(searchValue);
        }
    } else if (event.key === 'Escape') {
        document.getElementById('bulkTagModalSearchDropdown').classList.remove('show');
        document.getElementById('bulkTagModalSearchInput').blur();
    }
}

// Auto-create tag and add to bulk tag modal when search yields no results
async function autoCreateAndAddTagToBulkModal(tagName) {
    if (!tagName || tagName.trim() === '') return;

    const name = tagName.trim().toUpperCase(); // Convert to uppercase for consistency
    const color = generateRandomColor();

    try {
        // Show loading notification
        if (window.notificationManager) {
            window.notificationManager.info(`Äang táº¡o tag "${name}"...`);
        }

        console.log('[BULK-TAG-MODAL] Creating tag:', { name, color });

        // Get auth headers
        const headers = await window.tokenManager.getAuthHeader();

        // Create tag via API
        const response = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag',
            {
                method: 'POST',
                headers: {
                    ...headers,
                    'accept': 'application/json, text/plain, */*',
                    'content-type': 'application/json;charset=UTF-8',
                },
                body: JSON.stringify({
                    Name: name,
                    Color: color
                })
            }
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const newTag = await response.json();
        console.log('[BULK-TAG-MODAL] Tag created successfully:', newTag);

        // Remove @odata.context from newTag (Firebase doesn't allow keys with dots)
        if (newTag['@odata.context']) {
            delete newTag['@odata.context'];
        }

        // IMPORTANT: Add new tag directly to availableTags first (before reload)
        // This ensures the tag appears immediately in dropdown even if TPOS hasn't indexed it yet
        if (Array.isArray(availableTags)) {
            // Check if not already exists
            const existsInAvailable = availableTags.some(t => t.Id === newTag.Id);
            if (!existsInAvailable) {
                availableTags.push(newTag);
                window.availableTags = availableTags;
                console.log('[BULK-TAG-MODAL] Added new tag directly to availableTags:', newTag.Name);
            }
        }

        // Clear tags cache and update with new list
        window.cacheManager.clear("tags");
        window.cacheManager.set("tags", availableTags, "tags");
        console.log('[BULK-TAG-MODAL] Updated tags cache with new tag');

        // Update filter dropdowns
        populateTagFilter();
        populateBulkTagModalDropdown();

        // Add the new tag to bulk tag modal table using response data
        // newTag from API response contains: Id, Name, Color, NameNosign, Type
        addTagToBulkTagModal(newTag.Id, newTag.Name, newTag.Color);

        // Show success notification
        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ táº¡o vÃ  thÃªm tag "${name}"!`);
        }

        console.log('[BULK-TAG-MODAL] Tag created and added to bulk modal');

    } catch (error) {
        console.error('[BULK-TAG-MODAL] Error creating tag:', error);
        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i táº¡o tag: ' + error.message);
        }
    }
}

// Add tag to bulk tag modal
function addTagToBulkTagModal(tagId, tagName, tagColor) {
    console.log("[BULK-TAG-MODAL] Adding tag:", tagName);

    // Check if already exists
    if (bulkTagModalData.some(t => t.tagId === tagId)) {
        return;
    }

    // Add to data
    bulkTagModalData.push({
        tagId: tagId,
        tagName: tagName,
        tagColor: tagColor,
        sttList: []
    });

    // Update UI
    updateBulkTagModalTable();
    updateBulkTagModalRowCount();
    populateBulkTagModalDropdown();

    // Clear search input
    document.getElementById('bulkTagModalSearchInput').value = '';
    document.getElementById('bulkTagModalSearchDropdown').classList.remove('show');
}

// Remove tag row from modal
function removeTagFromBulkTagModal(tagId) {
    bulkTagModalData = bulkTagModalData.filter(t => t.tagId !== tagId);
    selectedBulkTagModalRows.delete(tagId);

    updateBulkTagModalTable();
    updateBulkTagModalRowCount();
    populateBulkTagModalDropdown();
}

// Clear all tag rows
function clearAllBulkTagRows() {
    if (bulkTagModalData.length === 0) return;

    if (confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a táº¥t cáº£ tag Ä‘Ã£ thÃªm?')) {
        bulkTagModalData = [];
        selectedBulkTagModalRows.clear();
        document.getElementById('bulkTagSelectAllCheckbox').checked = false;

        // Clear localStorage
        clearBulkTagLocalStorage();

        updateBulkTagModalTable();
        updateBulkTagModalRowCount();
        populateBulkTagModalDropdown();
    }
}

// Update row count display
function updateBulkTagModalRowCount() {
    const countEl = document.getElementById('bulkTagRowCount');
    countEl.textContent = `${bulkTagModalData.length} tag Ä‘Ã£ thÃªm`;
}

// Toggle select all
function toggleBulkTagSelectAll(checked) {
    if (checked) {
        bulkTagModalData.forEach(tag => {
            if (tag.sttList.length > 0) {
                selectedBulkTagModalRows.add(tag.tagId);
            }
        });
    } else {
        selectedBulkTagModalRows.clear();
    }

    updateBulkTagModalTable();
}

// Toggle individual row selection
function toggleBulkTagRowSelection(tagId) {
    const tagData = bulkTagModalData.find(t => t.tagId === tagId);
    if (!tagData || tagData.sttList.length === 0) return;

    if (selectedBulkTagModalRows.has(tagId)) {
        selectedBulkTagModalRows.delete(tagId);
    } else {
        selectedBulkTagModalRows.add(tagId);
    }

    updateBulkTagModalTable();
    updateSelectAllCheckbox();
}

// Update select all checkbox state
function updateSelectAllCheckbox() {
    const selectAllCheckbox = document.getElementById('bulkTagSelectAllCheckbox');
    const tagsWithSTT = bulkTagModalData.filter(t => t.sttList.length > 0);

    if (tagsWithSTT.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedBulkTagModalRows.size === tagsWithSTT.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedBulkTagModalRows.size > 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    }
}

// Add STT to a tag
function addSTTToBulkTagRow(tagId, inputElement) {
    const sttValue = inputElement.value.trim();
    if (!sttValue) return;

    const stt = parseInt(sttValue);
    if (isNaN(stt) || stt <= 0) {
        if (window.notificationManager) {
            window.notificationManager.warning('STT pháº£i lÃ  sá»‘ nguyÃªn dÆ°Æ¡ng', 2000);
        }
        return;
    }

    const tagData = bulkTagModalData.find(t => t.tagId === tagId);
    if (!tagData) return;

    // Check if STT exists in current data
    const order = displayedData.find(o => o.SessionIndex === stt);
    if (!order) {
        if (window.notificationManager) {
            window.notificationManager.warning(`STT ${stt} khÃ´ng tá»“n táº¡i trong danh sÃ¡ch hiá»‡n táº¡i`, 2000);
        }
        return;
    }

    // Check if already added (using Array.includes)
    if (tagData.sttList.includes(stt)) {
        if (window.notificationManager) {
            window.notificationManager.warning(`STT ${stt} Ä‘Ã£ Ä‘Æ°á»£c thÃªm`, 2000);
        }
        inputElement.value = '';
        return;
    }

    // Add STT (giá»¯ nguyÃªn thá»© tá»± nháº­p)
    tagData.sttList.push(stt);
    inputElement.value = '';

    updateBulkTagModalTable();

    // Re-focus on the input after table re-render
    setTimeout(() => {
        const newInput = document.querySelector(`.bulk-tag-row[data-tag-id="${tagId}"] .bulk-tag-stt-input`);
        if (newInput) {
            newInput.focus();
        }
    }, 10);
}

// Handle Enter key on STT input
function handleBulkTagSTTInputKeydown(event, tagId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        addSTTToBulkTagRow(tagId, event.target);
    }
}

// Remove STT from a tag
function removeSTTFromBulkTagRow(tagId, stt) {
    const tagData = bulkTagModalData.find(t => t.tagId === tagId);
    if (!tagData) return;

    tagData.sttList = tagData.sttList.filter(s => s !== stt);

    // If no more STTs, deselect the row
    if (tagData.sttList.length === 0) {
        selectedBulkTagModalRows.delete(tagId);
    }

    updateBulkTagModalTable();
    updateSelectAllCheckbox();
}

// Update the bulk tag modal table
function updateBulkTagModalTable() {
    const tableBody = document.getElementById('bulkTagTableBody');

    if (bulkTagModalData.length === 0) {
        tableBody.innerHTML = `
            <div class="bulk-tag-empty-state">
                <i class="fas fa-inbox"></i>
                <p>ChÆ°a cÃ³ tag nÃ o Ä‘Æ°á»£c thÃªm. HÃ£y tÃ¬m kiáº¿m vÃ  thÃªm tag.</p>
            </div>
        `;
        return;
    }

    tableBody.innerHTML = bulkTagModalData.map(tagData => {
        const isSelected = selectedBulkTagModalRows.has(tagData.tagId);
        const sttArray = tagData.sttList || []; // Giá»¯ nguyÃªn thá»© tá»± nháº­p, khÃ´ng sort
        const sttCount = sttArray.length;
        const hasError = tagData.errorMessage && tagData.errorMessage.length > 0;

        // Get customer names for STTs
        const sttPillsHtml = sttArray.map(stt => {
            const order = displayedData.find(o => o.SessionIndex === stt);
            const customerName = order ? (order.Name || order.PartnerName || 'N/A') : 'N/A';
            return `
                <div class="bulk-tag-stt-pill">
                    <span class="stt-number">STT ${stt}</span>
                    <span class="customer-name">${customerName}</span>
                    <button class="remove-stt" onclick="removeSTTFromBulkTagRow('${tagData.tagId}', ${stt})" title="XÃ³a STT">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
        }).join('');

        // Error message HTML
        const errorHtml = hasError ? `
            <div class="bulk-tag-row-error">
                ${tagData.errorMessage}
            </div>
        ` : '';

        return `
            <div class="bulk-tag-row ${isSelected ? 'selected' : ''} ${hasError ? 'has-error' : ''}" data-tag-id="${tagData.tagId}">
                <div class="bulk-tag-row-tag">
                    <input type="checkbox"
                           ${isSelected ? 'checked' : ''}
                           ${sttCount === 0 ? 'disabled' : ''}
                           onchange="toggleBulkTagRowSelection('${tagData.tagId}')"
                           title="${sttCount === 0 ? 'ThÃªm STT trÆ°á»›c khi chá»n' : 'Chá»n Ä‘á»ƒ gÃ¡n tag'}">
                    <div class="bulk-tag-row-tag-info">
                        <span class="tag-color-dot" style="background-color: ${tagData.tagColor}"></span>
                        <span class="tag-name">${tagData.tagName}</span>
                    </div>
                    ${errorHtml}
                </div>
                <div class="bulk-tag-row-stt">
                    <div class="bulk-tag-stt-pills">
                        ${sttPillsHtml || '<span style="color: #9ca3af; font-size: 13px;">ChÆ°a cÃ³ STT nÃ o</span>'}
                    </div>
                    <div class="bulk-tag-stt-input-wrapper">
                        <input type="number"
                               class="bulk-tag-stt-input"
                               placeholder="Nháº­p STT vÃ  Enter"
                               onkeydown="handleBulkTagSTTInputKeydown(event, '${tagData.tagId}')">
                        <span class="bulk-tag-stt-counter">(${sttCount})</span>
                    </div>
                </div>
                <div class="bulk-tag-row-action">
                    <button class="bulk-tag-remove-row-btn" onclick="removeTagFromBulkTagModal('${tagData.tagId}')" title="XÃ³a tag nÃ y">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

// Execute bulk tag modal assignment
/**
 * Execute bulk tag assignment from modal
 * New flow:
 * 1. Check for "ÄÃƒ Gá»˜P KO CHá»T" tag before assigning
 * 2. Track success/failed for each tag
 * 3. After assignment, remove successful tags/STTs, keep failed ones
 * 4. Save to Firebase with new format
 * 5. Show result modal
 * 6. DON'T close modal automatically
 */

// Helper function to normalize phone numbers
function normalizePhoneForBulkTag(phone) {
    if (!phone) return '';
    // Remove all non-digit characters
    let cleaned = phone.replace(/\D/g, '');
    // Handle Vietnam country code: replace leading 84 with 0
    if (cleaned.startsWith('84')) {
        cleaned = '0' + cleaned.substring(2);
    }
    return cleaned;
}

async function executeBulkTagModalAssignment() {
    console.log("[BULK-TAG-MODAL] Executing bulk tag assignment");

    // Get selected tags with STTs (checked rows only)
    const selectedTags = bulkTagModalData.filter(t =>
        selectedBulkTagModalRows.has(t.tagId) && t.sttList.length > 0
    );

    // Validate: at least one tag selected with STTs
    if (selectedTags.length === 0) {
        if (window.notificationManager) {
            window.notificationManager.warning('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t tag cÃ³ STT Ä‘á»ƒ gÃ¡n', 3000);
        } else {
            alert('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t tag cÃ³ STT Ä‘á»ƒ gÃ¡n');
        }
        return;
    }

    try {
        showLoading(true);

        // Results tracking
        const successResults = []; // Array of {tagName, tagColor, sttList: []}
        const failedResults = [];  // Array of {tagName, tagColor, sttList: [], reason}

        // Process each selected tag
        for (const selectedTag of selectedTags) {
            const tagInfo = {
                Id: parseInt(selectedTag.tagId, 10),
                Name: selectedTag.tagName,
                Color: selectedTag.tagColor
            };

            const sttArray = selectedTag.sttList || [];
            const successSTT = [];
            const failedSTT = [];
            let failReason = null;

            // Find orders matching STT
            const matchingOrders = displayedData.filter(order =>
                sttArray.includes(order.SessionIndex)
            );

            if (matchingOrders.length === 0) {
                console.warn(`[BULK-TAG-MODAL] No orders found for tag "${tagInfo.Name}"`);
                continue;
            }

            console.log(`[BULK-TAG-MODAL] Processing tag "${tagInfo.Name}" for ${matchingOrders.length} orders`);

            // Process each order
            for (const order of matchingOrders) {
                try {
                    // Parse current tags
                    const rawTags = order.Tags ? JSON.parse(order.Tags) : [];
                    const currentTags = rawTags.map(t => ({
                        Id: parseInt(t.Id, 10),
                        Name: t.Name,
                        Color: t.Color
                    }));

                    // Check if order has "ÄÃƒ Gá»˜P KO CHá»T" tag (exact match)
                    const hasBlockedTag = currentTags.some(t => t.Name === "ÄÃƒ Gá»˜P KO CHá»T");
                    if (hasBlockedTag) {
                        console.log(`[BULK-TAG-MODAL] Order ${order.Code} has blocked tag "ÄÃƒ Gá»˜P KO CHá»T", finding replacement...`);

                        // Get normalized phone number
                        const originalSTT = order.SessionIndex;
                        const normalizedPhone = normalizePhoneForBulkTag(order.Telephone);

                        if (!normalizedPhone) {
                            console.log(`[BULK-TAG-MODAL] Order ${order.Code} has no phone number`);
                            failedSTT.push(order.SessionIndex);
                            failReason = 'ÄÆ¡n cÃ³ tag "ÄÃƒ Gá»˜P KO CHá»T" vÃ  khÃ´ng cÃ³ SÄT';
                            continue;
                        }

                        // Find all orders with same phone number (excluding current order)
                        const samePhoneOrders = displayedData.filter(o =>
                            o.Id !== order.Id && normalizePhoneForBulkTag(o.Telephone) === normalizedPhone
                        );

                        if (samePhoneOrders.length === 0) {
                            console.log(`[BULK-TAG-MODAL] No replacement order found for phone ${normalizedPhone}`);
                            failedSTT.push(order.SessionIndex);
                            failReason = 'KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n thay tháº¿ cÃ¹ng SÄT';
                            continue;
                        }

                        // Select order with highest STT
                        const replacementOrder = samePhoneOrders.sort((a, b) =>
                            b.SessionIndex - a.SessionIndex
                        )[0];

                        console.log(`[BULK-TAG-MODAL] Found replacement order ${replacementOrder.Code} (STT ${replacementOrder.SessionIndex}) for blocked order ${order.Code} (STT ${originalSTT})`);

                        // Parse replacement order's tags
                        const replacementRawTags = replacementOrder.Tags ? JSON.parse(replacementOrder.Tags) : [];
                        const replacementCurrentTags = replacementRawTags.map(t => ({
                            Id: parseInt(t.Id, 10),
                            Name: t.Name,
                            Color: t.Color
                        }));

                        // Check if tag already exists on replacement order
                        const tagExistsOnReplacement = replacementCurrentTags.some(t => t.Id === tagInfo.Id);
                        if (tagExistsOnReplacement) {
                            console.log(`[BULK-TAG-MODAL] Tag already exists on replacement order ${replacementOrder.Code}`);
                            successSTT.push({
                                original: originalSTT,
                                redirectTo: replacementOrder.SessionIndex,
                                redirected: true
                            });
                            continue;
                        }

                        // Build updated tags for replacement order
                        const replacementUpdatedTags = [
                            ...replacementCurrentTags,
                            {
                                Id: tagInfo.Id,
                                Name: tagInfo.Name,
                                Color: tagInfo.Color
                            }
                        ];

                        // Call API to assign tag to replacement order
                        try {
                            const authHeaders = await window.tokenManager.getAuthHeader();
                            const response = await fetch(
                                "https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag",
                                {
                                    method: "POST",
                                    headers: {
                                        ...authHeaders,
                                        "Content-Type": "application/json",
                                        "Accept": "application/json"
                                    },
                                    body: JSON.stringify({
                                        Tags: replacementUpdatedTags,
                                        OrderId: replacementOrder.Id
                                    }),
                                }
                            );

                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }

                            // Update local data for replacement order
                            const updatedData = { Tags: JSON.stringify(replacementUpdatedTags) };
                            updateOrderInTable(replacementOrder.Id, updatedData);

                            // Emit Firebase update for replacement order
                            await emitTagUpdateToFirebase(replacementOrder.Id, replacementUpdatedTags);

                            // Record success with redirect info
                            successSTT.push({
                                original: originalSTT,
                                redirectTo: replacementOrder.SessionIndex,
                                redirected: true
                            });
                            console.log(`[BULK-TAG-MODAL] Successfully tagged replacement order ${replacementOrder.Code} with "${tagInfo.Name}" (redirected from STT ${originalSTT})`);

                        } catch (apiError) {
                            console.error(`[BULK-TAG-MODAL] Error tagging replacement order ${replacementOrder.Code}:`, apiError);
                            failedSTT.push(order.SessionIndex);
                            failReason = failReason || `Lá»—i API khi gÃ¡n cho Ä‘Æ¡n thay tháº¿: ${apiError.message}`;
                        }

                        continue;
                    }

                    // Check if tag already exists
                    const tagExists = currentTags.some(t => t.Id === tagInfo.Id);
                    if (tagExists) {
                        console.log(`[BULK-TAG-MODAL] Tag already exists for order ${order.Code}`);
                        successSTT.push(order.SessionIndex);
                        continue;
                    }

                    // Build updated tags array
                    const updatedTags = [
                        ...currentTags,
                        {
                            Id: tagInfo.Id,
                            Name: tagInfo.Name,
                            Color: tagInfo.Color
                        }
                    ];

                    // Call API to assign tag
                    const authHeaders = await window.tokenManager.getAuthHeader();
                    const response = await fetch(
                        "https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag",
                        {
                            method: "POST",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            body: JSON.stringify({
                                Tags: updatedTags,
                                OrderId: order.Id
                            }),
                        }
                    );

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}`);
                    }

                    // Update local data
                    const updatedData = { Tags: JSON.stringify(updatedTags) };
                    updateOrderInTable(order.Id, updatedData);

                    // Emit Firebase update
                    await emitTagUpdateToFirebase(order.Id, updatedTags);

                    successSTT.push(order.SessionIndex);
                    console.log(`[BULK-TAG-MODAL] Successfully tagged order ${order.Code} with "${tagInfo.Name}"`);

                } catch (error) {
                    console.error(`[BULK-TAG-MODAL] Error tagging order ${order.Code}:`, error);
                    failedSTT.push(order.SessionIndex);
                    failReason = failReason || `Lá»—i API: ${error.message}`;
                }
            }

            // Collect results for this tag
            // Separate normal STTs and redirected STTs
            const normalSTT = successSTT.filter(s => typeof s === 'number');
            const redirectedSTT = successSTT.filter(s => typeof s === 'object' && s.redirected);

            if (successSTT.length > 0) {
                successResults.push({
                    tagName: tagInfo.Name,
                    tagColor: tagInfo.Color,
                    sttList: normalSTT.sort((a, b) => a - b),
                    redirectedList: redirectedSTT.sort((a, b) => a.original - b.original)
                });
            }

            if (failedSTT.length > 0) {
                failedResults.push({
                    tagName: tagInfo.Name,
                    tagColor: tagInfo.Color,
                    sttList: failedSTT.sort((a, b) => a - b),
                    reason: failReason || 'Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh'
                });
            }

            // Update modal data: remove successful STTs, keep failed ones
            const tagDataInModal = bulkTagModalData.find(t => t.tagId === selectedTag.tagId);
            if (tagDataInModal) {
                // Get all successful original STTs (both normal and redirected)
                const successOriginalSTTs = [
                    ...normalSTT,
                    ...redirectedSTT.map(r => r.original)
                ];
                // Remove successful STTs
                tagDataInModal.sttList = tagDataInModal.sttList.filter(stt => !successOriginalSTTs.includes(stt));

                // Set error message if there are failures
                if (failedSTT.length > 0) {
                    tagDataInModal.errorMessage = `âš ï¸ STT ${failedSTT.join(', ')} - ${failReason}`;
                } else {
                    tagDataInModal.errorMessage = null;
                }
            }

            console.log(`[BULK-TAG-MODAL] Tag "${tagInfo.Name}" result: ${successSTT.length} success, ${failedSTT.length} failed`);
        }

        // Clear cache
        window.cacheManager.clear("orders");

        // Remove tags with no remaining STTs
        bulkTagModalData = bulkTagModalData.filter(tag => tag.sttList.length > 0);

        // Update selected rows
        selectedBulkTagModalRows.clear();
        bulkTagModalData.forEach(tag => {
            if (tag.sttList.length > 0) {
                selectedBulkTagModalRows.add(tag.tagId);
            }
        });

        // Save/clear localStorage based on remaining data
        if (bulkTagModalData.length > 0) {
            saveBulkTagToLocalStorage();
        } else {
            clearBulkTagLocalStorage();
        }

        // Save history to Firebase
        const totalSuccess = successResults.reduce((sum, r) => sum + r.sttList.length + (r.redirectedList?.length || 0), 0);
        const totalFailed = failedResults.reduce((sum, r) => sum + r.sttList.length, 0);

        if (totalSuccess > 0 || totalFailed > 0) {
            await saveBulkTagHistory({
                success: successResults,
                failed: failedResults
            });
        }

        showLoading(false);

        // Update modal UI
        updateBulkTagModalTable();
        updateBulkTagModalRowCount();
        updateSelectAllCheckbox();

        // Show result modal
        showBulkTagResultModal(successResults, failedResults);

        // DON'T close modal - user must click "Há»§y" to close

    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error in bulk tag assignment:", error);
        showLoading(false);

        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i: ${error.message}`, 5000);
        } else {
            alert(`Lá»—i: ${error.message}`);
        }
    }
}

// Save bulk tag history to Firebase
async function saveBulkTagHistory(results) {
    try {
        const timestamp = Date.now();
        const dateFormatted = new Date(timestamp).toLocaleString('vi-VN');

        // Get identifier name (tÃªn Ä‘á»‹nh danh) - fallback to DisplayName if not available
        let username = 'Unknown';
        try {
            // Æ¯u tiÃªn dÃ¹ng identifier name (tÃªn Ä‘á»‹nh danh)
            if (currentUserIdentifier) {
                username = currentUserIdentifier;
            } else {
                // Fallback to DisplayName from tokenManager
                const tokenData = window.tokenManager?.getTokenData?.();
                username = tokenData?.DisplayName || tokenData?.name || 'Unknown';
            }
        } catch (e) {
            console.warn("[BULK-TAG-MODAL] Could not get username:", e);
        }

        const historyEntry = {
            timestamp: timestamp,
            dateFormatted: dateFormatted,
            username: username,
            results: results, // {success: [...], failed: [...]}
            summary: {
                totalSuccess: results.success.reduce((sum, r) => sum + r.sttList.length, 0),
                totalFailed: results.failed.reduce((sum, r) => sum + r.sttList.length, 0)
            }
        };

        // Save to Firebase
        const historyRef = database.ref(`bulkTagHistory/${timestamp}`);
        await historyRef.set(historyEntry);

        console.log("[BULK-TAG-MODAL] History saved to Firebase:", historyEntry);
    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error saving history:", error);
    }
}

// Show bulk tag result modal
function showBulkTagResultModal(successResults, failedResults) {
    const totalSuccess = successResults.reduce((sum, r) => sum + r.sttList.length + (r.redirectedList?.length || 0), 0);
    const totalFailed = failedResults.reduce((sum, r) => sum + r.sttList.length, 0);

    // Build success HTML
    let successHtml = '';
    if (successResults.length > 0) {
        successHtml = `
            <div class="bulk-tag-result-section success">
                <div class="bulk-tag-result-section-header">
                    <i class="fas fa-check-circle"></i>
                    <span>ThÃ nh cÃ´ng (${totalSuccess} Ä‘Æ¡n)</span>
                </div>
                <div class="bulk-tag-result-section-body">
                    ${successResults.map(r => {
            // Build normal STT display
            const normalSttDisplay = r.sttList.length > 0
                ? `STT ${r.sttList.join(', ')}`
                : '';

            // Build redirected STT display
            const redirectedDisplay = r.redirectedList?.length > 0
                ? r.redirectedList.map(rd => `${rd.original} â†’ ${rd.redirectTo}`).join(', ')
                : '';

            // Combine displays
            let sttDisplay = '';
            if (normalSttDisplay && redirectedDisplay) {
                sttDisplay = `${normalSttDisplay}, ${redirectedDisplay}`;
            } else if (normalSttDisplay) {
                sttDisplay = normalSttDisplay;
            } else if (redirectedDisplay) {
                sttDisplay = `STT ${redirectedDisplay}`;
            }

            // Add redirect note if there are redirected items
            const redirectNote = r.redirectedList?.length > 0
                ? `<div class="redirect-note" style="font-size: 11px; color: #6b7280; margin-top: 2px;">â†³ Chuyá»ƒn sang Ä‘Æ¡n cÃ¹ng SÄT</div>`
                : '';

            return `
                            <div class="bulk-tag-result-item">
                                <span class="tag-color-dot" style="background-color: ${r.tagColor}"></span>
                                <span class="tag-name">${r.tagName}:</span>
                                <span class="stt-list">${sttDisplay}</span>
                                ${redirectNote}
                            </div>
                        `;
        }).join('')}
                </div>
            </div>
        `;
    }

    // Build failed HTML
    let failedHtml = '';
    if (failedResults.length > 0) {
        failedHtml = `
            <div class="bulk-tag-result-section failed">
                <div class="bulk-tag-result-section-header">
                    <i class="fas fa-times-circle"></i>
                    <span>Tháº¥t báº¡i (${totalFailed} Ä‘Æ¡n)</span>
                </div>
                <div class="bulk-tag-result-section-body">
                    ${failedResults.map(r => `
                        <div class="bulk-tag-result-item">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                            <div class="fail-reason">â†’ ${r.reason}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Create and show modal
    const modalHtml = `
        <div class="bulk-tag-result-modal" id="bulkTagResultModal">
            <div class="bulk-tag-result-modal-content">
                <div class="bulk-tag-result-modal-header">
                    <h3><i class="fas fa-clipboard-list"></i> Káº¿t Quáº£ GÃ¡n Tag</h3>
                    <button class="bulk-tag-result-modal-close" onclick="closeBulkTagResultModal()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="bulk-tag-result-modal-body">
                    ${successHtml}
                    ${failedHtml}
                    ${totalSuccess === 0 && totalFailed === 0 ? '<p style="text-align: center; color: #9ca3af;">KhÃ´ng cÃ³ káº¿t quáº£ nÃ o</p>' : ''}
                </div>
                <div class="bulk-tag-result-modal-footer">
                    <button class="bulk-tag-btn-confirm" onclick="closeBulkTagResultModal()">
                        <i class="fas fa-check"></i> ÄÃ³ng
                    </button>
                </div>
            </div>
        </div>
    `;

    // Remove existing modal if any
    const existingModal = document.getElementById('bulkTagResultModal');
    if (existingModal) {
        existingModal.remove();
    }

    // Add modal to body
    document.body.insertAdjacentHTML('beforeend', modalHtml);

    // Show modal
    setTimeout(() => {
        document.getElementById('bulkTagResultModal').classList.add('show');
    }, 10);
}

// Close bulk tag result modal
function closeBulkTagResultModal() {
    const modal = document.getElementById('bulkTagResultModal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => modal.remove(), 300);
    }
}

// Show bulk tag history modal
async function showBulkTagHistoryModal() {
    console.log("[BULK-TAG-MODAL] Opening history modal");

    const historyBody = document.getElementById('bulkTagHistoryModalBody');
    historyBody.innerHTML = `
        <div class="bulk-tag-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Äang táº£i lá»‹ch sá»­...</p>
        </div>
    `;

    document.getElementById('bulkTagHistoryModal').classList.add('show');

    try {
        // Load history from Firebase
        const historyRef = database.ref('bulkTagHistory');
        const snapshot = await historyRef.orderByKey().limitToLast(50).once('value');
        const historyData = snapshot.val();

        if (!historyData) {
            historyBody.innerHTML = `
                <div class="bulk-tag-history-empty">
                    <i class="fas fa-history"></i>
                    <p>ChÆ°a cÃ³ lá»‹ch sá»­ gÃ¡n tag nÃ o</p>
                </div>
            `;
            return;
        }

        // Convert to array and sort by timestamp descending
        const historyArray = Object.values(historyData).sort((a, b) => b.timestamp - a.timestamp);

        historyBody.innerHTML = `
            <div class="bulk-tag-history-list">
                ${historyArray.map((entry, index) => renderBulkTagHistoryItem(entry, index)).join('')}
            </div>
        `;

    } catch (error) {
        console.error("[BULK-TAG-MODAL] Error loading history:", error);
        historyBody.innerHTML = `
            <div class="bulk-tag-history-empty">
                <i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>
                <p>Lá»—i táº£i lá»‹ch sá»­: ${error.message}</p>
            </div>
        `;
    }
}

// Render a single history item (new format)
function renderBulkTagHistoryItem(entry, index) {
    const { dateFormatted, username, results, summary } = entry;

    // Build success section
    let successHtml = '';
    if (results.success && results.success.length > 0) {
        successHtml = `
            <div class="bulk-tag-history-success">
                <div class="bulk-tag-history-success-title">
                    <i class="fas fa-check-circle"></i>
                    ThÃ nh cÃ´ng (${summary.totalSuccess} Ä‘Æ¡n):
                </div>
                <div class="bulk-tag-history-tag-list">
                    ${results.success.map(r => `
                        <div class="bulk-tag-history-tag-item">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor || '#6b7280'}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Build failed section
    let failedHtml = '';
    if (results.failed && results.failed.length > 0) {
        failedHtml = `
            <div class="bulk-tag-history-failed">
                <div class="bulk-tag-history-failed-title">
                    <i class="fas fa-times-circle"></i>
                    Tháº¥t báº¡i (${summary.totalFailed} Ä‘Æ¡n):
                </div>
                <div class="bulk-tag-history-tag-list">
                    ${results.failed.map(r => `
                        <div class="bulk-tag-history-tag-item failed">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor || '#6b7280'}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                            <div class="fail-reason">â†’ ${r.reason}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    return `
        <div class="bulk-tag-history-item" id="bulkTagHistoryItem${index}">
            <div class="bulk-tag-history-header" onclick="toggleBulkTagHistoryItem(${index})">
                <div class="history-info">
                    <div class="history-time">
                        <i class="fas fa-clock"></i>
                        ${dateFormatted}
                    </div>
                    <div class="history-user">
                        <i class="fas fa-user"></i>
                        ${username || 'Unknown'}
                    </div>
                </div>
                <div class="history-summary">
                    <span class="success-count"><i class="fas fa-check"></i> ${summary.totalSuccess}</span>
                    <span class="failed-count"><i class="fas fa-times"></i> ${summary.totalFailed}</span>
                    <i class="fas fa-chevron-down expand-icon"></i>
                </div>
            </div>
            <div class="bulk-tag-history-body">
                ${successHtml}
                ${failedHtml}
            </div>
        </div>
    `;
}

// Toggle history item expand/collapse
function toggleBulkTagHistoryItem(index) {
    const item = document.getElementById(`bulkTagHistoryItem${index}`);
    if (item) {
        item.classList.toggle('expanded');
    }
}

// Close bulk tag history modal
function closeBulkTagHistoryModal() {
    document.getElementById('bulkTagHistoryModal').classList.remove('show');
}

// Close dropdown when clicking outside
document.addEventListener('click', function (event) {
    const searchWrapper = document.querySelector('.bulk-tag-search-wrapper');
    const dropdown = document.getElementById('bulkTagModalSearchDropdown');

    if (searchWrapper && dropdown && !searchWrapper.contains(event.target)) {
        dropdown.classList.remove('show');
    }

    // Also handle bulk tag delete modal dropdown
    const deleteSearchWrapper = document.querySelector('#bulkTagDeleteModal .bulk-tag-search-wrapper');
    const deleteDropdown = document.getElementById('bulkTagDeleteModalSearchDropdown');

    if (deleteSearchWrapper && deleteDropdown && !deleteSearchWrapper.contains(event.target)) {
        deleteDropdown.classList.remove('show');
    }
});

// =====================================================
// BULK TAG DELETE MODAL FUNCTIONS
// =====================================================

// State variables for bulk tag delete modal
// Each tag item: {tagId, tagName, tagColor, sttList: Array, errorMessage: string|null}
let bulkTagDeleteModalData = [];
let selectedBulkTagDeleteModalRows = new Set(); // Set of selected tag IDs

// LocalStorage key for bulk tag delete modal draft
const BULK_TAG_DELETE_DRAFT_KEY = 'bulkTagDeleteModalDraft';

// ===== LocalStorage Functions =====

// Save bulk tag delete modal data to localStorage
function saveBulkTagDeleteToLocalStorage() {
    try {
        const dataToSave = bulkTagDeleteModalData.map(tag => ({
            tagId: tag.tagId,
            tagName: tag.tagName,
            tagColor: tag.tagColor,
            sttList: tag.sttList || [],
            errorMessage: tag.errorMessage || null
        }));
        localStorage.setItem(BULK_TAG_DELETE_DRAFT_KEY, JSON.stringify(dataToSave));
        console.log("[BULK-TAG-DELETE] Saved draft to localStorage:", dataToSave);
    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error saving to localStorage:", error);
    }
}

// Load bulk tag delete modal data from localStorage
function loadBulkTagDeleteFromLocalStorage() {
    try {
        const savedData = localStorage.getItem(BULK_TAG_DELETE_DRAFT_KEY);
        if (!savedData) return false;

        const parsedData = JSON.parse(savedData);
        if (!Array.isArray(parsedData) || parsedData.length === 0) return false;

        bulkTagDeleteModalData = parsedData.map(tag => ({
            tagId: tag.tagId,
            tagName: tag.tagName,
            tagColor: tag.tagColor,
            sttList: tag.sttList || [],
            errorMessage: tag.errorMessage || null
        }));

        // Auto-select tags with STTs
        selectedBulkTagDeleteModalRows.clear();
        bulkTagDeleteModalData.forEach(tag => {
            if (tag.sttList.length > 0) {
                selectedBulkTagDeleteModalRows.add(tag.tagId);
            }
        });

        console.log("[BULK-TAG-DELETE] Loaded draft from localStorage:", bulkTagDeleteModalData);
        return true;
    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error loading from localStorage:", error);
        return false;
    }
}

// Clear bulk tag delete localStorage
function clearBulkTagDeleteLocalStorage() {
    try {
        localStorage.removeItem(BULK_TAG_DELETE_DRAFT_KEY);
        console.log("[BULK-TAG-DELETE] Cleared localStorage draft");
    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error clearing localStorage:", error);
    }
}

// Show bulk tag delete modal
async function showBulkTagDeleteModal() {
    console.log("[BULK-TAG-DELETE] Opening bulk tag delete modal");

    // Try to load from localStorage first
    const hasStoredData = loadBulkTagDeleteFromLocalStorage();

    if (!hasStoredData) {
        // Reset state if no stored data
        bulkTagDeleteModalData = [];
        selectedBulkTagDeleteModalRows.clear();
    }

    // Update UI
    updateBulkTagDeleteModalTable();
    updateBulkTagDeleteModalRowCount();
    updateBulkTagDeleteSelectAllCheckbox();
    document.getElementById('bulkTagDeleteModalSearchInput').value = '';

    // Load tags for dropdown
    await loadBulkTagDeleteModalOptions();

    // Show modal
    document.getElementById('bulkTagDeleteModal').classList.add('show');
}

// Close bulk tag delete modal
function closeBulkTagDeleteModal() {
    // Save current state to localStorage before closing
    if (bulkTagDeleteModalData.length > 0) {
        saveBulkTagDeleteToLocalStorage();
    }

    document.getElementById('bulkTagDeleteModal').classList.remove('show');
    document.getElementById('bulkTagDeleteModalSearchDropdown').classList.remove('show');
    // Don't clear data - keep in memory for when modal reopens
}

// Load tag options for search dropdown
async function loadBulkTagDeleteModalOptions() {
    try {
        // Use existing availableTags or fetch from API
        if (!availableTags || availableTags.length === 0) {
            await loadAvailableTags();
        }
        populateBulkTagDeleteModalDropdown();
    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error loading tags:", error);
    }
}

// Populate dropdown with tag options
function populateBulkTagDeleteModalDropdown() {
    const dropdown = document.getElementById('bulkTagDeleteModalSearchDropdown');
    const searchValue = document.getElementById('bulkTagDeleteModalSearchInput').value.toLowerCase().trim();

    // Use window.availableTags (from HTML) or local availableTags (from JS)
    const tags = window.availableTags || availableTags || [];

    console.log("[BULK-TAG-DELETE] Populating dropdown, tags count:", tags.length);

    // Check if tags is loaded
    if (!tags || tags.length === 0) {
        dropdown.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #9ca3af;">
                <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
                Äang táº£i danh sÃ¡ch tag...
                <br><br>
                <button onclick="refreshBulkTagDeleteModalDropdown()" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    <i class="fas fa-sync-alt"></i> Táº£i láº¡i
                </button>
            </div>
        `;
        return;
    }

    // Filter tags by search
    const filteredTags = tags.filter(tag =>
        tag.Name && tag.Name.toLowerCase().includes(searchValue)
    );

    if (filteredTags.length === 0) {
        const escapedSearch = searchValue.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        dropdown.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #9ca3af;">
                KhÃ´ng tÃ¬m tháº¥y tag "${escapedSearch}"
            </div>
        `;
        return;
    }

    // Check which tags are already added
    const addedTagIds = new Set(bulkTagDeleteModalData.map(t => t.tagId));

    // Limit display to first 100 tags for performance
    const displayTags = filteredTags.slice(0, 100);

    // Track first available (not added) tag for highlighting
    let firstAvailableFound = false;

    dropdown.innerHTML = displayTags.map(tag => {
        const isAdded = addedTagIds.has(tag.Id);
        const tagName = tag.Name.replace(/'/g, "\\'").replace(/"/g, "&quot;");

        // Highlight first tag that is NOT already added
        let isHighlighted = false;
        if (!isAdded && !firstAvailableFound) {
            isHighlighted = true;
            firstAvailableFound = true;
        }

        return `
            <div class="bulk-tag-search-option ${isAdded ? 'disabled' : ''} ${isHighlighted ? 'highlighted' : ''}"
                 data-tag-id="${tag.Id}"
                 data-tag-name="${tagName}"
                 data-tag-color="${tag.Color || '#6b7280'}"
                 onclick="${isAdded ? '' : `addTagToBulkTagDeleteModal('${tag.Id}', '${tagName}', '${tag.Color || '#6b7280'}')`}">
                <span class="tag-color-dot" style="background-color: ${tag.Color || '#6b7280'}"></span>
                <span class="tag-name">${tag.Name}</span>
                ${isAdded ? '<span class="tag-added">ÄÃ£ thÃªm</span>' : ''}
            </div>
        `;
    }).join('');

    // Show count if there are more tags
    if (filteredTags.length > 100) {
        dropdown.innerHTML += `
            <div style="padding: 10px 14px; text-align: center; color: #9ca3af; font-size: 12px; border-top: 1px solid #e5e7eb;">
                Hiá»ƒn thá»‹ 100/${filteredTags.length} tag. Nháº­p tá»« khÃ³a Ä‘á»ƒ lá»c.
            </div>
        `;
    }
}

// Show bulk tag delete modal dropdown (on focus)
function showBulkTagDeleteModalDropdown() {
    const dropdown = document.getElementById('bulkTagDeleteModalSearchDropdown');
    populateBulkTagDeleteModalDropdown();
    dropdown.classList.add('show');
}

// Refresh bulk tag delete modal dropdown (used by "Táº£i láº¡i" button)
async function refreshBulkTagDeleteModalDropdown() {
    const dropdown = document.getElementById('bulkTagDeleteModalSearchDropdown');

    // Show loading state
    dropdown.innerHTML = `
        <div style="padding: 16px; text-align: center; color: #9ca3af;">
            <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
            Äang táº£i danh sÃ¡ch tag...
        </div>
    `;

    try {
        // Force reload tags from API
        await loadAvailableTags();
        populateBulkTagDeleteModalDropdown();
    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error refreshing tags:", error);
        dropdown.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #ef4444;">
                <i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                Lá»—i táº£i danh sÃ¡ch tag
                <br><br>
                <button onclick="refreshBulkTagDeleteModalDropdown()" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    <i class="fas fa-sync-alt"></i> Thá»­ láº¡i
                </button>
            </div>
        `;
    }
}

// Filter bulk tag delete modal options based on search input
function filterBulkTagDeleteModalOptions() {
    const dropdown = document.getElementById('bulkTagDeleteModalSearchDropdown');
    populateBulkTagDeleteModalDropdown();
    dropdown.classList.add('show');
}

// Handle keydown on search input
function handleBulkTagDeleteModalSearchKeydown(event) {
    if (event.key === 'Enter') {
        event.preventDefault();

        // Find highlighted tag (first available tag)
        const highlightedTag = document.querySelector('#bulkTagDeleteModal .bulk-tag-search-option.highlighted');

        if (highlightedTag) {
            // Has highlighted tag â†’ select it
            const tagId = highlightedTag.getAttribute('data-tag-id');
            const tagName = highlightedTag.getAttribute('data-tag-name');
            const tagColor = highlightedTag.getAttribute('data-tag-color');
            addTagToBulkTagDeleteModal(tagId, tagName, tagColor);
        }
    } else if (event.key === 'Escape') {
        document.getElementById('bulkTagDeleteModalSearchDropdown').classList.remove('show');
        document.getElementById('bulkTagDeleteModalSearchInput').blur();
    }
}

// Add tag to bulk tag delete modal
function addTagToBulkTagDeleteModal(tagId, tagName, tagColor) {
    console.log("[BULK-TAG-DELETE] Adding tag:", tagName);

    // Check if already exists
    if (bulkTagDeleteModalData.some(t => t.tagId === tagId)) {
        return;
    }

    // Add to data
    bulkTagDeleteModalData.push({
        tagId: tagId,
        tagName: tagName,
        tagColor: tagColor,
        sttList: []
    });

    // Update UI
    updateBulkTagDeleteModalTable();
    updateBulkTagDeleteModalRowCount();
    populateBulkTagDeleteModalDropdown();

    // Clear search input
    document.getElementById('bulkTagDeleteModalSearchInput').value = '';
    document.getElementById('bulkTagDeleteModalSearchDropdown').classList.remove('show');
}

// Remove tag row from modal
function removeTagFromBulkTagDeleteModal(tagId) {
    bulkTagDeleteModalData = bulkTagDeleteModalData.filter(t => t.tagId !== tagId);
    selectedBulkTagDeleteModalRows.delete(tagId);

    updateBulkTagDeleteModalTable();
    updateBulkTagDeleteModalRowCount();
    populateBulkTagDeleteModalDropdown();
}

// Clear all tag rows
function clearAllBulkTagDeleteRows() {
    if (bulkTagDeleteModalData.length === 0) return;

    if (confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a táº¥t cáº£ tag Ä‘Ã£ thÃªm?')) {
        bulkTagDeleteModalData = [];
        selectedBulkTagDeleteModalRows.clear();
        document.getElementById('bulkTagDeleteSelectAllCheckbox').checked = false;

        // Clear localStorage
        clearBulkTagDeleteLocalStorage();

        updateBulkTagDeleteModalTable();
        updateBulkTagDeleteModalRowCount();
        populateBulkTagDeleteModalDropdown();
    }
}

// Update row count display
function updateBulkTagDeleteModalRowCount() {
    const countEl = document.getElementById('bulkTagDeleteRowCount');
    countEl.textContent = `${bulkTagDeleteModalData.length} tag Ä‘Ã£ thÃªm`;
}

// Toggle select all
function toggleBulkTagDeleteSelectAll(checked) {
    if (checked) {
        bulkTagDeleteModalData.forEach(tag => {
            if (tag.sttList.length > 0) {
                selectedBulkTagDeleteModalRows.add(tag.tagId);
            }
        });
    } else {
        selectedBulkTagDeleteModalRows.clear();
    }

    updateBulkTagDeleteModalTable();
}

// Toggle individual row selection
function toggleBulkTagDeleteRowSelection(tagId) {
    const tagData = bulkTagDeleteModalData.find(t => t.tagId === tagId);
    if (!tagData || tagData.sttList.length === 0) return;

    if (selectedBulkTagDeleteModalRows.has(tagId)) {
        selectedBulkTagDeleteModalRows.delete(tagId);
    } else {
        selectedBulkTagDeleteModalRows.add(tagId);
    }

    updateBulkTagDeleteModalTable();
    updateBulkTagDeleteSelectAllCheckbox();
}

// Update select all checkbox state
function updateBulkTagDeleteSelectAllCheckbox() {
    const selectAllCheckbox = document.getElementById('bulkTagDeleteSelectAllCheckbox');
    const tagsWithSTT = bulkTagDeleteModalData.filter(t => t.sttList.length > 0);

    if (tagsWithSTT.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedBulkTagDeleteModalRows.size === tagsWithSTT.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedBulkTagDeleteModalRows.size > 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    }
}

// Add STT to a tag
function addSTTToBulkTagDeleteRow(tagId, inputElement) {
    const sttValue = inputElement.value.trim();
    if (!sttValue) return;

    const stt = parseInt(sttValue);
    if (isNaN(stt) || stt <= 0) {
        if (window.notificationManager) {
            window.notificationManager.warning('STT pháº£i lÃ  sá»‘ nguyÃªn dÆ°Æ¡ng', 2000);
        }
        return;
    }

    const tagData = bulkTagDeleteModalData.find(t => t.tagId === tagId);
    if (!tagData) return;

    // Check if STT exists in current data
    const order = displayedData.find(o => o.SessionIndex === stt);
    if (!order) {
        if (window.notificationManager) {
            window.notificationManager.warning(`STT ${stt} khÃ´ng tá»“n táº¡i trong danh sÃ¡ch hiá»‡n táº¡i`, 2000);
        }
        return;
    }

    // Check if already added (using Array.includes)
    if (tagData.sttList.includes(stt)) {
        if (window.notificationManager) {
            window.notificationManager.warning(`STT ${stt} Ä‘Ã£ Ä‘Æ°á»£c thÃªm`, 2000);
        }
        inputElement.value = '';
        return;
    }

    // Add STT (giá»¯ nguyÃªn thá»© tá»± nháº­p)
    tagData.sttList.push(stt);
    inputElement.value = '';

    updateBulkTagDeleteModalTable();

    // Re-focus on the input after table re-render
    setTimeout(() => {
        const newInput = document.querySelector(`#bulkTagDeleteModal .bulk-tag-row[data-tag-id="${tagId}"] .bulk-tag-stt-input`);
        if (newInput) {
            newInput.focus();
        }
    }, 10);
}

// Handle Enter key on STT input
function handleBulkTagDeleteSTTInputKeydown(event, tagId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        addSTTToBulkTagDeleteRow(tagId, event.target);
    }
}

// Remove STT from a tag
function removeSTTFromBulkTagDeleteRow(tagId, stt) {
    const tagData = bulkTagDeleteModalData.find(t => t.tagId === tagId);
    if (!tagData) return;

    tagData.sttList = tagData.sttList.filter(s => s !== stt);

    // If no more STTs, deselect the row
    if (tagData.sttList.length === 0) {
        selectedBulkTagDeleteModalRows.delete(tagId);
    }

    updateBulkTagDeleteModalTable();
    updateBulkTagDeleteSelectAllCheckbox();
}

// Update the bulk tag delete modal table
function updateBulkTagDeleteModalTable() {
    const tableBody = document.getElementById('bulkTagDeleteTableBody');

    if (bulkTagDeleteModalData.length === 0) {
        tableBody.innerHTML = `
            <div class="bulk-tag-empty-state">
                <i class="fas fa-inbox"></i>
                <p>ChÆ°a cÃ³ tag nÃ o Ä‘Æ°á»£c thÃªm. HÃ£y tÃ¬m kiáº¿m vÃ  thÃªm tag cáº§n xÃ³a.</p>
            </div>
        `;
        return;
    }

    tableBody.innerHTML = bulkTagDeleteModalData.map(tagData => {
        const isSelected = selectedBulkTagDeleteModalRows.has(tagData.tagId);
        const sttArray = tagData.sttList || []; // Giá»¯ nguyÃªn thá»© tá»± nháº­p, khÃ´ng sort
        const sttCount = sttArray.length;
        const hasError = tagData.errorMessage && tagData.errorMessage.length > 0;

        // Get customer names for STTs
        const sttPillsHtml = sttArray.map(stt => {
            const order = displayedData.find(o => o.SessionIndex === stt);
            const customerName = order ? (order.Name || order.PartnerName || 'N/A') : 'N/A';
            return `
                <div class="bulk-tag-stt-pill">
                    <span class="stt-number">STT ${stt}</span>
                    <span class="customer-name">${customerName}</span>
                    <button class="remove-stt" onclick="removeSTTFromBulkTagDeleteRow('${tagData.tagId}', ${stt})" title="XÃ³a STT">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
        }).join('');

        // Error message HTML
        const errorHtml = hasError ? `
            <div class="bulk-tag-row-error">
                ${tagData.errorMessage}
            </div>
        ` : '';

        return `
            <div class="bulk-tag-row ${isSelected ? 'selected' : ''} ${hasError ? 'has-error' : ''}" data-tag-id="${tagData.tagId}">
                <div class="bulk-tag-row-tag">
                    <input type="checkbox"
                           ${isSelected ? 'checked' : ''}
                           ${sttCount === 0 ? 'disabled' : ''}
                           onchange="toggleBulkTagDeleteRowSelection('${tagData.tagId}')"
                           title="${sttCount === 0 ? 'ThÃªm STT trÆ°á»›c khi chá»n' : 'Chá»n Ä‘á»ƒ xÃ³a tag'}">
                    <div class="bulk-tag-row-tag-info">
                        <span class="tag-color-dot" style="background-color: ${tagData.tagColor}"></span>
                        <span class="tag-name">${tagData.tagName}</span>
                    </div>
                    ${errorHtml}
                </div>
                <div class="bulk-tag-row-stt">
                    <div class="bulk-tag-stt-pills">
                        ${sttPillsHtml || '<span style="color: #9ca3af; font-size: 13px;">ChÆ°a cÃ³ STT nÃ o</span>'}
                    </div>
                    <div class="bulk-tag-stt-input-wrapper">
                        <input type="number"
                               class="bulk-tag-stt-input"
                               placeholder="Nháº­p STT vÃ  Enter"
                               onkeydown="handleBulkTagDeleteSTTInputKeydown(event, '${tagData.tagId}')">
                        <span class="bulk-tag-stt-counter">(${sttCount})</span>
                    </div>
                </div>
                <div class="bulk-tag-row-action">
                    <button class="bulk-tag-remove-row-btn" onclick="removeTagFromBulkTagDeleteModal('${tagData.tagId}')" title="XÃ³a tag nÃ y">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

// Execute bulk tag delete modal removal
/**
 * Execute bulk tag removal from modal
 * Flow:
 * 1. Check if order HAS the tag before removing
 * 2. If order doesn't have the tag â†’ fail with message "Ä‘Æ¡n khÃ´ng cÃ³ tag X"
 * 3. Track success/failed for each tag
 * 4. After removal, remove successful tags/STTs, keep failed ones
 * 5. Save to Firebase with new format (bulkTagDeleteHistory)
 * 6. Show result modal
 * 7. DON'T close modal automatically
 */
async function executeBulkTagDeleteModalRemoval() {
    console.log("[BULK-TAG-DELETE] Executing bulk tag removal");

    // Get selected tags with STTs (checked rows only)
    const selectedTags = bulkTagDeleteModalData.filter(t =>
        selectedBulkTagDeleteModalRows.has(t.tagId) && t.sttList.length > 0
    );

    // Validate: at least one tag selected with STTs
    if (selectedTags.length === 0) {
        if (window.notificationManager) {
            window.notificationManager.warning('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t tag cÃ³ STT Ä‘á»ƒ xÃ³a', 3000);
        } else {
            alert('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t tag cÃ³ STT Ä‘á»ƒ xÃ³a');
        }
        return;
    }

    try {
        showLoading(true);

        // Results tracking
        const successResults = []; // Array of {tagName, tagColor, sttList: []}
        const failedResults = [];  // Array of {tagName, tagColor, sttList: [], reason}

        // Process each selected tag
        for (const selectedTag of selectedTags) {
            const tagInfo = {
                Id: parseInt(selectedTag.tagId, 10),
                Name: selectedTag.tagName,
                Color: selectedTag.tagColor
            };

            const sttArray = selectedTag.sttList || [];
            const successSTT = [];
            const failedSTT = [];
            let failReason = null;

            // Find orders matching STT
            const matchingOrders = displayedData.filter(order =>
                sttArray.includes(order.SessionIndex)
            );

            if (matchingOrders.length === 0) {
                console.warn(`[BULK-TAG-DELETE] No orders found for tag "${tagInfo.Name}"`);
                continue;
            }

            console.log(`[BULK-TAG-DELETE] Processing tag "${tagInfo.Name}" for ${matchingOrders.length} orders`);

            // Process each order
            for (const order of matchingOrders) {
                try {
                    // Parse current tags
                    const rawTags = order.Tags ? JSON.parse(order.Tags) : [];
                    const currentTags = rawTags.map(t => ({
                        Id: parseInt(t.Id, 10),
                        Name: t.Name,
                        Color: t.Color
                    }));

                    // Check if order HAS the tag
                    const hasTag = currentTags.some(t => t.Id === tagInfo.Id);
                    if (!hasTag) {
                        console.log(`[BULK-TAG-DELETE] Order ${order.Code} doesn't have tag "${tagInfo.Name}"`);
                        failedSTT.push(order.SessionIndex);
                        failReason = failReason || `ÄÆ¡n khÃ´ng cÃ³ tag "${tagInfo.Name}"`;
                        continue;
                    }

                    // Build updated tags array (REMOVE the tag)
                    const updatedTags = currentTags.filter(t => t.Id !== tagInfo.Id);

                    // Call API to assign (updated) tags
                    const authHeaders = await window.tokenManager.getAuthHeader();
                    const response = await fetch(
                        "https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag",
                        {
                            method: "POST",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                                "Accept": "application/json"
                            },
                            body: JSON.stringify({
                                Tags: updatedTags,
                                OrderId: order.Id
                            }),
                        }
                    );

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}`);
                    }

                    // Update local data
                    const updatedData = { Tags: JSON.stringify(updatedTags) };
                    updateOrderInTable(order.Id, updatedData);

                    // Emit Firebase update
                    await emitTagUpdateToFirebase(order.Id, updatedTags);

                    successSTT.push(order.SessionIndex);
                    console.log(`[BULK-TAG-DELETE] Successfully removed tag "${tagInfo.Name}" from order ${order.Code}`);

                } catch (error) {
                    console.error(`[BULK-TAG-DELETE] Error removing tag from order ${order.Code}:`, error);
                    failedSTT.push(order.SessionIndex);
                    failReason = failReason || `Lá»—i API: ${error.message}`;
                }
            }

            // Collect results for this tag
            if (successSTT.length > 0) {
                successResults.push({
                    tagName: tagInfo.Name,
                    tagColor: tagInfo.Color,
                    sttList: successSTT.sort((a, b) => a - b)
                });
            }

            if (failedSTT.length > 0) {
                failedResults.push({
                    tagName: tagInfo.Name,
                    tagColor: tagInfo.Color,
                    sttList: failedSTT.sort((a, b) => a - b),
                    reason: failReason || 'Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh'
                });
            }

            // Update modal data: remove successful STTs, keep failed ones
            const tagDataInModal = bulkTagDeleteModalData.find(t => t.tagId === selectedTag.tagId);
            if (tagDataInModal) {
                // Remove successful STTs
                tagDataInModal.sttList = tagDataInModal.sttList.filter(stt => !successSTT.includes(stt));

                // Set error message if there are failures
                if (failedSTT.length > 0) {
                    tagDataInModal.errorMessage = `âš ï¸ STT ${failedSTT.join(', ')} - ${failReason}`;
                } else {
                    tagDataInModal.errorMessage = null;
                }
            }

            console.log(`[BULK-TAG-DELETE] Tag "${tagInfo.Name}" result: ${successSTT.length} success, ${failedSTT.length} failed`);
        }

        // Clear cache
        window.cacheManager.clear("orders");

        // Remove tags with no remaining STTs
        bulkTagDeleteModalData = bulkTagDeleteModalData.filter(tag => tag.sttList.length > 0);

        // Update selected rows
        selectedBulkTagDeleteModalRows.clear();
        bulkTagDeleteModalData.forEach(tag => {
            if (tag.sttList.length > 0) {
                selectedBulkTagDeleteModalRows.add(tag.tagId);
            }
        });

        // Save/clear localStorage based on remaining data
        if (bulkTagDeleteModalData.length > 0) {
            saveBulkTagDeleteToLocalStorage();
        } else {
            clearBulkTagDeleteLocalStorage();
        }

        // Save history to Firebase (separate path: bulkTagDeleteHistory)
        const totalSuccess = successResults.reduce((sum, r) => sum + r.sttList.length, 0);
        const totalFailed = failedResults.reduce((sum, r) => sum + r.sttList.length, 0);

        if (totalSuccess > 0 || totalFailed > 0) {
            await saveBulkTagDeleteHistory({
                success: successResults,
                failed: failedResults
            });
        }

        showLoading(false);

        // Update modal UI
        updateBulkTagDeleteModalTable();
        updateBulkTagDeleteModalRowCount();
        updateBulkTagDeleteSelectAllCheckbox();

        // Show result modal
        showBulkTagDeleteResultModal(successResults, failedResults);

        // DON'T close modal - user must click "Há»§y" to close

    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error in bulk tag removal:", error);
        showLoading(false);

        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i: ${error.message}`, 5000);
        } else {
            alert(`Lá»—i: ${error.message}`);
        }
    }
}

// Save bulk tag delete history to Firebase
async function saveBulkTagDeleteHistory(results) {
    try {
        const timestamp = Date.now();
        const dateFormatted = new Date(timestamp).toLocaleString('vi-VN');

        // Get identifier name (tÃªn Ä‘á»‹nh danh) - fallback to DisplayName if not available
        let username = 'Unknown';
        try {
            // Æ¯u tiÃªn dÃ¹ng identifier name (tÃªn Ä‘á»‹nh danh)
            if (currentUserIdentifier) {
                username = currentUserIdentifier;
            } else {
                // Fallback to DisplayName from tokenManager
                const tokenData = window.tokenManager?.getTokenData?.();
                username = tokenData?.DisplayName || tokenData?.name || 'Unknown';
            }
        } catch (e) {
            console.warn("[BULK-TAG-DELETE] Could not get username:", e);
        }

        const historyEntry = {
            timestamp: timestamp,
            dateFormatted: dateFormatted,
            username: username,
            results: results, // {success: [...], failed: [...]}
            summary: {
                totalSuccess: results.success.reduce((sum, r) => sum + r.sttList.length, 0),
                totalFailed: results.failed.reduce((sum, r) => sum + r.sttList.length, 0)
            }
        };

        // Save to Firebase (separate path for delete history)
        const historyRef = database.ref(`bulkTagDeleteHistory/${timestamp}`);
        await historyRef.set(historyEntry);

        console.log("[BULK-TAG-DELETE] History saved to Firebase:", historyEntry);
    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error saving history:", error);
    }
}

// Show bulk tag delete result modal
function showBulkTagDeleteResultModal(successResults, failedResults) {
    const totalSuccess = successResults.reduce((sum, r) => sum + r.sttList.length, 0);
    const totalFailed = failedResults.reduce((sum, r) => sum + r.sttList.length, 0);

    // Build success HTML
    let successHtml = '';
    if (successResults.length > 0) {
        successHtml = `
            <div class="bulk-tag-result-section success">
                <div class="bulk-tag-result-section-header">
                    <i class="fas fa-check-circle"></i>
                    <span>XÃ³a thÃ nh cÃ´ng (${totalSuccess} Ä‘Æ¡n)</span>
                </div>
                <div class="bulk-tag-result-section-body">
                    ${successResults.map(r => `
                        <div class="bulk-tag-result-item">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Build failed HTML
    let failedHtml = '';
    if (failedResults.length > 0) {
        failedHtml = `
            <div class="bulk-tag-result-section failed">
                <div class="bulk-tag-result-section-header">
                    <i class="fas fa-times-circle"></i>
                    <span>Tháº¥t báº¡i (${totalFailed} Ä‘Æ¡n)</span>
                </div>
                <div class="bulk-tag-result-section-body">
                    ${failedResults.map(r => `
                        <div class="bulk-tag-result-item">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                            <div class="fail-reason">â†’ ${r.reason}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Create and show modal
    const modalHtml = `
        <div class="bulk-tag-result-modal bulk-tag-delete-result" id="bulkTagDeleteResultModal">
            <div class="bulk-tag-result-modal-content">
                <div class="bulk-tag-result-modal-header" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">
                    <h3><i class="fas fa-clipboard-list"></i> Káº¿t Quáº£ XÃ³a Tag</h3>
                    <button class="bulk-tag-result-modal-close" onclick="closeBulkTagDeleteResultModal()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="bulk-tag-result-modal-body">
                    ${successHtml}
                    ${failedHtml}
                    ${totalSuccess === 0 && totalFailed === 0 ? '<p style="text-align: center; color: #9ca3af;">KhÃ´ng cÃ³ káº¿t quáº£ nÃ o</p>' : ''}
                </div>
                <div class="bulk-tag-result-modal-footer">
                    <button class="bulk-tag-btn-confirm" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);" onclick="closeBulkTagDeleteResultModal()">
                        <i class="fas fa-check"></i> ÄÃ³ng
                    </button>
                </div>
            </div>
        </div>
    `;

    // Remove existing modal if any
    const existingModal = document.getElementById('bulkTagDeleteResultModal');
    if (existingModal) {
        existingModal.remove();
    }

    // Add modal to body
    document.body.insertAdjacentHTML('beforeend', modalHtml);

    // Show modal
    setTimeout(() => {
        document.getElementById('bulkTagDeleteResultModal').classList.add('show');
    }, 10);
}

// Close bulk tag delete result modal
function closeBulkTagDeleteResultModal() {
    const modal = document.getElementById('bulkTagDeleteResultModal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => modal.remove(), 300);
    }
}

// Show bulk tag delete history modal
async function showBulkTagDeleteHistoryModal() {
    console.log("[BULK-TAG-DELETE] Opening history modal");

    const historyBody = document.getElementById('bulkTagDeleteHistoryModalBody');
    historyBody.innerHTML = `
        <div class="bulk-tag-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Äang táº£i lá»‹ch sá»­...</p>
        </div>
    `;

    document.getElementById('bulkTagDeleteHistoryModal').classList.add('show');

    try {
        // Load history from Firebase (separate path)
        const historyRef = database.ref('bulkTagDeleteHistory');
        const snapshot = await historyRef.orderByKey().limitToLast(50).once('value');
        const historyData = snapshot.val();

        if (!historyData) {
            historyBody.innerHTML = `
                <div class="bulk-tag-history-empty">
                    <i class="fas fa-history"></i>
                    <p>ChÆ°a cÃ³ lá»‹ch sá»­ xÃ³a tag nÃ o</p>
                </div>
            `;
            return;
        }

        // Convert to array and sort by timestamp descending
        const historyArray = Object.values(historyData).sort((a, b) => b.timestamp - a.timestamp);

        historyBody.innerHTML = `
            <div class="bulk-tag-history-list">
                ${historyArray.map((entry, index) => renderBulkTagDeleteHistoryItem(entry, index)).join('')}
            </div>
        `;

    } catch (error) {
        console.error("[BULK-TAG-DELETE] Error loading history:", error);
        historyBody.innerHTML = `
            <div class="bulk-tag-history-empty">
                <i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>
                <p>Lá»—i táº£i lá»‹ch sá»­: ${error.message}</p>
            </div>
        `;
    }
}

// Render a single delete history item
function renderBulkTagDeleteHistoryItem(entry, index) {
    const { dateFormatted, username, results, summary } = entry;

    // Build success section
    let successHtml = '';
    if (results.success && results.success.length > 0) {
        successHtml = `
            <div class="bulk-tag-history-success">
                <div class="bulk-tag-history-success-title">
                    <i class="fas fa-check-circle"></i>
                    XÃ³a thÃ nh cÃ´ng (${summary.totalSuccess} Ä‘Æ¡n):
                </div>
                <div class="bulk-tag-history-tag-list">
                    ${results.success.map(r => `
                        <div class="bulk-tag-history-tag-item">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor || '#6b7280'}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Build failed section
    let failedHtml = '';
    if (results.failed && results.failed.length > 0) {
        failedHtml = `
            <div class="bulk-tag-history-failed">
                <div class="bulk-tag-history-failed-title">
                    <i class="fas fa-times-circle"></i>
                    Tháº¥t báº¡i (${summary.totalFailed} Ä‘Æ¡n):
                </div>
                <div class="bulk-tag-history-tag-list">
                    ${results.failed.map(r => `
                        <div class="bulk-tag-history-tag-item failed">
                            <span class="tag-color-dot" style="background-color: ${r.tagColor || '#6b7280'}"></span>
                            <span class="tag-name">${r.tagName}:</span>
                            <span class="stt-list">STT ${r.sttList.join(', ')}</span>
                            <div class="fail-reason">â†’ ${r.reason}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    return `
        <div class="bulk-tag-history-item" id="bulkTagDeleteHistoryItem${index}">
            <div class="bulk-tag-history-header" onclick="toggleBulkTagDeleteHistoryItem(${index})">
                <div class="history-info">
                    <div class="history-time">
                        <i class="fas fa-clock"></i>
                        ${dateFormatted}
                    </div>
                    <div class="history-user">
                        <i class="fas fa-user"></i>
                        ${username || 'Unknown'}
                    </div>
                </div>
                <div class="history-summary">
                    <span class="success-count"><i class="fas fa-check"></i> ${summary.totalSuccess}</span>
                    <span class="failed-count"><i class="fas fa-times"></i> ${summary.totalFailed}</span>
                    <i class="fas fa-chevron-down expand-icon"></i>
                </div>
            </div>
            <div class="bulk-tag-history-body">
                ${successHtml}
                ${failedHtml}
            </div>
        </div>
    `;
}

// Toggle delete history item expand/collapse
function toggleBulkTagDeleteHistoryItem(index) {
    const item = document.getElementById(`bulkTagDeleteHistoryItem${index}`);
    if (item) {
        item.classList.toggle('expanded');
    }
}

// Close bulk tag delete history modal
function closeBulkTagDeleteHistoryModal() {
    document.getElementById('bulkTagDeleteHistoryModal').classList.remove('show');
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                   SECTION 7: TABLE SEARCH & FILTERING                       â•‘
// â•‘                            search: #SEARCH                                  â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// TABLE SEARCH & FILTERING #SEARCH
// =====================================================
function handleTableSearch(query) {
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        searchQuery = query.trim().toLowerCase();
        document
            .getElementById("searchClearBtn")
            .classList.toggle("active", !!searchQuery);
        performTableSearch();
    }, 300);
}

// =====================================================
// MERGE ORDERS BY PHONE NUMBER
// =====================================================
function mergeOrdersByPhone(orders) {
    if (!orders || orders.length === 0) return orders;

    // Normalize phone numbers (remove spaces, dots, dashes, country code)
    const normalizePhone = (phone) => {
        if (!phone) return '';
        // Remove all non-digit characters
        let cleaned = phone.replace(/\D/g, '');
        // Handle Vietnam country code: replace leading 84 with 0
        if (cleaned.startsWith('84')) {
            cleaned = '0' + cleaned.substring(2);
        }
        return cleaned;
    };

    // Group orders by normalized phone number
    const phoneGroups = new Map();

    orders.forEach(order => {
        const normalizedPhone = normalizePhone(order.Telephone);
        if (!normalizedPhone) {
            // If no phone number, treat as individual order
            if (!phoneGroups.has(`no_phone_${order.Id}`)) {
                phoneGroups.set(`no_phone_${order.Id}`, []);
            }
            phoneGroups.get(`no_phone_${order.Id}`).push(order);
        } else {
            if (!phoneGroups.has(normalizedPhone)) {
                phoneGroups.set(normalizedPhone, []);
            }
            phoneGroups.get(normalizedPhone).push(order);
        }
    });

    // Merge orders in each group
    const mergedOrders = [];

    phoneGroups.forEach((groupOrders, phone) => {
        if (groupOrders.length === 1) {
            // Only one order with this phone, no merging needed
            mergedOrders.push(groupOrders[0]);
        } else {
            // Multiple orders with same phone number - merge them
            // Sort by SessionIndex (STT) to find the order with largest STT
            const sortedOrders = [...groupOrders].sort((a, b) => {
                const sttA = parseInt(a.SessionIndex) || 0;
                const sttB = parseInt(b.SessionIndex) || 0;
                return sttB - sttA; // Descending order (largest first)
            });

            // Order with largest STT becomes the target (will receive all products)
            const targetOrder = sortedOrders[0];
            const sourceOrders = sortedOrders.slice(1); // Orders with smaller STT (will lose products)

            // Collect all unique values
            const allCodes = [];
            const allNames = new Set();
            const allAddresses = new Set();
            const allNotes = [];
            const allSTTs = [];
            let totalAmount = 0;
            let totalQuantity = 0;
            const allIds = [];
            let earliestDate = targetOrder.DateCreated;

            groupOrders.forEach(order => {
                allCodes.push(order.Code);
                if (order.Name && order.Name.trim()) allNames.add(order.Name.trim());
                if (order.Address && order.Address.trim()) allAddresses.add(order.Address.trim());
                if (order.Note && order.Note.trim()) allNotes.push(order.Note.trim());
                if (order.SessionIndex) allSTTs.push(order.SessionIndex);
                totalAmount += (order.TotalAmount || 0);
                totalQuantity += (order.TotalQuantity || 0);
                allIds.push(order.Id);

                // Keep earliest date
                if (new Date(order.DateCreated) < new Date(earliestDate)) {
                    earliestDate = order.DateCreated;
                }
            });

            // Group orders by customer name to handle single vs multi-customer scenarios
            const customerGroups = new Map();
            groupOrders.forEach(order => {
                const name = order.Name?.trim() || 'Unknown';
                if (!customerGroups.has(name)) {
                    customerGroups.set(name, []);
                }
                customerGroups.get(name).push(order);
            });

            // Determine if single or multi-customer
            const uniqueCustomerCount = customerGroups.size;
            const isSingleCustomer = uniqueCustomerCount === 1;

            // Store original orders with necessary chat info AND amount/quantity for display
            const originalOrders = groupOrders.map(order => ({
                Id: order.Id,
                Name: order.Name,
                Code: order.Code,
                SessionIndex: order.SessionIndex,
                Facebook_ASUserId: order.Facebook_ASUserId,
                Facebook_PostId: order.Facebook_PostId,
                Telephone: order.Telephone,
                TotalAmount: order.TotalAmount || 0,
                TotalQuantity: order.TotalQuantity || 0
            }));

            // Create customer groups info for rendering
            const customerGroupsInfo = Array.from(customerGroups.entries()).map(([name, orders]) => {
                // Sort orders by STT to get largest
                const sortedOrders = [...orders].sort((a, b) => {
                    const sttA = parseInt(a.SessionIndex) || 0;
                    const sttB = parseInt(b.SessionIndex) || 0;
                    return sttB - sttA; // Descending order (largest first)
                });

                return {
                    name,
                    orderCount: orders.length,
                    orders: sortedOrders.map(o => ({
                        id: o.Id,
                        stt: o.SessionIndex,
                        psid: o.Facebook_ASUserId,
                        channelId: window.chatDataManager ? window.chatDataManager.parseChannelId(o.Facebook_PostId) : null,
                        code: o.Code
                    }))
                };
            });

            // Create merged order
            const mergedOrder = {
                ...targetOrder, // Use target order as base
                Code: allCodes.join(' + '),
                Name: Array.from(allNames).join(' / '),
                Address: Array.from(allAddresses).join(' | '),
                Note: allNotes.length > 0 ? allNotes.join(' | ') : targetOrder.Note,
                TotalAmount: totalAmount,
                TotalQuantity: totalQuantity,
                DateCreated: earliestDate,
                Id: allIds.join('_'), // Combine IDs for checkbox handling
                OriginalIds: allIds, // Store original IDs for reference
                MergedCount: groupOrders.length, // Track how many orders were merged
                SessionIndex: allSTTs.length > 1 ? allSTTs.join(' + ') : (targetOrder.SessionIndex || ''),
                AllSTTs: allSTTs, // Store all STT for reference
                // NEW: Store merge info for product transfer
                TargetOrderId: targetOrder.Id, // Order with largest STT (will receive products)
                SourceOrderIds: sourceOrders.map(o => o.Id), // Orders with smaller STT (will lose products)
                TargetSTT: targetOrder.SessionIndex,
                SourceSTTs: sourceOrders.map(o => o.SessionIndex),
                IsMerged: true, // Flag to identify merged orders
                // NEW: Customer grouping info for message/comment rendering
                OriginalOrders: originalOrders, // Store original orders with chat info
                IsSingleCustomer: isSingleCustomer, // true if all orders have same customer name
                UniqueCustomerCount: uniqueCustomerCount, // Number of unique customers
                CustomerGroups: customerGroupsInfo // Grouped by customer with sorted orders
            };

            mergedOrders.push(mergedOrder);
        }
    });

    return mergedOrders;
}

function performTableSearch() {
    // Apply search filter
    let tempData = searchQuery
        ? allData.filter((order) => matchesSearchQuery(order, searchQuery))
        : [...allData];

    // Apply Employee STT Range Filter
    // Check if user has admin access via detailedPermissions
    const auth = window.authManager ? window.authManager.getAuthState() : null;
    let isAdmin = auth?.detailedPermissions?.['baocaosaleonline']?.['viewRevenue'] === true ||
        auth?.roleTemplate === 'admin';

    const currentUserType = auth && auth.userType ? auth.userType : null;
    const currentDisplayName = auth && auth.displayName ? auth.displayName : null;
    const currentUserId = auth && auth.id ? auth.id : null;

    // Fallback: Check username string for Admin (legacy support)
    if (!isAdmin && currentUserType) {
        const lowerName = currentUserType.toLowerCase();
        if (lowerName.includes('admin') || lowerName.includes('quáº£n trá»‹') || lowerName.includes('administrator')) {
            isAdmin = true;
            console.log('[FILTER] User identified as Admin by name check');
        }
    }

    if (!isAdmin && employeeRanges.length > 0) {
        console.log('[FILTER] Current user:', currentDisplayName || currentUserType, 'ID:', currentUserId);

        let userRange = null;

        // 1. Try matching by ID first (most reliable)
        if (currentUserId) {
            userRange = employeeRanges.find(r => r.id === currentUserId);
            if (userRange) console.log('[FILTER] Matched by ID');
        }

        // 2. If not found, try matching by Display Name (Exact match)
        if (!userRange && currentDisplayName) {
            userRange = employeeRanges.find(r => r.name === currentDisplayName);
            if (userRange) console.log('[FILTER] Matched by Display Name');
        }

        // 3. If not found, try matching by User Type (Legacy)
        if (!userRange && currentUserType) {
            userRange = employeeRanges.find(r => r.name === currentUserType);
            if (userRange) console.log('[FILTER] Matched by User Type');
        }

        // 4. If not found, try matching by short name (before "-")
        if (!userRange && currentUserType) {
            const shortName = currentUserType.split('-')[0].trim();
            userRange = employeeRanges.find(r => r.name === shortName);
            if (userRange) console.log('[FILTER] Matched by Short Name:', shortName);
        }

        if (userRange) {
            const debugInfo = `
ğŸ” THÃ”NG TIN DEBUG:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ‘¤ TÃ i khoáº£n hiá»‡n táº¡i: ${currentDisplayName || currentUserType}
ğŸ†” User ID: ${currentUserId || 'KhÃ´ng cÃ³'}
ğŸ” LÃ  Admin? ${isAdmin ? 'CÃ“' : 'KHÃ”NG'}
ğŸ“Š STT Ä‘Æ°á»£c phÃ¢n: ${userRange.start} - ${userRange.end}
ğŸ‘¥ TÃªn trong setting: ${userRange.name}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ Äang Ã¡p dá»¥ng filter cho báº¡n!
            `.trim();

            console.log(debugInfo);

            // Alert removed as per user request
            // if (!window._filterDebugShown) {
            //     alert(debugInfo);
            //     window._filterDebugShown = true;
            // }

            tempData = tempData.filter(order => {
                const stt = parseInt(order.SessionIndex);
                if (isNaN(stt)) return false;
                return stt >= userRange.start && stt <= userRange.end;
            });
            console.log(`[FILTER] Applied STT range ${userRange.start}-${userRange.end} for ${currentDisplayName || currentUserType}`);
        } else {
            console.log('[FILTER] No range found for user:', currentDisplayName || currentUserType);
        }
    } else if (isAdmin) {
        console.log('[FILTER] User is Admin - NO FILTER APPLIED');
    }

    // Apply conversation status filter (Merged Messages & Comments)
    const conversationFilter = document.getElementById('conversationFilter')?.value || 'all';

    if (window.pancakeDataManager && conversationFilter !== 'all') {
        tempData = tempData.filter(order => {
            const msgUnread = window.pancakeDataManager.getMessageUnreadInfoForOrder(order);
            const cmmUnread = window.pancakeDataManager.getCommentUnreadInfoForOrder(order);

            const hasUnreadMessage = msgUnread.hasUnread;
            const hasUnreadComment = cmmUnread.hasUnread;

            if (conversationFilter === 'unread') {
                return hasUnreadMessage || hasUnreadComment;
            } else if (conversationFilter === 'read') {
                return !hasUnreadMessage && !hasUnreadComment;
            }
            return true;
        });
    }

    // Apply Status Filter
    const statusFilter = document.getElementById('statusFilter')?.value || 'all';
    if (statusFilter !== 'all') {
        tempData = tempData.filter(order => {
            if (statusFilter === 'Draft') {
                return order.Status === 'Draft';
            } else if (statusFilter === 'Confirmed') {
                return order.Status !== 'Draft';
            }
            return true;
        });
    }

    // Apply TAG filter
    const tagFilter = document.getElementById('tagFilter')?.value || 'all';

    if (tagFilter !== 'all') {
        tempData = tempData.filter(order => {
            if (!order.Tags) return false;

            try {
                const orderTags = JSON.parse(order.Tags);
                if (!Array.isArray(orderTags) || orderTags.length === 0) return false;

                // Check if the order has the selected tag
                return orderTags.some(tag => String(tag.Id) === String(tagFilter));
            } catch (e) {
                return false;
            }
        });
    }

    filteredData = tempData;

    // Priority sorting: STT â†’ Phone â†’ Name
    if (searchQuery) {
        filteredData.sort((a, b) => {
            const searchLower = searchQuery.toLowerCase();
            const aStt = String(a.SessionIndex || '').toLowerCase();
            const bStt = String(b.SessionIndex || '').toLowerCase();
            const aPhone = (a.Telephone || '').toLowerCase();
            const bPhone = (b.Telephone || '').toLowerCase();
            const aName = (a.Name || '').toLowerCase();
            const bName = (b.Name || '').toLowerCase();

            // Priority 1: STT exact match
            const aSttMatch = aStt === searchLower;
            const bSttMatch = bStt === searchLower;
            if (aSttMatch && !bSttMatch) return -1;
            if (!aSttMatch && bSttMatch) return 1;

            // Priority 2: STT starts with
            const aSttStarts = aStt.startsWith(searchLower);
            const bSttStarts = bStt.startsWith(searchLower);
            if (aSttStarts && !bSttStarts) return -1;
            if (!aSttStarts && bSttStarts) return 1;

            // Priority 3: STT contains
            const aSttContains = aStt.includes(searchLower);
            const bSttContains = bStt.includes(searchLower);
            if (aSttContains && !bSttContains) return -1;
            if (!aSttContains && bSttContains) return 1;

            // Priority 4: Phone starts with
            const aPhoneStarts = aPhone.startsWith(searchLower);
            const bPhoneStarts = bPhone.startsWith(searchLower);
            if (aPhoneStarts && !bPhoneStarts) return -1;
            if (!aPhoneStarts && bPhoneStarts) return 1;

            // Priority 5: Phone contains
            const aPhoneContains = aPhone.includes(searchLower);
            const bPhoneContains = bPhone.includes(searchLower);
            if (aPhoneContains && !bPhoneContains) return -1;
            if (!aPhoneContains && bPhoneContains) return 1;

            // Priority 6: Name starts with
            const aNameStarts = aName.startsWith(searchLower);
            const bNameStarts = bName.startsWith(searchLower);
            if (aNameStarts && !bNameStarts) return -1;
            if (!aNameStarts && bNameStarts) return 1;

            // Priority 7: Name contains
            const aNameContains = aName.includes(searchLower);
            const bNameContains = bName.includes(searchLower);
            if (aNameContains && !bNameContains) return -1;
            if (!aNameContains && bNameContains) return 1;

            // Default: keep original order
            return 0;
        });
    }

    // NOTE: Visual merging disabled - each order shows as separate row
    // Merge products button (mergeProductsBtn) still works independently
    // filteredData = mergeOrdersByPhone(filteredData);

    // Reset sorting when filters change
    resetSorting();

    displayedData = filteredData;
    renderTable();
    updateStats();
    updatePageInfo();
    updateSearchResultCount();
}

function matchesSearchQuery(order, query) {
    const searchableText = [
        String(order.SessionIndex || ''), // STT - Priority field
        order.Code,
        order.Name,
        order.Telephone,
        order.Address,
        order.Note,
        order.StatusText,
    ]
        .join(" ")
        .toLowerCase();
    const normalizedText = removeVietnameseTones(searchableText);
    const normalizedQuery = removeVietnameseTones(query);
    return (
        searchableText.includes(query) ||
        normalizedText.includes(normalizedQuery)
    );
}

function removeVietnameseTones(str) {
    if (!str) return "";
    return str
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/Ä‘/g, "d")
        .replace(/Ä/g, "D");
}

function updateSearchResultCount() {
    document.getElementById("searchResultCount").textContent =
        filteredData.length.toLocaleString("vi-VN");
}

// Copy phone number to clipboard
function copyPhoneNumber(phone) {
    if (!phone) return;
    navigator.clipboard.writeText(phone).catch(err => {
        console.error('Failed to copy phone number:', err);
    });
}

function highlightSearchText(text, query) {
    if (!query || !text) return text;
    const regex = new RegExp(`(${escapeRegex(query)})`, "gi");
    return text.replace(regex, '<span class="highlight">$1</span>');
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// =====================================================
// DATA FETCHING & CAMPAIGN LOADING
// =====================================================
function formatDateTimeLocal(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day}T${hours}:${minutes}`;
}

function convertToUTC(dateTimeLocal) {
    if (!dateTimeLocal) {
        console.error("[DATE] Empty date value provided to convertToUTC");
        throw new Error("Date value is required");
    }

    const date = new Date(dateTimeLocal);

    if (isNaN(date.getTime())) {
        console.error("[DATE] Invalid date value:", dateTimeLocal);
        throw new Error(`Invalid date value: ${dateTimeLocal}`);
    }

    return date.toISOString();
}

async function handleLoadCampaigns() {
    // Validate dates
    const startDateValue = document.getElementById("startDate").value;
    const endDateValue = document.getElementById("endDate").value;

    if (!startDateValue || !endDateValue) {
        if (window.notificationManager) {
            window.notificationManager.error("Vui lÃ²ng chá»n khoáº£ng thá»i gian (Tá»« ngÃ y - Äáº¿n ngÃ y)", 3000);
        } else {
            alert("Vui lÃ²ng chá»n khoáº£ng thá»i gian (Tá»« ngÃ y - Äáº¿n ngÃ y)");
        }
        return;
    }

    const skip = parseInt(document.getElementById("skipRangeFilter").value) || 0;
    await loadCampaignList(skip, startDateValue, endDateValue);
}

async function loadCampaignList(skip = 0, startDateLocal = null, endDateLocal = null, autoLoad = false) {
    try {
        showLoading(true);

        let url;
        if (startDateLocal && endDateLocal) {
            // Sá»­ dá»¥ng date filter vá»›i skip - Táº£i 3000 Ä‘Æ¡n hÃ ng
            const startDate = convertToUTC(startDateLocal);
            const endDate = convertToUTC(endDateLocal);
            const filter = `(DateCreated ge ${startDate} and DateCreated le ${endDate})`;
            // OPTIMIZATION: Only fetch necessary fields for campaign list
            url = `${API_CONFIG.WORKER_URL}/api/odata/SaleOnline_Order/ODataService.GetView?$top=3000&$skip=${skip}&$orderby=DateCreated desc&$filter=${encodeURIComponent(filter)}&$count=true&$select=LiveCampaignId,LiveCampaignName,DateCreated`;

            console.log(`[CAMPAIGNS] Loading campaigns with skip=${skip}, date range: ${startDateLocal} to ${endDateLocal}, autoLoad=${autoLoad}`);
        } else {
            // Fallback: khÃ´ng cÃ³ date filter - Táº£i 3000 Ä‘Æ¡n hÃ ng
            // OPTIMIZATION: Only fetch necessary fields for campaign list
            url = `${API_CONFIG.WORKER_URL}/api/odata/SaleOnline_Order/ODataService.GetView?$top=3000&$skip=${skip}&$orderby=DateCreated desc&$count=true&$select=LiveCampaignId,LiveCampaignName,DateCreated`;

            console.log(`[CAMPAIGNS] Loading campaigns with skip=${skip}, no date filter, autoLoad=${autoLoad}`);
        }

        const headers = await window.tokenManager.getAuthHeader();
        const response = await API_CONFIG.smartFetch(url, {
            headers: { ...headers, accept: "application/json" },
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        const orders = data.value || [];
        const totalCount = data["@odata.count"] || 0;

        console.log(`[CAMPAIGNS] Loaded ${orders.length} orders out of ${totalCount} total`);

        // ğŸ¯ BÆ¯á»šC 1: Gá»˜P CÃC CHIáº¾N Dá»ŠCH THEO LiveCampaignId
        const campaignsByCampaignId = new Map(); // key: LiveCampaignId, value: { name, dates: Set }

        orders.forEach((order) => {
            if (!order.LiveCampaignId) return;

            // Láº¥y ngÃ y tá»« DateCreated (bá» pháº§n giá»)
            const dateCreated = new Date(order.DateCreated);
            const dateKey = `${dateCreated.getFullYear()}-${String(dateCreated.getMonth() + 1).padStart(2, '0')}-${String(dateCreated.getDate()).padStart(2, '0')}`;

            if (!campaignsByCampaignId.has(order.LiveCampaignId)) {
                campaignsByCampaignId.set(order.LiveCampaignId, {
                    campaignId: order.LiveCampaignId,
                    campaignName: order.LiveCampaignName || "KhÃ´ng cÃ³ tÃªn",
                    dates: new Set(),
                    latestDate: order.DateCreated
                });
            }

            const campaign = campaignsByCampaignId.get(order.LiveCampaignId);
            campaign.dates.add(dateKey);

            // Keep latest date for sorting
            if (new Date(order.DateCreated) > new Date(campaign.latestDate)) {
                campaign.latestDate = order.DateCreated;
            }
        });

        // ğŸ¯ HÃ€M PARSE NGÃ€Y Tá»ª TÃŠN CHIáº¾N Dá»ŠCH
        function extractCampaignDate(campaignName) {
            // TÃ¬m pattern: DD/MM/YY hoáº·c DD/MM/YYYY (vÃ­ dá»¥: "11/11/25", "15/11/2025")
            const match = campaignName.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
            if (!match) return null;

            let day = match[1].padStart(2, '0');
            let month = match[2].padStart(2, '0');
            let year = match[3];

            // Normalize year: convert YY â†’ YYYY (assume 20YY)
            if (year.length === 2) {
                year = '20' + year;
            }

            // Return normalized format: DD/MM/YYYY
            return `${day}/${month}/${year}`;
        }

        // ğŸ¯ BÆ¯á»šC 2: Gá»˜P CÃC CHIáº¾N Dá»ŠCH THEO NGÃ€Y TRONG TÃŠN
        // VÃ­ dá»¥: "HOUSE 11/11/25" + "STORE 11/11/25" â†’ "11/11/25 - HOUSE + STORE"
        const campaignsByDateKey = new Map(); // key: ngÃ y tá»« tÃªn (vÃ­ dá»¥: "11/11/25")

        Array.from(campaignsByCampaignId.values()).forEach(campaign => {
            const dateKey = extractCampaignDate(campaign.campaignName);

            // Sá»­ dá»¥ng dateKey hoáº·c tÃªn gá»‘c náº¿u khÃ´ng parse Ä‘Æ°á»£c
            const groupKey = dateKey || campaign.campaignName;

            if (!campaignsByDateKey.has(groupKey)) {
                campaignsByDateKey.set(groupKey, {
                    campaignIds: [],
                    campaignNames: [],
                    dates: new Set(),
                    latestDate: campaign.latestDate,
                    dateKey: dateKey
                });
            }

            const merged = campaignsByDateKey.get(groupKey);
            merged.campaignIds.push(campaign.campaignId);
            merged.campaignNames.push(campaign.campaignName);
            campaign.dates.forEach(d => merged.dates.add(d));

            // Keep latest date
            if (new Date(campaign.latestDate) > new Date(merged.latestDate)) {
                merged.latestDate = campaign.latestDate;
            }
        });

        // ğŸ¯ BÆ¯á»šC 3: Táº O DANH SÃCH CAMPAIGNS ÄÃƒ Gá»˜P
        const mergedCampaigns = [];

        // Sort by latest date descending
        const sortedCampaigns = Array.from(campaignsByDateKey.values())
            .sort((a, b) => new Date(b.latestDate) - new Date(a.latestDate));

        sortedCampaigns.forEach(campaign => {
            const dates = Array.from(campaign.dates).sort((a, b) => b.localeCompare(a));

            // Táº¡o display name
            let displayName;
            const uniqueNames = [...new Set(campaign.campaignNames)];

            if (campaign.dateKey) {
                // CÃ³ ngÃ y tá»« tÃªn â†’ hiá»ƒn thá»‹ ngÃ y + danh sÃ¡ch loáº¡i chiáº¿n dá»‹ch
                const types = uniqueNames.map(name => {
                    // Extract prefix (HOUSE, STORE, etc.) - láº¥y pháº§n trÆ°á»›c dáº¥u cÃ¡ch Ä‘áº§u tiÃªn
                    const prefix = name.split(' ')[0];
                    return prefix;
                }).filter((v, i, a) => a.indexOf(v) === i); // unique types

                const typeStr = types.join(' + ');

                if (dates.length === 1) {
                    displayName = `${campaign.dateKey} - ${typeStr} (${dates[0]})`;
                } else {
                    displayName = `${campaign.dateKey} - ${typeStr} (${dates.length} ngÃ y: ${dates.join(', ')})`;
                }
            } else {
                // KhÃ´ng parse Ä‘Æ°á»£c ngÃ y â†’ giá»¯ tÃªn gá»‘c
                if (dates.length === 1) {
                    displayName = `${uniqueNames[0]} (${dates[0]})`;
                } else {
                    displayName = `${uniqueNames[0]} (${dates.length} ngÃ y: ${dates.join(', ')})`;
                }
            }

            mergedCampaigns.push({
                campaignId: campaign.campaignIds[0], // For backward compatibility
                campaignIds: campaign.campaignIds, // Array of all merged campaign IDs
                displayName: displayName,
                dates: dates,
                latestDate: campaign.latestDate,
                count: dates.length
            });
        });

        console.log(`[CAMPAIGNS] Found ${mergedCampaigns.length} unique campaigns (merged from ${orders.length} orders)`);

        showLoading(false);

        // Populate dropdown vá»›i autoLoad parameter
        await populateCampaignFilter(mergedCampaigns, autoLoad);

        // Hiá»ƒn thá»‹ thÃ´ng bÃ¡o (chá»‰ khi khÃ´ng auto-load Ä‘á»ƒ trÃ¡nh spam)
        if (!autoLoad) {
            if (window.notificationManager) {
                window.notificationManager.success(
                    `Táº£i thÃ nh cÃ´ng ${mergedCampaigns.length} chiáº¿n dá»‹ch tá»« ${orders.length} Ä‘Æ¡n hÃ ng (${skip + 1}-${skip + orders.length}/${totalCount})`,
                    3000
                );
            } else {
                showInfoBanner(`âœ… Táº£i thÃ nh cÃ´ng ${mergedCampaigns.length} chiáº¿n dá»‹ch tá»« ${orders.length} Ä‘Æ¡n hÃ ng`);
            }
        }

    } catch (error) {
        console.error("[CAMPAIGNS] Error loading campaigns:", error);
        showLoading(false);

        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i khi táº£i danh sÃ¡ch chiáº¿n dá»‹ch: ${error.message}`, 4000);
        } else {
            alert("Lá»—i khi táº£i danh sÃ¡ch chiáº¿n dá»‹ch: " + error.message);
        }
    }
}

async function populateCampaignFilter(campaigns, autoLoad = false) {
    const select = document.getElementById("campaignFilter");
    select.innerHTML = '<option value="">-- Chá»n chiáº¿n dá»‹ch --</option>';

    // ğŸ¯ Add Custom option for filtering by order creation date
    const customOption = document.createElement("option");
    customOption.value = "custom";
    customOption.textContent = "ğŸ”® Custom (lá»c theo ngÃ y táº¡o Ä‘Æ¡n)";
    customOption.dataset.campaign = JSON.stringify({ isCustom: true });
    select.appendChild(customOption);

    campaigns.forEach((campaign, index) => {
        const option = document.createElement("option");
        // Sá»­ dá»¥ng index lÃ m value vÃ¬ campaignId giá» lÃ  array
        option.value = index;
        option.textContent = campaign.displayName;
        option.dataset.campaign = JSON.stringify(campaign);
        select.appendChild(option);
    });

    if (campaigns.length > 0) {
        // ğŸ”¥ Load saved preferences from Firebase
        const savedPrefs = await loadFilterPreferencesFromFirebase();
        const customDateContainer = document.getElementById("customDateFilterContainer");
        const customStartDateInput = document.getElementById("customStartDate");

        if (savedPrefs && savedPrefs.isCustomMode) {
            // ğŸ¯ Restore CUSTOM mode from Firebase
            console.log('[FILTER-PREFS] Restoring CUSTOM mode from Firebase');
            select.value = 'custom';

            // Set custom date from Firebase
            if (savedPrefs.customStartDate) {
                customStartDateInput.value = savedPrefs.customStartDate;
            }
            customDateContainer.style.display = "flex";

            // Update selectedCampaign
            selectedCampaign = { isCustom: true };

            // Load general employee ranges for custom mode
            console.log('[EMPLOYEE] Loading general employee ranges for restored custom mode');
            await loadEmployeeRangesForCampaign(null);

            if (autoLoad && savedPrefs.customStartDate) {
                // ğŸ¯ Auto-load data with saved custom date
                console.log('[AUTO-LOAD] Tá»± Ä‘á»™ng táº£i dá»¯ liá»‡u vá»›i custom date:', savedPrefs.customStartDate);

                if (window.notificationManager) {
                    window.notificationManager.info(
                        `Äang táº£i Ä‘Æ¡n hÃ ng tá»« ngÃ y: ${new Date(savedPrefs.customStartDate).toLocaleString('vi-VN')}`,
                        2000,
                        'KhÃ´i phá»¥c tá»« Firebase'
                    );
                }

                await handleSearch();

                if (window.realtimeManager) {
                    console.log('[AUTO-CONNECT] Connecting to Realtime Server (24/7)...');
                    window.realtimeManager.connectServerMode();
                }
            }
        } else if (savedPrefs && savedPrefs.selectedCampaignValue !== undefined && savedPrefs.selectedCampaignValue !== 'custom') {
            // ğŸ¯ Restore saved campaign selection from Firebase
            // â­ FIX: Æ¯u tiÃªn tÃ¬m theo displayName thay vÃ¬ index Ä‘á»ƒ trÃ¡nh lá»—i khi thá»© tá»± campaigns thay Ä‘á»•i
            const savedValue = savedPrefs.selectedCampaignValue;
            const savedName = savedPrefs.selectedCampaignName;

            let foundOptionIndex = -1;

            // â­ Æ¯u tiÃªn 1: TÃ¬m theo displayName (chÃ­nh xÃ¡c hÆ¡n)
            if (savedName) {
                for (let i = 0; i < select.options.length; i++) {
                    const optionCampaign = select.options[i].dataset.campaign;
                    if (optionCampaign) {
                        try {
                            const campaign = JSON.parse(optionCampaign);
                            if (campaign.displayName === savedName) {
                                foundOptionIndex = i;
                                console.log('[FILTER-PREFS] âœ… Found campaign by displayName:', savedName, 'â†’ index:', i);
                                break;
                            }
                        } catch (e) { }
                    }
                }
            }

            // â­ Fallback: TÃ¬m theo index (cÃ¡ch cÅ©)
            if (foundOptionIndex === -1) {
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value === String(savedValue)) {
                        foundOptionIndex = i;
                        console.log('[FILTER-PREFS] Found campaign by index (fallback):', savedValue);
                        break;
                    }
                }
            }

            if (foundOptionIndex !== -1) {
                console.log('[FILTER-PREFS] Restoring saved campaign selection:', savedName || savedValue);
                select.selectedIndex = foundOptionIndex;
                customDateContainer.style.display = "none";
            } else {
                // Saved campaign not in current list, use first campaign
                console.log('[FILTER-PREFS] Saved campaign not found, using first campaign');
                select.value = 0;
                customDateContainer.style.display = "none";
            }

            // Manually update selectedCampaign state
            const selectedOption = select.options[select.selectedIndex];
            selectedCampaign = selectedOption?.dataset.campaign
                ? JSON.parse(selectedOption.dataset.campaign)
                : null;

            // â­ Load employee ranges for the selected campaign
            if (selectedCampaign?.displayName) {
                console.log(`[EMPLOYEE] Auto-loading employee ranges for: ${selectedCampaign.displayName}`);
                await loadEmployeeRangesForCampaign(selectedCampaign.displayName);

                if (allData.length > 0) {
                    console.log(`[EMPLOYEE] Re-rendering table with ${employeeRanges.length} employee ranges`);
                    performTableSearch();
                }
            }

            if (autoLoad) {
                console.log('[AUTO-LOAD] Tá»± Ä‘á»™ng táº£i dá»¯ liá»‡u chiáº¿n dá»‹ch:', selectedCampaign?.displayName || campaigns[0].displayName);

                if (window.notificationManager) {
                    window.notificationManager.info(
                        `Äang táº£i dá»¯ liá»‡u chiáº¿n dá»‹ch: ${selectedCampaign?.displayName || campaigns[0].displayName}`,
                        2000,
                        'KhÃ´i phá»¥c tá»« Firebase'
                    );
                }

                await handleSearch();

                if (window.realtimeManager) {
                    console.log('[AUTO-CONNECT] Connecting to Realtime Server (24/7)...');
                    window.realtimeManager.connectServerMode();
                }
            }
        } else {
            // ğŸ¯ No saved preferences - use default (first campaign)
            select.value = 0;
            customDateContainer.style.display = "none";

            // Manually update selectedCampaign state
            const selectedOption = select.options[select.selectedIndex];
            selectedCampaign = selectedOption?.dataset.campaign
                ? JSON.parse(selectedOption.dataset.campaign)
                : null;

            // â­ Load employee ranges for the selected campaign
            if (selectedCampaign?.displayName) {
                console.log(`[EMPLOYEE] Auto-loading employee ranges for: ${selectedCampaign.displayName}`);
                await loadEmployeeRangesForCampaign(selectedCampaign.displayName);

                if (allData.length > 0) {
                    console.log(`[EMPLOYEE] Re-rendering table with ${employeeRanges.length} employee ranges`);
                    performTableSearch();
                }
            }

            if (autoLoad) {
                console.log('[AUTO-LOAD] Tá»± Ä‘á»™ng táº£i dá»¯ liá»‡u chiáº¿n dá»‹ch:', campaigns[0].displayName);

                if (window.notificationManager) {
                    window.notificationManager.info(
                        `Äang táº£i dá»¯ liá»‡u chiáº¿n dá»‹ch: ${campaigns[0].displayName}`,
                        2000,
                        'Tá»± Ä‘á»™ng táº£i'
                    );
                }

                await handleSearch();

                if (window.realtimeManager) {
                    console.log('[AUTO-CONNECT] Connecting to Realtime Server (24/7)...');
                    window.realtimeManager.connectServerMode();
                }
            } else {
                console.log('[MANUAL-SELECT] ÄÃ£ chá»n chiáº¿n dá»‹ch Ä‘áº§u tiÃªn (chá» ngÆ°á»i dÃ¹ng báº¥m Táº£i):', campaigns[0].displayName);
            }
        }
    }
}

async function handleCampaignChange() {
    const select = document.getElementById("campaignFilter");
    const selectedOption = select.options[select.selectedIndex];
    selectedCampaign = selectedOption?.dataset.campaign
        ? JSON.parse(selectedOption.dataset.campaign)
        : null;

    // ğŸ¯ Handle Custom mode - show/hide custom date input
    const customDateContainer = document.getElementById("customDateFilterContainer");
    if (selectedCampaign?.isCustom) {
        customDateContainer.style.display = "flex";
        console.log('[CUSTOM-FILTER] Custom mode selected - showing custom date input');

        // Set default custom date to start of today if empty
        const customStartDateInput = document.getElementById("customStartDate");
        if (!customStartDateInput.value) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            customStartDateInput.value = formatDateTimeLocal(today);
        }

        // ğŸ”¥ Save custom mode preference to Firebase
        saveFilterPreferencesToFirebase({
            selectedCampaignValue: 'custom',
            isCustomMode: true,
            customStartDate: customStartDateInput.value
        });

        // Load employee ranges (general, no campaign)
        console.log('[EMPLOYEE] Loading general employee ranges for custom mode');
        await loadEmployeeRangesForCampaign(null);

        // Don't auto-search yet, wait for user to confirm custom date
        return;
    } else {
        customDateContainer.style.display = "none";

        // ğŸ”¥ Save campaign selection to Firebase (not custom mode)
        // â­ FIX: LÆ°u displayName thay vÃ¬ index Ä‘á»ƒ trÃ¡nh lá»—i khi thá»© tá»± campaigns thay Ä‘á»•i
        if (select.value && select.value !== '' && selectedCampaign?.displayName) {
            saveFilterPreferencesToFirebase({
                selectedCampaignValue: select.value,
                selectedCampaignName: selectedCampaign.displayName, // â­ LÆ°u tÃªn campaign
                isCustomMode: false,
                customStartDate: null
            });
        }
    }

    // ğŸ”¥ Cleanup old Firebase TAG listeners
    cleanupTagRealtimeListeners();

    // â­ QUAN TRá»ŒNG: Load employee ranges TRÆ¯á»šC KHI load dá»¯ liá»‡u
    // Ä‘á»ƒ Ä‘áº£m báº£o báº£ng Ä‘Æ°á»£c phÃ¢n chia Ä‘Ãºng ngay tá»« Ä‘áº§u
    if (selectedCampaign?.displayName) {
        console.log(`[EMPLOYEE] Loading employee ranges for campaign: ${selectedCampaign.displayName}`);
        await loadEmployeeRangesForCampaign(selectedCampaign.displayName);
    } else {
        console.log('[EMPLOYEE] Loading general employee ranges (no campaign selected)');
        await loadEmployeeRangesForCampaign(null);
    }

    // Tá»± Ä‘á»™ng load dá»¯ liá»‡u khi chá»n chiáº¿n dá»‹ch
    if (selectedCampaign?.campaignId || selectedCampaign?.campaignIds) {
        await handleSearch();

        // ğŸ¯ AUTO-CONNECT REALTIME SERVER
        if (window.realtimeManager) {
            console.log('[AUTO-CONNECT] Connecting to Realtime Server (24/7)...');
            window.realtimeManager.connectServerMode();
        }

        // ğŸ”¥ Setup new Firebase TAG listeners for this campaign
        setupTagRealtimeListeners();
    }
}

// ğŸ¯ Handle custom start date change - auto-fill end date (+3 days) and trigger search
async function handleCustomDateChange() {
    const customStartDateInput = document.getElementById("customStartDate");
    const customEndDateInput = document.getElementById("customEndDate");

    if (!customStartDateInput.value) {
        console.log('[CUSTOM-FILTER] Start date cleared, waiting for valid date...');
        return;
    }

    // Auto-fill end date = start date + 3 days at 00:00
    const startDate = new Date(customStartDateInput.value);
    const endDate = new Date(startDate.getTime() + 3 * 24 * 60 * 60 * 1000);
    endDate.setHours(0, 0, 0, 0);
    customEndDateInput.value = formatDateTimeLocal(endDate);

    console.log(`[CUSTOM-FILTER] Date range: ${customStartDateInput.value} -> ${customEndDateInput.value}`);

    // Ensure custom mode is set
    selectedCampaign = { isCustom: true };

    // ğŸ”¥ Save custom dates to Firebase
    saveFilterPreferencesToFirebase({
        selectedCampaignValue: 'custom',
        isCustomMode: true,
        customStartDate: customStartDateInput.value,
        customEndDate: customEndDateInput.value
    });

    // Cleanup old listeners and data
    cleanupTagRealtimeListeners();

    // Notify user
    if (window.notificationManager) {
        const startDisplay = new Date(customStartDateInput.value).toLocaleDateString('vi-VN');
        const endDisplay = new Date(customEndDateInput.value).toLocaleDateString('vi-VN');
        window.notificationManager.info(
            `Äang táº£i Ä‘Æ¡n hÃ ng: ${startDisplay} - ${endDisplay}`,
            2000
        );
    }

    // Trigger search
    await handleSearch();

    // Setup new TAG listeners
    setupTagRealtimeListeners();
}

// ğŸ¯ Handle custom end date change - just trigger search (no auto-fill)
async function handleCustomEndDateChange() {
    const customStartDateInput = document.getElementById("customStartDate");
    const customEndDateInput = document.getElementById("customEndDate");

    if (!customStartDateInput.value || !customEndDateInput.value) {
        console.log('[CUSTOM-FILTER] Missing start or end date...');
        return;
    }

    console.log(`[CUSTOM-FILTER] End date changed: ${customStartDateInput.value} -> ${customEndDateInput.value}`);

    // Ensure custom mode is set
    selectedCampaign = { isCustom: true };

    // ğŸ”¥ Save custom dates to Firebase
    saveFilterPreferencesToFirebase({
        selectedCampaignValue: 'custom',
        isCustomMode: true,
        customStartDate: customStartDateInput.value,
        customEndDate: customEndDateInput.value
    });

    // Cleanup old listeners and data
    cleanupTagRealtimeListeners();

    // Trigger search
    await handleSearch();

    // Setup new TAG listeners
    setupTagRealtimeListeners();
}

async function reloadTableData() {
    const btn = document.getElementById('reloadTableBtn');
    const icon = btn ? btn.querySelector('i') : null;

    if (btn) btn.disabled = true;
    if (icon) icon.classList.add('fa-spin');

    try {
        // ğŸ¯ SIMPLIFIED: Always use Custom Mode - just reload with current date range
        await handleSearch();

        if (window.notificationManager) {
            window.notificationManager.success("ÄÃ£ táº£i láº¡i dá»¯ liá»‡u báº£ng thÃ nh cÃ´ng");
        }
    } catch (error) {
        console.error("Error reloading table:", error);
        if (window.notificationManager) {
            window.notificationManager.error("Lá»—i khi táº£i láº¡i dá»¯ liá»‡u: " + error.message);
        } else {
            alert("Lá»—i khi táº£i láº¡i dá»¯ liá»‡u: " + error.message);
        }
    } finally {
        if (btn) btn.disabled = false;
        if (icon) icon.classList.remove('fa-spin');
    }
}

async function handleSearch() {
    // ğŸ¯ SIMPLIFIED: Always use Custom Mode
    // Validate custom date range
    const customStartDateValue = document.getElementById("customStartDate").value;
    const customEndDateValue = document.getElementById("customEndDate").value;

    if (!customStartDateValue) {
        if (window.notificationManager) {
            window.notificationManager.error("Vui lÃ²ng chá»n Tá»« ngÃ y", 3000);
        } else {
            alert("Vui lÃ²ng chá»n Tá»« ngÃ y");
        }
        return;
    }

    if (!customEndDateValue) {
        if (window.notificationManager) {
            window.notificationManager.error("Vui lÃ²ng chá»n Äáº¿n ngÃ y", 3000);
        } else {
            alert("Vui lÃ²ng chá»n Äáº¿n ngÃ y");
        }
        return;
    }

    // Ensure selectedCampaign is set to custom mode
    selectedCampaign = { isCustom: true };

    // Update UI label with date range
    const activeCampaignLabel = document.getElementById('activeCampaignLabel');
    if (activeCampaignLabel) {
        const startDisplay = new Date(customStartDateValue).toLocaleDateString('vi-VN');
        const endDisplay = new Date(customEndDateValue).toLocaleDateString('vi-VN');
        activeCampaignLabel.innerHTML = `<i class="fas fa-calendar-check"></i> ${startDisplay} - ${endDisplay}`;
    }

    // Abort any ongoing background loading
    if (isLoadingInBackground) {
        console.log('[PROGRESSIVE] Aborting background loading for new search...');
        loadingAborted = true;
        // Wait a bit for background loading to stop
        await new Promise(resolve => setTimeout(resolve, 200));
    }

    window.cacheManager.clear("orders");
    searchQuery = "";
    document.getElementById("tableSearchInput").value = "";
    document.getElementById("searchClearBtn").classList.remove("active");
    allData = [];
    renderedCount = 0; // Reset rendered count to prevent duplicate rows
    await fetchOrders();
}

// Progressive loading state
let isLoadingInBackground = false;

// Track if conversations are being fetched (for loading indicator in messages column)
let isLoadingConversations = false;

// Guard flag to prevent duplicate fetchOrders calls
let isFetchingOrders = false;

async function fetchOrders() {
    // Prevent duplicate calls
    if (isFetchingOrders) {
        console.log('[FETCH-ORDERS] Already fetching, skipping duplicate call...');
        return;
    }
    isFetchingOrders = true;

    try {
        showLoading(true);
        loadingAborted = false;

        // ğŸ¯ Check for custom mode
        const isCustomMode = selectedCampaign?.isCustom;
        let filter;

        // ğŸ¯ SIMPLIFIED: Always use Custom Mode with customStartDate and customEndDate
        const customStartDateValue = document.getElementById("customStartDate").value;
        const customEndDateValue = document.getElementById("customEndDate").value || document.getElementById("endDate").value;

        if (!customStartDateValue || !customEndDateValue) {
            throw new Error("Vui lÃ²ng chá»n khoáº£ng thá»i gian (Tá»« ngÃ y - Äáº¿n ngÃ y)");
        }

        const customStartDate = convertToUTC(customStartDateValue);
        const customEndDate = convertToUTC(customEndDateValue);
        filter = `(DateCreated ge ${customStartDate} and DateCreated le ${customEndDate})`;
        console.log(`[FETCH-CUSTOM] Fetching orders: ${customStartDateValue} -> ${customEndDateValue}`);

        const PAGE_SIZE = 1000; // API fetch size for background loading
        const INITIAL_PAGE_SIZE = 50; // Smaller size for instant first load
        const UPDATE_EVERY = 200; // Update UI every 200 orders
        let skip = 0;
        let hasMore = true;
        allData = [];
        renderedCount = 0; // Reset rendered count to prevent duplicate rows on new fetch
        const headers = await window.tokenManager.getAuthHeader();

        // ===== PHASE 1: Load first batch and show immediately =====
        console.log('[PROGRESSIVE] Loading first batch...');
        const firstUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order/ODataService.GetView?$top=${INITIAL_PAGE_SIZE}&$skip=${skip}&$orderby=DateCreated desc&$filter=${encodeURIComponent(filter)}&$count=true`;
        const firstResponse = await fetch(firstUrl, {
            headers: { ...headers, accept: "application/json" },
        });
        if (!firstResponse.ok) throw new Error(`HTTP ${firstResponse.status}`);
        const firstData = await firstResponse.json();
        const firstOrders = firstData.value || [];
        totalCount = firstData["@odata.count"] || 0;

        allData = firstOrders;
        // Show UI immediately with first batch
        document.getElementById("statsBar").style.display = "flex";
        document.getElementById("tableContainer").style.display = "block";
        document.getElementById("searchSection").classList.add("active");

        performTableSearch(); // Apply merging and filters immediately
        updateSearchResultCount();
        showInfoBanner(
            `â³ ÄÃ£ táº£i ${allData.length}/${totalCount} Ä‘Æ¡n hÃ ng. Äang táº£i thÃªm...`,
        );
        sendDataToTab2();
        // Also update Overview tab with first batch
        sendOrdersDataToOverview();

        // âš¡ PHASE 2 OPTIMIZATION: Load conversations in BACKGROUND (non-blocking)
        // This allows users to interact with the table immediately
        // Chat columns will show loading spinners, then update when data arrives
        console.log('[PROGRESSIVE] Loading conversations in background...');
        if (window.chatDataManager) {
            // Set loading state for messages column indicator (shows spinner)
            isLoadingConversations = true;

            // Re-render to show loading spinners in chat columns
            performTableSearch();

            // Collect unique channel IDs from orders (parse from Facebook_PostId)
            const channelIds = [...new Set(
                allData
                    .map(order => window.chatDataManager.parseChannelId(order.Facebook_PostId))
                    .filter(id => id) // Remove null/undefined
            )];
            console.log('[PROGRESSIVE] Found channel IDs:', channelIds);

            // âš¡ Run conversations loading in BACKGROUND (no await!)
            (async () => {
                try {
                    // FIX: fetchConversations now uses Type="all" to fetch both messages and comments in 1 request
                    // No need to call both methods anymore - this reduces API calls by 50%!
                    // Force refresh (true) to always fetch fresh data when searching
                    await window.chatDataManager.fetchConversations(true, channelIds);

                    // Fetch Pancake conversations for unread info
                    if (window.pancakeDataManager) {
                        console.log('[PANCAKE] Fetching conversations for unread info...');
                        await window.pancakeDataManager.fetchConversations(true);
                        console.log('[PANCAKE] âœ… Conversations fetched');
                    }

                    // Clear loading state
                    isLoadingConversations = false;
                    console.log('[PROGRESSIVE] âœ… Conversations loaded (background)');

                    // Re-render with actual chat data
                    performTableSearch();
                } catch (err) {
                    console.error('[PROGRESSIVE] âŒ Conversations loading error:', err);
                    isLoadingConversations = false;
                }
            })();
        } else {
            // chatDataManager not ready yet - will be handled by Phase 1 re-render
            console.log('[PROGRESSIVE] chatDataManager not ready, skipping conversations for now');
        }

        // Load tags in background
        loadAvailableTags().catch(err => console.error('[TAGS] Error loading tags:', err));

        // Load user identifier for quick tag feature
        loadCurrentUserIdentifier().catch(err => console.error('[QUICK-TAG] Error loading identifier:', err));

        // Detect edited notes using Firebase snapshots (fast, no API spam!)
        detectEditedNotes().then(() => {
            // Re-apply filters and merge with noteEdited flags
            performTableSearch();
            console.log('[NOTE-TRACKER] Table re-rendered with edit indicators');
        }).catch(err => console.error('[NOTE-TRACKER] Error detecting edited notes:', err));

        // Hide loading overlay after first batch
        showLoading(false);

        // ===== PHASE 2: Continue loading remaining orders in background =====
        hasMore = firstOrders.length === INITIAL_PAGE_SIZE;
        skip += INITIAL_PAGE_SIZE;

        if (hasMore) {
            isLoadingInBackground = true;
            console.log('[PROGRESSIVE] Starting background loading...');

            // Run background loading
            (async () => {
                try {
                    let lastUpdateCount = allData.length; // Track when we last updated

                    while (hasMore && !loadingAborted) {
                        const url = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order/ODataService.GetView?$top=${PAGE_SIZE}&$skip=${skip}&$orderby=DateCreated desc&$filter=${encodeURIComponent(filter)}`;
                        const response = await API_CONFIG.smartFetch(url, {
                            headers: { ...headers, accept: "application/json" },
                        });
                        if (!response.ok) {
                            console.error(`[PROGRESSIVE] Error fetching batch at skip=${skip}`);
                            break;
                        }

                        const data = await response.json();
                        const orders = data.value || [];

                        if (orders.length > 0) {
                            allData = allData.concat(orders);

                            // Update table every UPDATE_EVERY orders OR if this is the last batch
                            const shouldUpdate =
                                allData.length - lastUpdateCount >= UPDATE_EVERY ||
                                orders.length < PAGE_SIZE;

                            if (shouldUpdate) {
                                console.log(`[PROGRESSIVE] Updating table: ${allData.length}/${totalCount} orders`);
                                performTableSearch(); // Apply merging, employee filtering, and all other filters
                                updateSearchResultCount();
                                showInfoBanner(
                                    `â³ ÄÃ£ táº£i ${allData.length}/${totalCount} Ä‘Æ¡n hÃ ng. Äang táº£i thÃªm...`,
                                );
                                sendDataToTab2();
                                lastUpdateCount = allData.length;
                            }
                        }

                        hasMore = orders.length === PAGE_SIZE;
                        skip += PAGE_SIZE;

                        // Small delay to allow UI interaction
                        if (hasMore) {
                            await new Promise((resolve) => setTimeout(resolve, 100));
                        }
                    }

                    // Final update
                    if (!loadingAborted) {
                        // Set flag to false BEFORE calling performTableSearch
                        // so renderByEmployee() knows loading is complete
                        isLoadingInBackground = false;
                        console.log('[PROGRESSIVE] Background loading completed');
                        performTableSearch(); // Final merge and render
                        updateSearchResultCount();
                        showInfoBanner(
                            `âœ… ÄÃ£ táº£i vÃ  hiá»ƒn thá»‹ TOÃ€N Bá»˜ ${filteredData.length} Ä‘Æ¡n hÃ ng.`,
                        );
                        sendDataToTab2();
                        // Auto-update Tab3 with full data after background loading completes
                        sendOrdersDataToTab3();
                        // Auto-update Overview tab with full data after background loading completes
                        sendOrdersDataToOverview();
                    }

                } catch (error) {
                    console.error('[PROGRESSIVE] Background loading error:', error);
                } finally {
                    // Ensure flag is always reset even on error or abort
                    isLoadingInBackground = false;
                }
            })();
        } else {
            // No more data, we're done
            showInfoBanner(
                `âœ… ÄÃ£ táº£i vÃ  hiá»ƒn thá»‹ TOÃ€N Bá»˜ ${filteredData.length} Ä‘Æ¡n hÃ ng.`,
            );
        }

    } catch (error) {
        console.error("Error fetching data:", error);

        // Better error messages
        let errorMessage = "Lá»—i khi táº£i dá»¯ liá»‡u: ";
        if (error.message.includes("Invalid date")) {
            errorMessage += "NgÃ y thÃ¡ng khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra láº¡i khoáº£ng thá»i gian.";
        } else if (error.message.includes("Date value is required")) {
            errorMessage += "Vui lÃ²ng chá»n khoáº£ng thá»i gian (Tá»« ngÃ y - Äáº¿n ngÃ y).";
        } else {
            errorMessage += error.message;
        }

        if (window.notificationManager) {
            window.notificationManager.error(errorMessage, 4000);
        } else {
            alert(errorMessage);
        }

        showLoading(false);
    } finally {
        // Reset fetching flag to allow subsequent calls
        isFetchingOrders = false;
    }
}

// =====================================================
// MANUAL ASSIGN "GIá» TRá»NG" TAG (FOR SELECTED ORDERS)
// =====================================================
async function assignEmptyCartTagToSelected() {
    try {
        // Láº¥y danh sÃ¡ch Ä‘Æ¡n hÃ ng Ä‘Ã£ Ä‘Æ°á»£c chá»n
        const checkboxes = document.querySelectorAll('tbody input[type="checkbox"]:checked');
        const selectedOrderIds = Array.from(checkboxes).map(cb => cb.value);

        if (selectedOrderIds.length === 0) {
            if (window.notificationManager) {
                window.notificationManager.warning('Vui lÃ²ng chá»n Ã­t nháº¥t 1 Ä‘Æ¡n hÃ ng', 3000);
            } else {
                alert('Vui lÃ²ng chá»n Ã­t nháº¥t 1 Ä‘Æ¡n hÃ ng');
            }
            return;
        }

        console.log(`[ASSIGN-TAG] Processing ${selectedOrderIds.length} selected orders...`);

        // Load tags náº¿u chÆ°a cÃ³
        if (availableTags.length === 0) {
            console.log('[ASSIGN-TAG] Loading tags...');
            await loadAvailableTags();
        }

        // TÃ¬m tag "GIá» TRá»NG" trong availableTags
        const emptyCartTag = availableTags.find(tag =>
            tag.Name && tag.Name.toUpperCase() === "GIá» TRá»NG"
        );

        if (!emptyCartTag) {
            if (window.notificationManager) {
                window.notificationManager.error('KhÃ´ng tÃ¬m tháº¥y tag "GIá» TRá»NG" trong há»‡ thá»‘ng', 4000);
            } else {
                alert('KhÃ´ng tÃ¬m tháº¥y tag "GIá» TRá»NG" trong há»‡ thá»‘ng');
            }
            return;
        }

        console.log('[ASSIGN-TAG] Found "GIá» TRá»NG" tag:', emptyCartTag);

        // Lá»c cÃ¡c Ä‘Æ¡n hÃ ng cÃ³ TotalQuantity = 0 vÃ  chÆ°a cÃ³ tag "GIá» TRá»NG"
        const ordersNeedingTag = allData.filter(order => {
            // Pháº£i náº±m trong danh sÃ¡ch selected
            if (!selectedOrderIds.includes(order.Id)) return false;

            // Check TotalQuantity = 0
            if (order.TotalQuantity !== 0) return false;

            // Check xem Ä‘Ã£ cÃ³ tag "GIá» TRá»NG" chÆ°a
            if (order.Tags) {
                try {
                    const tags = JSON.parse(order.Tags);
                    if (Array.isArray(tags)) {
                        const hasEmptyCartTag = tags.some(tag =>
                            tag.Name && tag.Name.toUpperCase() === "GIá» TRá»NG"
                        );
                        if (hasEmptyCartTag) return false; // ÄÃ£ cÃ³ tag rá»“i
                    }
                } catch (e) {
                    // Parse error, coi nhÆ° chÆ°a cÃ³ tag
                }
            }

            return true; // Cáº§n thÃªm tag
        });

        if (ordersNeedingTag.length === 0) {
            console.log('[ASSIGN-TAG] No selected orders with TotalQuantity = 0 need "GIá» TRá»NG" tag');

            // Äáº¿m sá»‘ Ä‘Æ¡n cÃ³ sá»‘ lÆ°á»£ng > 0
            const nonZeroCount = allData.filter(order =>
                selectedOrderIds.includes(order.Id) && order.TotalQuantity > 0
            ).length;

            let message = '';
            if (nonZeroCount > 0) {
                message = `${nonZeroCount} Ä‘Æ¡n Ä‘Ã£ chá»n cÃ³ sá»‘ lÆ°á»£ng > 0, khÃ´ng cáº§n gÃ¡n tag "GIá» TRá»NG"`;
            } else {
                message = 'CÃ¡c Ä‘Æ¡n Ä‘Ã£ chá»n Ä‘Ã£ cÃ³ tag "GIá» TRá»NG" rá»“i';
            }

            if (window.notificationManager) {
                window.notificationManager.info(message, 3000);
            } else {
                alert(message);
            }
            return;
        }

        console.log(`[ASSIGN-TAG] Found ${ordersNeedingTag.length} orders needing "GIá» TRá»NG" tag`);

        // ThÃ´ng bÃ¡o cho user
        if (window.notificationManager) {
            window.notificationManager.info(
                `Äang gÃ¡n tag "GIá» TRá»NG" cho ${ordersNeedingTag.length} Ä‘Æ¡n hÃ ng...`,
                3000
            );
        }

        // GÃ¡n tag cho tá»«ng order (vá»›i delay Ä‘á»ƒ trÃ¡nh spam API)
        let successCount = 0;
        let failCount = 0;

        for (const order of ordersNeedingTag) {
            try {
                // Láº¥y tags hiá»‡n táº¡i cá»§a order
                let currentTags = [];
                if (order.Tags) {
                    try {
                        currentTags = JSON.parse(order.Tags);
                    } catch (e) {
                        currentTags = [];
                    }
                }

                // ThÃªm tag "GIá» TRá»NG"
                const newTags = [
                    ...currentTags,
                    {
                        Id: emptyCartTag.Id,
                        Name: emptyCartTag.Name,
                        Color: emptyCartTag.Color
                    }
                ];

                // Call API Ä‘á»ƒ gÃ¡n tag
                const headers = await window.tokenManager.getAuthHeader();
                const payload = {
                    Tags: newTags.map(tag => ({
                        Id: tag.Id,
                        Color: tag.Color,
                        Name: tag.Name,
                    })),
                    OrderId: order.Id,
                };

                const response = await API_CONFIG.smartFetch(
                    "https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag",
                    {
                        method: "POST",
                        headers: {
                            ...headers,
                            "Content-Type": "application/json",
                            Accept: "application/json",
                        },
                        body: JSON.stringify(payload),
                    }
                );

                if (response.ok) {
                    // Cáº­p nháº­t tags trong allData
                    const updatedData = { Tags: JSON.stringify(newTags) };
                    updateOrderInTable(order.Id, updatedData);
                    successCount++;
                    console.log(`[ASSIGN-TAG] âœ“ Tagged order ${order.Code}`);
                } else {
                    failCount++;
                    console.error(`[ASSIGN-TAG] âœ— Failed to tag order ${order.Code}: HTTP ${response.status}`);
                }

                // Delay 500ms giá»¯a cÃ¡c requests Ä‘á»ƒ trÃ¡nh spam API
                await new Promise(resolve => setTimeout(resolve, 500));

            } catch (error) {
                failCount++;
                console.error(`[ASSIGN-TAG] âœ— Error tagging order ${order.Code}:`, error);
            }
        }

        // ThÃ´ng bÃ¡o káº¿t quáº£
        console.log(`[ASSIGN-TAG] Completed: ${successCount} success, ${failCount} failed`);

        if (window.notificationManager) {
            if (successCount > 0) {
                window.notificationManager.success(
                    `ÄÃ£ gÃ¡n tag "GIá» TRá»NG" cho ${successCount} Ä‘Æ¡n hÃ ng${failCount > 0 ? ` (${failCount} lá»—i)` : ''}`,
                    4000
                );
            }
            if (failCount > 0 && successCount === 0) {
                window.notificationManager.error(
                    `KhÃ´ng thá»ƒ gÃ¡n tag cho ${failCount} Ä‘Æ¡n hÃ ng`,
                    4000
                );
            }
        }

        // Clear cache vÃ  refresh UI
        if (successCount > 0) {
            window.cacheManager.clear("orders");
            renderTable();
        }

    } catch (error) {
        console.error('[ASSIGN-TAG] Error in assignEmptyCartTagToSelected:', error);
        if (window.notificationManager) {
            window.notificationManager.error(`Lá»—i: ${error.message}`, 4000);
        }
    }
}

// =====================================================
// RENDERING & UI UPDATES
// =====================================================

// ğŸ”„ Cáº¬P NHáº¬T ORDER TRONG Báº¢NG SAU KHI SAVE
function updateOrderInTable(orderId, updatedOrderData) {
    console.log('[UPDATE] Updating order in table:', orderId);

    // Lá»c bá» cÃ¡c trÆ°á»ng undefined Ä‘á»ƒ trÃ¡nh ghi Ä‘Ã¨ dá»¯ liá»‡u cÃ³ sáºµn (nhÆ° Tags)
    const cleanedData = Object.keys(updatedOrderData).reduce((acc, key) => {
        if (updatedOrderData[key] !== undefined) {
            acc[key] = updatedOrderData[key];
        }
        return acc;
    }, {});

    // 1. TÃ¬m vÃ  cáº­p nháº­t trong allData
    const indexInAll = allData.findIndex(order => order.Id === orderId);
    if (indexInAll !== -1) {
        allData[indexInAll] = { ...allData[indexInAll], ...cleanedData };
        console.log('[UPDATE] Updated in allData at index:', indexInAll);
    }

    // 2. TÃ¬m vÃ  cáº­p nháº­t trong filteredData
    const indexInFiltered = filteredData.findIndex(order => order.Id === orderId);
    if (indexInFiltered !== -1) {
        filteredData[indexInFiltered] = { ...filteredData[indexInFiltered], ...cleanedData };
        console.log('[UPDATE] Updated in filteredData at index:', indexInFiltered);
    }

    // 3. TÃ¬m vÃ  cáº­p nháº­t trong displayedData
    const indexInDisplayed = displayedData.findIndex(order => order.Id === orderId);
    if (indexInDisplayed !== -1) {
        displayedData[indexInDisplayed] = { ...displayedData[indexInDisplayed], ...cleanedData };
        console.log('[UPDATE] Updated in displayedData at index:', indexInDisplayed);
    }

    // 4. Re-apply all filters and re-render table
    // This ensures realtime filter updates (e.g., removing a tag will hide the order if filtering by that tag)
    performTableSearch();

    // 5. Cáº­p nháº­t stats (náº¿u tá»•ng tiá»n thay Ä‘á»•i)
    updateStats();

    // 6. Highlight row vá»«a Ä‘Æ°á»£c cáº­p nháº­t
    // highlightUpdatedRow(orderId); // DISABLED: Removed auto-scroll and highlight

    console.log('[UPDATE] âœ“ Table updated successfully');
}

// ğŸŒŸ HIGHLIGHT ROW Vá»ªA Cáº¬P NHáº¬T
// DISABLED: Removed auto-scroll and highlight functionality
// function highlightUpdatedRow(orderId) {
//     setTimeout(() => {
//         // TÃ¬m row trong báº£ng
//         const rows = document.querySelectorAll('#tableBody tr');
//         rows.forEach(row => {
//             const checkbox = row.querySelector('input[type="checkbox"]');
//             if (checkbox && checkbox.value === orderId) {
//                 // ThÃªm class highlight
//                 row.classList.add('product-row-highlight');

//                 // Scroll vÃ o view (náº¿u cáº§n)
//                 row.scrollIntoView({ behavior: 'smooth', block: 'center' });

//                 // Remove highlight sau 2 giÃ¢y
//                 setTimeout(() => {
//                     row.classList.remove('product-row-highlight');
//                 }, 2000);
//             }
//         });
//     }, 100);
// }

// =====================================================
// TABLE SORTING FUNCTIONS
// =====================================================

/**
 * Apply sorting to displayedData based on currentSortColumn and currentSortDirection
 */
function applySorting() {
    if (!currentSortColumn || !currentSortDirection) return;

    const sortableColumns = {
        'phone': { field: 'Telephone', type: 'string' },
        'address': { field: 'Address', type: 'string' },
        'debt': { field: null, type: 'debt' }, // Special: get from cache
        'total': { field: 'TotalAmount', type: 'number' },
        'quantity': { field: 'TotalQuantity', type: 'number' }
    };

    const config = sortableColumns[currentSortColumn];
    if (!config) return;

    displayedData.sort((a, b) => {
        let aVal, bVal;

        if (config.type === 'debt') {
            // Get debt from cache
            aVal = getCachedDebt(a.Telephone) || 0;
            bVal = getCachedDebt(b.Telephone) || 0;
        } else if (config.type === 'number') {
            aVal = Number(a[config.field]) || 0;
            bVal = Number(b[config.field]) || 0;
        } else {
            // String type
            aVal = (a[config.field] || '').toString().trim();
            bVal = (b[config.field] || '').toString().trim();
        }

        // Sorting logic
        if (config.type === 'string') {
            // Empty strings first when ascending
            const aEmpty = !aVal;
            const bEmpty = !bVal;

            if (currentSortDirection === 'asc') {
                if (aEmpty && !bEmpty) return -1;
                if (!aEmpty && bEmpty) return 1;
                if (aEmpty && bEmpty) return 0;
                return aVal.localeCompare(bVal, 'vi');
            } else {
                if (aEmpty && !bEmpty) return 1;
                if (!aEmpty && bEmpty) return -1;
                if (aEmpty && bEmpty) return 0;
                return bVal.localeCompare(aVal, 'vi');
            }
        } else {
            // Number type (including debt)
            if (currentSortDirection === 'asc') {
                return aVal - bVal;
            } else {
                return bVal - aVal;
            }
        }
    });
}

/**
 * Handle column header click for sorting
 * @param {string} column - Column name (phone, address, debt, total, quantity)
 */
function handleSortClick(column) {
    const sortableColumns = ['phone', 'address', 'debt', 'total', 'quantity'];
    if (!sortableColumns.includes(column)) return;

    if (currentSortColumn === column) {
        // Same column: cycle asc â†’ desc â†’ null
        if (currentSortDirection === 'asc') {
            currentSortDirection = 'desc';
        } else if (currentSortDirection === 'desc') {
            currentSortDirection = null;
            currentSortColumn = null;
        }
    } else {
        // Different column: reset and start with asc
        currentSortColumn = column;
        currentSortDirection = 'asc';
    }

    // Update header icons
    updateSortIcons();

    // Re-apply sorting and render
    if (currentSortColumn && currentSortDirection) {
        displayedData = [...filteredData];
        applySorting();
    } else {
        displayedData = [...filteredData];
    }
    renderTable();
}

/**
 * Update sort icons on table headers (supports multiple tables)
 */
function updateSortIcons() {
    const sortableColumns = ['phone', 'address', 'debt', 'total', 'quantity'];

    sortableColumns.forEach(col => {
        // Find all headers with this column (main table + employee tables)
        const headers = document.querySelectorAll(`th[data-column="${col}"]`);

        headers.forEach(th => {
            // Remove existing icon
            const existingIcon = th.querySelector('.sort-icon');
            if (existingIcon) existingIcon.remove();

            // Add new icon
            const icon = document.createElement('span');
            icon.className = 'sort-icon';
            icon.style.marginLeft = '4px';
            icon.style.fontSize = '10px';

            if (currentSortColumn === col) {
                if (currentSortDirection === 'asc') {
                    icon.innerHTML = 'â–²';
                    icon.style.color = '#3b82f6';
                } else if (currentSortDirection === 'desc') {
                    icon.innerHTML = 'â–¼';
                    icon.style.color = '#3b82f6';
                }
            } else {
                icon.innerHTML = 'â‡…';
                icon.style.color = '#9ca3af';
            }

            th.appendChild(icon);
        });
    });
}

/**
 * Reset sorting state
 */
function resetSorting() {
    currentSortColumn = null;
    currentSortDirection = null;
    updateSortIcons();
}

/**
 * Initialize sortable headers using event delegation
 */
function initSortableHeaders() {
    const sortableColumns = ['phone', 'address', 'debt', 'total', 'quantity'];

    // Use event delegation on document for dynamically created tables
    document.addEventListener('click', (e) => {
        const th = e.target.closest('th[data-column]');
        if (!th) return;

        const column = th.getAttribute('data-column');
        if (sortableColumns.includes(column)) {
            handleSortClick(column);
        }
    });

    // Initialize icons after table loads
    setTimeout(updateSortIcons, 500);
}

// Initialize on DOM ready (only once)
let sortableHeadersInitialized = false;
document.addEventListener('DOMContentLoaded', () => {
    if (!sortableHeadersInitialized) {
        sortableHeadersInitialized = true;
        initSortableHeaders();
    }
});

function renderTable() {
    if (displayedData.length === 0) {
        const tbody = document.getElementById("tableBody");
        tbody.innerHTML =
            '<tr><td colspan="18" style="text-align: center; padding: 40px;">KhÃ´ng cÃ³ dá»¯ liá»‡u</td></tr>';
        return;
    }

    // Check if user has admin access via detailedPermissions
    const auth = window.authManager ? window.authManager.getAuthState() : null;
    let isAdmin = auth?.detailedPermissions?.['baocaosaleonline']?.['viewRevenue'] === true ||
        auth?.roleTemplate === 'admin';

    // Fallback: Check username string for Admin (legacy support)
    const currentUserType = auth && auth.userType ? auth.userType : null;
    if (!isAdmin && currentUserType) {
        const lowerName = currentUserType.toLowerCase();
        if (lowerName.includes('admin') || lowerName.includes('quáº£n trá»‹') || lowerName.includes('administrator')) {
            isAdmin = true;
        }
    }

    // Group by employee if ranges are configured AND user is NOT admin
    if (!isAdmin && employeeRanges.length > 0) {
        renderByEmployee();
    } else {
        renderAllOrders();
    }

    // Apply column visibility after rendering
    if (window.columnVisibility) {
        window.columnVisibility.initialize();
    }

    // Update sort icons after rendering
    updateSortIcons();
}

function renderAllOrders() {
    // Set rendering flag to prevent loadMoreRows() from running during render
    isRendering = true;

    const tableContainer = document.getElementById('tableContainer');

    // Show the default table wrapper
    const defaultTableWrapper = tableContainer.querySelector('.table-wrapper');
    if (defaultTableWrapper) {
        defaultTableWrapper.style.display = 'block';
    }

    // Remove any existing employee sections
    const existingSections = tableContainer.querySelectorAll('.employee-section');
    existingSections.forEach(section => section.remove());

    // Render all orders in the default table
    const tbody = document.getElementById("tableBody");

    // INFINITE SCROLL: Render only first batch
    renderedCount = INITIAL_RENDER_COUNT;
    const initialData = displayedData.slice(0, renderedCount);
    tbody.innerHTML = initialData.map(createRowHTML).join("");

    // Add spacer if there are more items
    if (displayedData.length > renderedCount) {
        const spacer = document.createElement('tr');
        spacer.id = 'table-spacer';
        spacer.innerHTML = `<td colspan="18" style="text-align: center; padding: 20px; color: #6b7280;">
            <i class="fas fa-spinner fa-spin"></i> Äang táº£i thÃªm...
        </td>`;
        tbody.appendChild(spacer);
    }

    // Batch fetch debts for all phones in initial data (ONE API call instead of 50!)
    const phonesToFetch = initialData.map(order => order.Telephone).filter(Boolean);
    if (phonesToFetch.length > 0 && typeof batchFetchDebts === 'function') {
        batchFetchDebts(phonesToFetch);
    }

    // Clear rendering flag after render is complete
    isRendering = false;
}

// =====================================================
// INFINITE SCROLL LOGIC
// =====================================================
const INITIAL_RENDER_COUNT = 50;
const LOAD_MORE_COUNT = 50;
let renderedCount = 0;

document.addEventListener('DOMContentLoaded', () => {
    const tableWrapper = document.getElementById("tableWrapper");
    if (tableWrapper) {
        tableWrapper.addEventListener('scroll', handleTableScroll);
    }
});

function handleTableScroll(e) {
    const { scrollTop, scrollHeight, clientHeight } = e.target;

    // Check if scrolled near bottom (within 200px)
    if (scrollTop + clientHeight >= scrollHeight - 200) {
        loadMoreRows();
    }
}

function loadMoreRows() {
    // Prevent appending during active render or if we have no more data
    if (isRendering || renderedCount >= displayedData.length) return;

    const tbody = document.getElementById("tableBody");
    if (!tbody) return; // Safety check

    const spacer = document.getElementById("table-spacer");

    // Remove spacer temporarily
    if (spacer) spacer.remove();

    // Calculate next batch
    const nextBatch = displayedData.slice(renderedCount, renderedCount + LOAD_MORE_COUNT);
    renderedCount += nextBatch.length;

    // Append new rows
    const fragment = document.createDocumentFragment();
    nextBatch.forEach(order => {
        const tr = document.createElement('tr');
        // Use a temporary container to parse HTML string
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = `<table><tbody>${createRowHTML(order)}</tbody></table>`;
        const newRow = tempDiv.querySelector('tr');
        if (newRow) {
            fragment.appendChild(newRow);
        }
    });

    tbody.appendChild(fragment);

    // Apply column visibility to newly added rows
    if (window.columnVisibility) {
        const settings = window.columnVisibility.load();
        window.columnVisibility.apply(settings);
    }

    // Add spacer back if still have more
    if (renderedCount < displayedData.length) {
        const newSpacer = document.createElement('tr');
        newSpacer.id = 'table-spacer';
        newSpacer.innerHTML = `<td colspan="18" style="text-align: center; padding: 20px; color: #6b7280;">
            <i class="fas fa-spinner fa-spin"></i> Äang táº£i thÃªm...
        </td>`;
        tbody.appendChild(newSpacer);
    }

    // Batch fetch debts for newly loaded phones
    const phonesToFetch = nextBatch.map(order => order.Telephone).filter(Boolean);
    if (phonesToFetch.length > 0 && typeof batchFetchDebts === 'function') {
        batchFetchDebts(phonesToFetch);
    }
}

function renderByEmployee() {
    // Set rendering flag to prevent any race conditions
    isRendering = true;

    const tableContainer = document.getElementById('tableContainer');

    // If background loading is in progress, show loading placeholder and wait for completion
    // This ensures employee sections show complete data
    if (isLoadingInBackground) {
        console.log('[EMPLOYEE-VIEW] Waiting for background loading to complete...');

        // Hide the default table
        const defaultTableWrapper = tableContainer.querySelector('.table-wrapper');
        if (defaultTableWrapper) {
            defaultTableWrapper.style.display = 'none';
        }

        // Remove existing employee sections
        const existingSections = tableContainer.querySelectorAll('.employee-section');
        existingSections.forEach(section => section.remove());

        // Show loading placeholder
        let loadingPlaceholder = tableContainer.querySelector('.employee-loading-placeholder');
        if (!loadingPlaceholder) {
            loadingPlaceholder = document.createElement('div');
            loadingPlaceholder.className = 'employee-loading-placeholder';
            loadingPlaceholder.style.cssText = 'text-align: center; padding: 60px 20px; color: #6b7280;';
            loadingPlaceholder.innerHTML = `
                <i class="fas fa-spinner fa-spin" style="font-size: 32px; margin-bottom: 16px; display: block;"></i>
                <div style="font-size: 16px; font-weight: 500;">Äang táº£i dá»¯ liá»‡u Ä‘Æ¡n hÃ ng...</div>
                <div style="font-size: 13px; margin-top: 8px;">Vui lÃ²ng Ä‘á»£i cho tá»›i khi táº£i xong toÃ n bá»™ dá»¯ liá»‡u</div>
            `;
            tableContainer.appendChild(loadingPlaceholder);
        }

        isRendering = false;
        return; // performTableSearch() will be called again when loading completes
    }

    // Remove loading placeholder if exists
    const loadingPlaceholder = tableContainer.querySelector('.employee-loading-placeholder');
    if (loadingPlaceholder) {
        loadingPlaceholder.remove();
    }

    // Group data by employee
    const dataByEmployee = {};

    // Initialize groups for each employee
    employeeRanges.forEach(range => {
        dataByEmployee[range.name] = [];
    });

    // Add "KhÃ¡c" category for orders without employee
    dataByEmployee['KhÃ¡c'] = [];

    // Group orders by employee
    displayedData.forEach(order => {
        const employeeName = getEmployeeName(order.SessionIndex) || 'KhÃ¡c';
        if (!dataByEmployee[employeeName]) {
            dataByEmployee[employeeName] = [];
        }
        dataByEmployee[employeeName].push(order);
    });

    // Get ordered list of employees
    const orderedEmployees = employeeRanges.map(r => r.name).filter(name => dataByEmployee[name].length > 0);

    // Add "KhÃ¡c" at the end if it has data
    if (dataByEmployee['KhÃ¡c'].length > 0) {
        orderedEmployees.push('KhÃ¡c');
    }

    // Hide the default table container (tableContainer already declared above)
    const defaultTableWrapper = tableContainer.querySelector('.table-wrapper');
    if (defaultTableWrapper) {
        defaultTableWrapper.style.display = 'none';
    }

    // Remove existing employee sections
    const existingSections = tableContainer.querySelectorAll('.employee-section');
    existingSections.forEach(section => section.remove());

    // Render each employee section
    orderedEmployees.forEach(employeeName => {
        const orders = dataByEmployee[employeeName];
        const totalAmount = orders.reduce((sum, order) => sum + (order.TotalAmount || 0), 0);
        const totalQuantity = orders.reduce((sum, order) => sum + (order.TotalQuantity || 0), 0);

        const section = document.createElement('div');
        section.className = 'employee-section';

        section.innerHTML = `
            <div class="employee-header">
                <div>
                    <div class="employee-name">
                        <i class="fas fa-user-circle"></i> ${employeeName}
                    </div>
                    <div class="employee-stats">
                        ${orders.length} Ä‘Æ¡n hÃ ng â€¢ ${totalQuantity} sáº£n pháº©m â€¢ ${totalAmount.toLocaleString('vi-VN')}Ä‘
                    </div>
                </div>
                <div class="employee-total">
                    ${orders.length} Ä‘Æ¡n
                </div>
            </div>
            <div class="employee-table-wrapper">
                <div class="table-wrapper">
                    <table class="table">
                        <thead>
                            <tr>
                                <th><input type="checkbox" class="employee-select-all" data-employee="${employeeName}" /></th>
                                <th data-column="actions">Thao tÃ¡c</th>
                                <th data-column="stt">STT</th>
                                <th data-column="employee" style="width: 90px;">NhÃ¢n viÃªn</th>
                                <th data-column="tag">TAG</th>
                                <th data-column="order-code">MÃ£ ÄH</th>
                                <th data-column="customer">KhÃ¡ch hÃ ng</th>
                                <th data-column="phone">SÄT</th>
                                <th data-column="messages">Tin nháº¯n</th>
                                <th data-column="comments">BÃ¬nh luáº­n</th>
                                <th data-column="qr" style="width: 50px; text-align: center;">QR</th>
                                <th data-column="debt" style="width: 100px; text-align: right;">CÃ´ng Ná»£</th>
                                <th data-column="address">Äá»‹a chá»‰</th>
                                <th data-column="notes">Ghi chÃº</th>
                                <th data-column="total">Tá»•ng tiá»n</th>
                                <th data-column="quantity">SL</th>
                                <th data-column="created-date">NgÃ y táº¡o</th>
                                <th data-column="status">Tráº¡ng thÃ¡i</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${orders.map(createRowHTML).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
        `;

        tableContainer.appendChild(section);
    });

    // Add event listeners for employee select all checkboxes
    const employeeSelectAlls = tableContainer.querySelectorAll('.employee-select-all');
    employeeSelectAlls.forEach(checkbox => {
        checkbox.addEventListener('change', function () {
            const section = this.closest('.employee-section');
            const checkboxes = section.querySelectorAll('tbody input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = this.checked);
            updateActionButtons();
        });
    });

    // Batch fetch debts for all phones in displayed data (ONE API call!)
    const phonesToFetch = displayedData.map(order => order.Telephone).filter(Boolean);
    if (phonesToFetch.length > 0 && typeof batchFetchDebts === 'function') {
        batchFetchDebts(phonesToFetch);
    }

    // Clear rendering flag after render is complete
    isRendering = false;
}

function createRowHTML(order) {
    if (!order || !order.Id) return "";
    let tagsHTML = "";
    if (order.Tags) {
        try {
            const tags = JSON.parse(order.Tags);
            if (Array.isArray(tags)) {
                tagsHTML = parseOrderTags(order.Tags, order.Id, order.Code);
            }
        } catch (e) { }
    }
    const partnerStatusHTML = formatPartnerStatus(order.PartnerStatusText, order.PartnerId);
    const highlight = (text) => highlightSearchText(text || "", searchQuery);

    // Get messages and comments columns
    const messagesHTML = renderMessagesColumn(order);
    const commentsHTML = renderCommentsColumn(order);

    // Add watermark class for edited notes
    const rowClass = order.noteEdited ? 'note-edited' : '';

    // Check for merged orders
    const isMerged = order.MergedCount && order.MergedCount > 1;
    const mergedClass = isMerged ? 'merged-order-row' : '';
    const mergedIcon = isMerged ? '<i class="fas fa-link merged-icon" title="ÄÆ¡n gá»™p"></i>' : '';

    // Get employee name for STT
    const employeeName = getEmployeeName(order.SessionIndex);
    const employeeHTML = employeeName
        ? `<span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">${employeeName}</span>`
        : '<span style="color: #9ca3af;">âˆ’</span>';

    // Build actions cell HTML
    const actionsHTML = `
            <td data-column="actions">
                ${isMerged ? `
                    <div class="merged-edit-dropdown" style="position: relative; display: inline-block;">
                        <button class="btn-edit-icon" onclick="toggleMergedEditDropdown(this, event)" title="Chá»n Ä‘Æ¡n hÃ ng Ä‘á»ƒ chá»‰nh sá»­a">
                            <i class="fas fa-edit"></i>
                            <i class="fas fa-caret-down" style="font-size: 10px; margin-left: 2px;"></i>
                        </button>
                        <div class="merged-edit-options" style="display: none; position: absolute; left: 0; top: 100%; background: white; border: 1px solid #e5e7eb; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 100px;">
                            ${order.OriginalOrders.sort((a, b) => (parseInt(b.SessionIndex) || 0) - (parseInt(a.SessionIndex) || 0)).map(o => `
                                <div onclick="openEditModal('${o.Id}'); closeMergedEditDropdown(); event.stopPropagation();"
                                     style="padding: 8px 12px; cursor: pointer; font-size: 13px; border-bottom: 1px solid #f3f4f6; transition: background 0.2s;"
                                     onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='white'">
                                    <span style="font-weight: 500;">STT ${o.SessionIndex}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : `
                    <button class="btn-edit-icon" onclick="openEditModal('${order.Id}')" title="Chá»‰nh sá»­a Ä‘Æ¡n hÃ ng">
                        <i class="fas fa-edit"></i>
                    </button>
                `}
                ${order.noteEdited ? '<span class="note-edited-badge" style="margin-left: 4px;" title="Ghi chÃº Ä‘Ã£ Ä‘Æ°á»£c sá»­a">âœï¸</span>' : ''}
            </td>`;

    return `
        <tr class="${rowClass} ${mergedClass}">
            <td><input type="checkbox" value="${order.Id}" ${selectedOrderIds.has(order.Id) ? 'checked' : ''} /></td>
            ${actionsHTML}
            <td data-column="stt">
                <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                    <span>${order.SessionIndex || ""}</span>
                    ${mergedIcon}
                    ${ordersWithKPIBase.has(order.Id) ? '<span class="kpi-base-indicator" title="ÄÃ£ lÆ°u BASE tÃ­nh KPI"><i class="fas fa-lock" style="color: #10b981; font-size: 10px;"></i></span>' : ''}
                </div>
            </td>
            <td data-column="employee" style="text-align: center;">${employeeHTML}</td>
            <td data-column="tag">
                <div style="display: flex; flex-direction: column; gap: 4px; align-items: flex-start;">
                    <div style="display: flex; gap: 2px;">
                        <button class="tag-icon-btn" onclick="openTagModal('${order.Id}', '${order.Code}'); event.stopPropagation();" title="Quáº£n lÃ½ tag" style="padding: 2px 6px;">
                            <i class="fas fa-tags"></i>
                        </button>
                        <button class="quick-tag-btn" onclick="quickAssignTag('${order.Id}', '${order.Code}', 'xá»­ lÃ½'); event.stopPropagation();" title="Xá»­ lÃ½ + Ä‘á»‹nh danh">
                            <i class="fas fa-clock"></i>
                        </button>
                        <button class="quick-tag-btn quick-tag-ok" onclick="quickAssignTag('${order.Id}', '${order.Code}', 'ok'); event.stopPropagation();" title="OK + Ä‘á»‹nh danh">
                            <i class="fas fa-check"></i>
                        </button>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">${tagsHTML}</div>
                </div>
            </td>
            <td data-column="order-code">
                <span>${highlight(order.Code)}</span>
            </td>
            <td data-column="customer"><div class="customer-name">${highlight(order.Name)}</div>${partnerStatusHTML}</td>
            <td data-column="phone" style="text-align: center;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                    ${order.Telephone ? `<i class="fas fa-copy copy-phone-btn" onclick="copyPhoneNumber('${order.Telephone}'); event.stopPropagation();" title="Copy SÄT" style="cursor: pointer; color: #9ca3af; font-size: 11px;"></i>` : ''}
                    <span>${highlight(order.Telephone)}</span>
                </div>
            </td>
            ${messagesHTML}
            ${commentsHTML}
            <td data-column="qr" style="text-align: center;">${renderQRColumn(order.Telephone)}</td>
            <td data-column="debt" style="text-align: right;">${renderDebtColumn(order.Telephone)}</td>
            <td data-column="address">${highlight(order.Address)}</td>
            <td data-column="notes">${window.DecodingUtility ? window.DecodingUtility.formatNoteWithDecodedData(order.Note) : highlight(order.Note)}</td>
            ${renderMergedTotalColumn(order)}
            ${renderMergedQuantityColumn(order)}
            <td data-column="created-date">${new Date(order.DateCreated).toLocaleString("vi-VN")}</td>
            <td data-column="status"><span class="status-badge ${order.Status === "Draft" ? "status-draft" : "status-order"}" style="cursor: pointer;" onclick="openOrderStatusModal('${order.Id}', '${order.Status}')" data-order-id="${order.Id}" title="Click Ä‘á»ƒ thay Ä‘á»•i tráº¡ng thÃ¡i">${highlight(order.StatusText || order.Status)}</span></td>
        </tr>`;
}

// Helper: Format message preview with icon
function formatMessagePreview(chatInfo) {
    let displayMessage = 'âˆ’'; // Default to dash
    let messageIcon = '';

    if (chatInfo.attachments && chatInfo.attachments.length > 0) {
        // Has attachments (images, files, etc.)
        const attachment = chatInfo.attachments[0];
        if (attachment.Type === 'image' || attachment.Type === 'photo') {
            displayMessage = 'ÄÃ£ gá»­i áº£nh';
            messageIcon = 'ğŸ“·';
        } else if (attachment.Type === 'video') {
            displayMessage = 'ÄÃ£ gá»­i video';
            messageIcon = 'ğŸ¥';
        } else if (attachment.Type === 'file') {
            displayMessage = 'ÄÃ£ gá»­i file';
            messageIcon = 'ğŸ“';
        } else if (attachment.Type === 'audio') {
            displayMessage = 'ÄÃ£ gá»­i audio';
            messageIcon = 'ğŸµ';
        } else if (attachment.Type === 'sticker' || attachment.type === 'sticker' || attachment.sticker_id) {
            displayMessage = 'ÄÃ£ gá»­i sticker';
            messageIcon = 'ğŸ§¸';
        } else if (attachment.Type === 'animated_image_share' || attachment.type === 'animated_image_share') {
            displayMessage = 'ÄÃ£ gá»­i GIF';
            messageIcon = 'ğŸï¸';
        } else {
            displayMessage = 'ÄÃ£ gá»­i tá»‡p';
            messageIcon = 'ğŸ“';
        }
    } else if (chatInfo.message) {
        // Text message
        displayMessage = chatInfo.message;
    }

    // Truncate message
    if (displayMessage.length > 30) {
        displayMessage = displayMessage.substring(0, 30) + '...';
    }

    // Return formatted message with icon
    return messageIcon ? `${messageIcon} ${displayMessage}` : displayMessage;
}

// Helper: Render multi-customer messages/comments (merged order with different customers)
// Shows multiple lines, one per customer with their largest STT
function renderMultiCustomerMessages(order, columnType = 'messages') {
    const rows = [];

    // For each customer group, find order with largest STT and get its message
    order.CustomerGroups.forEach(customerGroup => {
        // Get the order with largest STT (already sorted in customerGroups)
        const largestSTTOrder = customerGroup.orders[0]; // First order is largest STT

        // Find full order object from OriginalOrders
        const fullOrder = order.OriginalOrders.find(o => o.Id === largestSTTOrder.id);
        if (!fullOrder || !largestSTTOrder.psid || !largestSTTOrder.channelId) {
            return; // Skip this customer if no valid data
        }

        // Get message or comment
        const messageInfo = columnType === 'messages'
            ? window.chatDataManager.getLastMessageForOrder(fullOrder)
            : window.chatDataManager.getLastCommentForOrder(largestSTTOrder.channelId, largestSTTOrder.psid, fullOrder);

        // Format message preview
        const displayMessage = formatMessagePreview(messageInfo);
        const unreadBadge = messageInfo.hasUnread ? '<span class="unread-badge"></span>' : '';
        const fontWeight = messageInfo.hasUnread ? '700' : '400';
        const color = messageInfo.hasUnread ? '#111827' : '#6b7280';

        // Create click handler - use separate modals for messages and comments
        const clickHandler = columnType === 'messages'
            ? `openChatModal('${largestSTTOrder.id}', '${largestSTTOrder.channelId}', '${largestSTTOrder.psid}')`
            : `openCommentModal('${largestSTTOrder.id}', '${largestSTTOrder.channelId}', '${largestSTTOrder.psid}')`;

        rows.push(`
            <div class="multi-customer-message-row" onclick="${clickHandler}" style="border-bottom: 1px solid #e5e7eb; padding: 6px 8px; cursor: pointer; transition: background-color 0.2s;">
                <div style="font-size: 11px; color: #6b7280; margin-bottom: 3px; font-weight: 500;">
                    ${customerGroup.name} â€¢ STT ${largestSTTOrder.stt}
                </div>
                <div style="display: flex; align-items: center; gap: 6px;">
                    ${unreadBadge}
                    <span style="font-size: 13px; font-weight: ${fontWeight}; color: ${color};">
                        ${displayMessage}
                    </span>
                </div>
                ${messageInfo.unreadCount > 0 ? `<div style="font-size: 11px; color: #ef4444; font-weight: 600; margin-top: 2px;">${messageInfo.unreadCount} tin má»›i</div>` : ''}
            </div>
        `);
    });

    // If no rows, show dash
    if (rows.length === 0) {
        return `<td data-column="${columnType}" style="text-align: center; color: #9ca3af;">âˆ’</td>`;
    }

    return `
        <td data-column="${columnType}" style="padding: 0; vertical-align: top;">
            <div style="max-height: 200px; overflow-y: auto;">
                ${rows.join('')}
            </div>
        </td>
    `;
}

// Helper: Render single customer message/comment (merged order with same customer)
// Shows only the message/comment from the order with largest STT
function renderSingleCustomerMessage(order, columnType = 'messages') {
    // Get the order with largest STT (stored in TargetOrderId)
    const targetOrder = order.OriginalOrders.find(o => o.Id === order.TargetOrderId);

    if (!targetOrder || !targetOrder.Facebook_ASUserId) {
        return `<td data-column="${columnType}" style="text-align: center; color: #9ca3af;">âˆ’</td>`;
    }

    // Get chat info for this specific order
    const chatInfo = window.chatDataManager.getChatInfoForOrder(targetOrder);

    if (!chatInfo.psid || !chatInfo.channelId) {
        return `<td data-column="${columnType}" style="text-align: center; color: #9ca3af;">âˆ’</td>`;
    }

    // Get message or comment based on type
    const messageInfo = columnType === 'messages'
        ? window.chatDataManager.getLastMessageForOrder(targetOrder)
        : window.chatDataManager.getLastCommentForOrder(chatInfo.channelId, chatInfo.psid, targetOrder);

    // Render using the existing renderChatColumnWithData function
    // But we need to pass the targetOrder ID for the click handler
    return renderChatColumnWithData(targetOrder, messageInfo, chatInfo.channelId, chatInfo.psid, columnType);
}

// Render messages column only (not comments)
function renderMessagesColumn(order) {
    if (!window.chatDataManager) {
        console.log('[CHAT RENDER] chatDataManager not available');
        return '<td data-column="messages" style="text-align: center; color: #9ca3af;">âˆ’</td>';
    }

    // Show loading indicator when conversations are being fetched
    if (isLoadingConversations) {
        return '<td data-column="messages" style="text-align: center; color: #9ca3af;" title="Äang táº£i tin nháº¯n..."><i class="fas fa-spinner fa-spin" style="font-size: 12px; color: #667eea;"></i></td>';
    }

    // Check if this is a merged order - always show STT-based format
    if (order.IsMerged && order.OriginalOrders && order.OriginalOrders.length > 1) {
        return renderMergedMessagesColumn(order, 'messages');
    }

    // Get chat info for order
    const orderChatInfo = window.chatDataManager.getChatInfoForOrder(order);

    // Debug log first few orders
    if (order.SessionIndex && order.SessionIndex <= 3) {
        console.log(`[CHAT RENDER] Order ${order.Code}:`, {
            Facebook_ASUserId: order.Facebook_ASUserId,
            Facebook_PostId: order.Facebook_PostId,
            channelId: orderChatInfo.channelId,
            psid: orderChatInfo.psid,
            hasChat: orderChatInfo.hasChat
        });
    }

    // If no PSID or Channel ID, show dash
    if (!orderChatInfo.psid || !orderChatInfo.channelId) {
        return '<td data-column="messages" style="text-align: center; color: #9ca3af;">âˆ’</td>';
    }

    const messageInfo = window.chatDataManager.getLastMessageForOrder(order);
    const channelId = orderChatInfo.channelId;
    const psid = orderChatInfo.psid;

    // Always render with clickable cell (even when showing "-") as long as we have channelId and psid
    // This allows users to open the modal even when there are no messages yet
    return renderChatColumnWithData(order, messageInfo, channelId, psid, 'messages');
}

// Render comments column only (not messages)
function renderCommentsColumn(order) {
    if (!window.chatDataManager) {
        console.log('[CHAT RENDER] chatDataManager not available');
        return '<td data-column="comments" style="text-align: center; color: #9ca3af;">âˆ’</td>';
    }

    // Show loading indicator when conversations are being fetched
    if (isLoadingConversations) {
        return '<td data-column="comments" style="text-align: center; color: #9ca3af;" title="Äang táº£i bÃ¬nh luáº­n..."><i class="fas fa-spinner fa-spin" style="font-size: 12px; color: #667eea;"></i></td>';
    }

    // Check if this is a merged order - always show STT-based format
    if (order.IsMerged && order.OriginalOrders && order.OriginalOrders.length > 1) {
        return renderMergedMessagesColumn(order, 'comments');
    }

    // Get chat info for order
    const orderChatInfo = window.chatDataManager.getChatInfoForOrder(order);

    // If no PSID or Channel ID, show dash
    if (!orderChatInfo.psid || !orderChatInfo.channelId) {
        return '<td data-column="comments" style="text-align: center; color: #9ca3af;">âˆ’</td>';
    }

    const commentInfo = window.chatDataManager.getLastCommentForOrder(orderChatInfo.channelId, orderChatInfo.psid, order);
    const channelId = orderChatInfo.channelId;
    const psid = orderChatInfo.psid;

    // Always render with clickable cell (even when showing "-") as long as we have channelId and psid
    // This allows users to open the modal even when there are no comments yet
    return renderChatColumnWithData(order, commentInfo, channelId, psid, 'comments');
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                    SECTION 9: MERGED ORDER COLUMNS                          â•‘
// â•‘                            search: #MERGED                                  â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// MERGED ORDER COLUMNS - Messages & Comments (STT-based) #MERGED
// =====================================================

// Render merged messages/comments column with individual STT values
function renderMergedMessagesColumn(order, columnType = 'messages') {
    // Debug log
    console.log('[renderMergedMessagesColumn]', {
        columnType,
        IsMerged: order.IsMerged,
        OriginalOrdersCount: order.OriginalOrders?.length,
        OriginalOrders: order.OriginalOrders
    });

    // Check if user wants to show message content (from column visibility settings)
    const columnSettings = window.columnVisibility?.load() || {};
    const showContent = columnSettings.messagesContent !== false; // Default true

    // Sort by STT descending (largest first)
    const sortedOrders = [...order.OriginalOrders].sort((a, b) =>
        (parseInt(b.SessionIndex) || 0) - (parseInt(a.SessionIndex) || 0)
    );

    const rows = sortedOrders.map(originalOrder => {
        // Get chat info for this specific order
        const chatInfo = window.chatDataManager ? window.chatDataManager.getChatInfoForOrder(originalOrder) : null;
        const channelId = chatInfo?.channelId || window.chatDataManager?.parseChannelId(originalOrder.Facebook_PostId);
        const psid = originalOrder.Facebook_ASUserId;

        // Get message or comment info - always show something even without chat info
        let displayMessage = 'âˆ’';
        let hasUnread = false;
        let unreadCount = 0;

        // If user disabled content display, always show "-" (no preview, no badge)
        if (!showContent) {
            displayMessage = 'â€“';
        } else if (window.chatDataManager && channelId && psid) {
            const msgInfo = columnType === 'messages'
                ? window.chatDataManager.getLastMessageForOrder(originalOrder)
                : window.chatDataManager.getLastCommentForOrder(channelId, psid, originalOrder);

            if (msgInfo && (msgInfo.message || msgInfo.content || msgInfo.text)) {
                displayMessage = formatMessagePreview(msgInfo);
                hasUnread = msgInfo.hasUnread || false;
                unreadCount = msgInfo.unreadCount || 0;
            }
        }

        // Create click handler - always allow click if we have channelId and psid
        const clickHandler = channelId && psid
            ? (columnType === 'messages'
                ? `openChatModal('${originalOrder.Id}', '${channelId}', '${psid}')`
                : `openCommentModal('${originalOrder.Id}', '${channelId}', '${psid}')`)
            : '';

        const cursorStyle = clickHandler ? 'cursor: pointer;' : 'cursor: default;';
        const hoverStyle = clickHandler ? `onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='transparent'"` : '';

        // Only show unread indicators if content display is enabled
        const unreadBadge = (showContent && hasUnread) ? '<span style="width: 6px; height: 6px; background: #ef4444; border-radius: 50%; flex-shrink: 0;"></span>' : '';
        const fontWeight = (showContent && hasUnread) ? '600' : '400';
        const color = (showContent && hasUnread) ? '#111827' : '#6b7280';

        // Always show unread count if > 0 (only when content display is enabled)
        const unreadText = (showContent && unreadCount > 0) ? `<span style="font-size: 10px; color: #ef4444; font-weight: 600; margin-left: 4px;">${unreadCount} tin má»›i</span>` : '';

        return `
            <div class="merged-detail-row" ${clickHandler ? `onclick="${clickHandler}; event.stopPropagation();"` : ''} 
                 style="display: flex; align-items: center; gap: 6px; border-bottom: 1px solid #e5e7eb; padding: 6px 8px; min-height: 28px; ${cursorStyle} transition: background 0.2s;"
                 ${hoverStyle}>
                <span style="font-size: 11px; color: #6b7280; font-weight: 500; min-width: 55px; flex-shrink: 0;">STT ${originalOrder.SessionIndex}:</span>
                ${unreadBadge}
                <span style="font-size: 12px; font-weight: ${fontWeight}; color: ${color}; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1;">${displayMessage}</span>
                ${unreadText}
            </div>
        `;
    }).join('');

    return `<td data-column="${columnType}" style="padding: 0; vertical-align: top;">${rows}</td>`;
}

// =====================================================
// MERGED ORDER COLUMNS - Quantity & Total Amount
// =====================================================

// Render merged quantity column with individual STT values
function renderMergedQuantityColumn(order) {
    // Non-merged orders: simple display
    if (!order.IsMerged || !order.OriginalOrders || order.OriginalOrders.length <= 1) {
        return `<td data-column="quantity">${order.TotalQuantity || 0}</td>`;
    }

    // Sort by STT descending (largest first)
    const sortedOrders = [...order.OriginalOrders].sort((a, b) =>
        (parseInt(b.SessionIndex) || 0) - (parseInt(a.SessionIndex) || 0)
    );

    const rows = sortedOrders.map(o => `
        <div class="merged-detail-row" onclick="openEditModal('${o.Id}'); event.stopPropagation();" 
             style="display: flex; align-items: center; gap: 6px; border-bottom: 1px solid #e5e7eb; padding: 6px 8px; min-height: 28px; cursor: pointer; transition: background 0.2s;"
             onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='transparent'">
            <span style="font-size: 11px; color: #6b7280; font-weight: 500; min-width: 55px; flex-shrink: 0;">STT ${o.SessionIndex}:</span>
            <span style="font-weight: 600;">${o.TotalQuantity || 0}</span>
        </div>
    `).join('');

    return `<td data-column="quantity" style="padding: 0; vertical-align: top;">${rows}</td>`;
}

// Render merged total amount column with individual STT values
function renderMergedTotalColumn(order) {
    // Non-merged orders: simple display
    if (!order.IsMerged || !order.OriginalOrders || order.OriginalOrders.length <= 1) {
        return `<td data-column="total">${(order.TotalAmount || 0).toLocaleString("vi-VN")}Ä‘</td>`;
    }

    // Sort by STT descending (largest first)
    const sortedOrders = [...order.OriginalOrders].sort((a, b) =>
        (parseInt(b.SessionIndex) || 0) - (parseInt(a.SessionIndex) || 0)
    );

    const rows = sortedOrders.map(o => `
        <div class="merged-detail-row" onclick="openEditModal('${o.Id}'); event.stopPropagation();" 
             style="display: flex; align-items: center; gap: 6px; border-bottom: 1px solid #e5e7eb; padding: 6px 8px; min-height: 28px; cursor: pointer; transition: background 0.2s;"
             onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='transparent'">
            <span style="font-size: 11px; color: #6b7280; font-weight: 500; min-width: 55px; flex-shrink: 0;">STT ${o.SessionIndex}:</span>
            <span style="font-weight: 600; color: #3b82f6;">${(o.TotalAmount || 0).toLocaleString("vi-VN")}Ä‘</span>
        </div>
    `).join('');

    return `<td data-column="total" style="padding: 0; vertical-align: top;">${rows}</td>`;
}

// Helper function to render chat column with data (for both messages and comments)
function renderChatColumnWithData(order, chatInfo, channelId, psid, columnType = 'messages') {
    // Format message based on type
    let displayMessage = 'âˆ’'; // Default to dash
    let messageIcon = '';

    if (chatInfo.attachments && chatInfo.attachments.length > 0) {
        // Has attachments (images, files, etc.)
        const attachment = chatInfo.attachments[0];
        if (attachment.Type === 'image' || attachment.Type === 'photo') {
            displayMessage = 'ÄÃ£ gá»­i áº£nh';
            messageIcon = 'ğŸ“·';
        } else if (attachment.Type === 'video') {
            displayMessage = 'ÄÃ£ gá»­i video';
            messageIcon = 'ğŸ¥';
        } else if (attachment.Type === 'file') {
            displayMessage = 'ÄÃ£ gá»­i file';
            messageIcon = 'ğŸ“';
        } else if (attachment.Type === 'audio') {
            displayMessage = 'ÄÃ£ gá»­i audio';
            messageIcon = 'ğŸµ';
        } else if (attachment.Type === 'sticker' || attachment.type === 'sticker' || attachment.sticker_id) {
            displayMessage = 'ÄÃ£ gá»­i sticker';
            messageIcon = 'ğŸ§¸';
        } else if (attachment.Type === 'animated_image_share' || attachment.type === 'animated_image_share') {
            displayMessage = 'ÄÃ£ gá»­i GIF';
            messageIcon = 'ğŸï¸';
        } else {
            displayMessage = 'ÄÃ£ gá»­i tá»‡p';
            messageIcon = 'ğŸ“';
        }
    } else if (chatInfo.message) {
        // Text message
        displayMessage = chatInfo.message;
    }

    // Truncate message
    if (displayMessage.length > 30) {
        displayMessage = displayMessage.substring(0, 30) + '...';
    }

    // Styling based on unread status
    const isUnread = chatInfo.hasUnread;
    const fontWeight = isUnread ? '700' : '400';
    const color = isUnread ? '#111827' : '#6b7280';
    const unreadBadge = isUnread ? `<span class="unread-badge"></span>` : '';

    // Click handler
    // For merged orders, use the TargetOrderId (order with largest STT) instead of the combined Id
    const orderIdToUse = order.IsMerged && order.TargetOrderId ? order.TargetOrderId : order.Id;
    // Use separate modals: openChatModal for messages, openCommentModal for comments
    const clickHandler = columnType === 'messages'
        ? `openChatModal('${orderIdToUse}', '${channelId}', '${psid}')`
        : `openCommentModal('${orderIdToUse}', '${channelId}', '${psid}')`;

    const tooltipText = columnType === 'comments'
        ? 'Click Ä‘á»ƒ xem bÃ¬nh luáº­n'
        : 'Click Ä‘á»ƒ xem toÃ n bá»™ tin nháº¯n';

    return `
        <td data-column="${columnType}" onclick="${clickHandler}" style="cursor: pointer;" title="${tooltipText}">
            <div style="display: flex; align-items: center; gap: 6px;">
                ${unreadBadge}
                <div style="display: flex; flex-direction: column;">
                    <span style="font-size: 13px; font-weight: ${fontWeight}; color: ${color};">
                        ${messageIcon} ${displayMessage}
                    </span>
                    ${chatInfo.unreadCount > 0 ? `<span style="font-size: 11px; color: #ef4444; font-weight: 600;">${chatInfo.unreadCount} tin má»›i</span>` : ''}
                </div>
            </div>
        </td>`;
}

function parseOrderTags(tagsJson, orderId, orderCode) {
    try {
        const tags = JSON.parse(tagsJson);
        if (!Array.isArray(tags) || tags.length === 0) return "";

        // Escape function for safe onclick attributes
        const escapeAttr = (str) => String(str).replace(/'/g, "\\'").replace(/"/g, "&quot;");

        return tags
            .map(
                (tag) =>
                    `<div style="display: inline-flex; align-items: center; gap: 2px;">
                        <span class="order-tag" style="background-color: ${tag.Color || "#6b7280"}; cursor: pointer;" onclick="openTagModal('${escapeAttr(orderId)}', '${escapeAttr(orderCode)}'); event.stopPropagation();" title="Quáº£n lÃ½ tag">${tag.Name || ""}</span>
                        <button class="tag-remove-btn" onclick="quickRemoveTag('${escapeAttr(orderId)}', '${escapeAttr(orderCode)}', '${escapeAttr(tag.Id)}'); event.stopPropagation();" title="XÃ³a tag nÃ y">Ã—</button>
                    </div>`,
            )
            .join("");
    } catch (e) {
        return "";
    }
}

function formatPartnerStatus(statusText, partnerId) {
    if (!statusText) return "";
    const statusColors = {
        "BÃ¬nh thÆ°á»ng": "#5cb85c",
        "Bom hÃ ng": "#d1332e",
        "Cáº£nh bÃ¡o": "#f0ad4e",
        "KhÃ¡ch sá»‰": "#5cb85c",
        "Nguy hiá»ƒm": "#d9534f",
        "ThÃ¢n thiáº¿t": "#5bc0de",
        Vip: "#337ab7",
        VIP: "#5bc0deff",
    };
    const color = statusColors[statusText] || "#6b7280";
    const cursorStyle = partnerId ? 'cursor: pointer;' : '';
    const onclickAttr = partnerId ? `onclick="openPartnerStatusModal('${partnerId}', '${statusText}')"` : '';
    const titleAttr = partnerId ? 'title="Click Ä‘á»ƒ thay Ä‘á»•i tráº¡ng thÃ¡i"' : '';
    const dataAttr = partnerId ? `data-partner-id="${partnerId}"` : '';

    return `<span class="partner-status" style="background-color: ${color}; ${cursorStyle}" ${onclickAttr} ${titleAttr} ${dataAttr}>${statusText}</span>`;
}

// --- Partner Status Modal Logic ---

const PARTNER_STATUS_OPTIONS = [
    { value: "#5cb85c", text: "BÃ¬nh thÆ°á»ng" },
    { value: "#d1332e", text: "Bom hÃ ng" },
    { value: "#f0ad4e", text: "Cáº£nh bÃ¡o" },
    { value: "#5cb85c", text: "KhÃ¡ch sá»‰" },
    { value: "#d9534f", text: "Nguy hiá»ƒm" },
    { value: "#5bc0de", text: "ThÃ¢n thiáº¿t" },
    { value: "#337ab7", text: "Vip" },
    { value: "#5bc0deff", text: "VIP" }
];

function openPartnerStatusModal(partnerId, currentStatus) {
    const modal = document.getElementById('partnerStatusModal');
    const container = document.getElementById('partnerStatusOptions');
    if (!modal || !container) return;

    // Populate options
    container.innerHTML = '';
    PARTNER_STATUS_OPTIONS.forEach(option => {
        const btn = document.createElement('div');
        btn.className = 'status-btn';
        if (option.text === currentStatus) btn.classList.add('selected');

        btn.innerHTML = `
            <span class="status-color-dot" style="background-color: ${option.value};"></span>
            <span class="status-text">${option.text}</span>
        `;
        btn.onclick = () => updatePartnerStatus(partnerId, option.value, option.text);
        container.appendChild(btn);
    });

    modal.classList.add('show');
}

function closePartnerStatusModal() {
    const modal = document.getElementById('partnerStatusModal');
    if (modal) modal.classList.remove('show');
}

async function updatePartnerStatus(partnerId, color, text) {
    closePartnerStatusModal();

    // Optimistic update (optional, but good for UX)
    // For now, we'll wait for API success to ensure consistency

    try {
        const url = `${API_CONFIG.WORKER_URL}/api/odata/Partner(${partnerId})/ODataService.UpdateStatus`;
        const headers = await window.tokenManager.getAuthHeader();

        const response = await API_CONFIG.smartFetch(url, {
            method: 'POST',
            headers: {
                ...headers,
                'content-type': 'application/json;charset=UTF-8',
                'accept': 'application/json, text/plain, */*'
            },
            body: JSON.stringify({ status: `${color}_${text}` })
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        // Success
        window.notificationManager.show('Cáº­p nháº­t tráº¡ng thÃ¡i thÃ nh cÃ´ng', 'success');

        // Update local data
        allData.forEach(order => {
            if (String(order.PartnerId) === String(partnerId)) {
                order.PartnerStatus = text;
                order.PartnerStatusText = text;
            }
        });

        // Inline UI Update
        const badges = document.querySelectorAll(`.partner-status[data-partner-id="${partnerId}"]`);
        badges.forEach(badge => {
            badge.style.backgroundColor = color;
            badge.innerText = text;
            badge.setAttribute('onclick', `openPartnerStatusModal('${partnerId}', '${text}')`);
        });

    } catch (error) {
        console.error('[PARTNER] Update status failed:', error);
        window.notificationManager.show('Cáº­p nháº­t tráº¡ng thÃ¡i tháº¥t báº¡i: ' + error.message, 'error');
    }
}

// --- Order Status Modal Logic ---

const ORDER_STATUS_OPTIONS = [
    { value: "ÄÆ¡n hÃ ng", text: "ÄÆ¡n hÃ ng", color: "#5cb85c" },
    { value: "Há»§y", text: "Huá»· bá»", color: "#d1332e" },
    { value: "NhÃ¡p", text: "NhÃ¡p", color: "#f0ad4e" }
];

function openOrderStatusModal(orderId, currentStatus) {
    const modal = document.getElementById('orderStatusModal');
    const container = document.getElementById('orderStatusOptions');
    if (!modal || !container) return;

    // Populate options
    container.innerHTML = '';
    ORDER_STATUS_OPTIONS.forEach(option => {
        const btn = document.createElement('div');
        btn.className = 'status-btn';
        if (option.value === currentStatus) btn.classList.add('selected');

        btn.innerHTML = `
            <span class="status-color-dot" style="background-color: ${option.color};"></span>
            <span class="status-text">${option.text}</span>
        `;
        btn.onclick = () => updateOrderStatus(orderId, option.value, option.text, option.color);
        container.appendChild(btn);
    });

    modal.classList.add('show');
}

function closeOrderStatusModal() {
    const modal = document.getElementById('orderStatusModal');
    if (modal) modal.classList.remove('show');
}

async function updateOrderStatus(orderId, newValue, newText, newColor) {
    closeOrderStatusModal();

    try {
        const url = `${API_CONFIG.WORKER_URL}/api/odata/SaleOnline_Order/OdataService.UpdateStatusSaleOnline?Id=${orderId}&Status=${encodeURIComponent(newValue)}`;
        const headers = await window.tokenManager.getAuthHeader();

        const response = await API_CONFIG.smartFetch(url, {
            method: 'POST',
            headers: {
                ...headers,
                'content-type': 'application/json;charset=utf-8',
                'accept': '*/*'
            },
            body: null
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        // Success
        window.notificationManager.show('Cáº­p nháº­t tráº¡ng thÃ¡i Ä‘Æ¡n hÃ ng thÃ nh cÃ´ng', 'success');

        // Update local data
        allData.forEach(order => {
            if (String(order.Id) === String(orderId)) {
                order.Status = newValue;
                order.StatusText = newText;
            }
        });

        // Inline UI Update
        const badges = document.querySelectorAll(`.status-badge[data-order-id="${orderId}"]`);
        badges.forEach(badge => {
            badge.className = `status-badge ${newValue === "Draft" ? "status-draft" : "status-order"}`;
            // Update color manually if needed, or rely on class. 
            // The existing logic uses classes, but we might want to force the color if it's custom.
            // For now, let's just update the text and rely on re-render or class.
            // Actually, the user provided specific colors for the options.
            // Let's apply the color directly for immediate feedback.
            badge.style.backgroundColor = newColor; // This might override class styles
            badge.innerText = newText || newValue;
            badge.setAttribute('onclick', `openOrderStatusModal('${orderId}', '${newValue}')`);
        });

        // If we want to be safe and consistent with filters:
        // performTableSearch(); // Optional, but inline is faster.

    } catch (error) {
        console.error('[ORDER] Update status failed:', error);
        window.notificationManager.show('Cáº­p nháº­t tráº¡ng thÃ¡i tháº¥t báº¡i: ' + error.message, 'error');
    }
}

function updateStats() {
    const totalAmount = displayedData.reduce(
        (sum, order) => sum + (order.TotalAmount || 0),
        0,
    );

    // Calculate merged order statistics
    const mergedOrders = displayedData.filter(order => order.IsMerged === true);
    const totalOriginalOrders = displayedData.reduce((sum, order) => {
        return sum + (order.MergedCount || 1);
    }, 0);

    // Update total orders count
    document.getElementById("totalOrdersCount").textContent =
        filteredData.length.toLocaleString("vi-VN");

    // Update merged orders info
    const mergedInfoElement = document.getElementById("mergedOrdersInfo");
    if (mergedOrders.length > 0) {
        mergedInfoElement.textContent =
            `${mergedOrders.length} Ä‘Æ¡n gá»™p (${totalOriginalOrders} Ä‘Æ¡n gá»‘c)`;
        mergedInfoElement.style.color = "#f59e0b"; // Orange color for emphasis
    } else {
        mergedInfoElement.textContent = "-";
        mergedInfoElement.style.color = "#9ca3af"; // Gray color
    }

    document.getElementById("displayedOrdersCount").textContent =
        displayedData.length.toLocaleString("vi-VN");
    document.getElementById("totalAmountSum").textContent =
        totalAmount.toLocaleString("vi-VN") + "Ä‘";
    document.getElementById("loadingProgress").textContent = "100%";
}

function updatePageInfo() {
    const totalDisplayed = displayedData.length;
    const totalFiltered = filteredData.length;
    document.getElementById("pageInfo").textContent =
        `Hiá»ƒn thá»‹ ${totalDisplayed.toLocaleString("vi-VN")} / ${totalFiltered.toLocaleString("vi-VN")}`;
    document.getElementById("scrollHint").textContent =
        totalDisplayed > 0 ? "âœ… ÄÃ£ hiá»ƒn thá»‹ táº¥t cáº£" : "";
}

// =====================================================
// EVENT HANDLERS & HELPERS
// =====================================================
function sendDataToTab2() {
    const filterData = {
        startDate: convertToUTC(document.getElementById("startDate").value),
        endDate: convertToUTC(document.getElementById("endDate").value),
        campaignId: selectedCampaign?.campaignId || null,
        campaignName: selectedCampaign?.displayName || "",
        data: allData,
        totalRecords: allData.length,
        timestamp: new Date().toISOString(),
    };
    if (window.parent)
        window.parent.postMessage(
            { type: "FILTER_CHANGED", filter: filterData },
            "*",
        );
    localStorage.setItem("tab1_filter_data", JSON.stringify(filterData));
}

// =====================================================
// HELPER: CHECK IF ORDER SHOULD BE SELECTABLE
// =====================================================
// =====================================================
// HELPER: CHECK IF ORDER SHOULD BE SELECTABLE
// =====================================================
// SELECTION MANAGEMENT (STATE-BASED)
// =====================================================


function isOrderSelectable(orderId) {
    const order = allData.find(o => o.Id === orderId);
    if (!order) return true; // Náº¿u khÃ´ng tÃ¬m tháº¥y, cho phÃ©p select

    // Kiá»ƒm tra sá»‘ lÆ°á»£ng = 0
    if (order.TotalQuantity === 0) {
        console.log(`[SELECT] Skipping order ${order.Code}: TotalQuantity = 0`);
        return false;
    }

    // Kiá»ƒm tra tag "GIá» TRá»NG"
    if (order.Tags) {
        try {
            const tags = JSON.parse(order.Tags);
            if (Array.isArray(tags)) {
                const hasEmptyCartTag = tags.some(tag =>
                    tag.Name && tag.Name.toUpperCase() === "GIá» TRá»NG"
                );
                if (hasEmptyCartTag) {
                    console.log(`[SELECT] Skipping order ${order.Code}: Has "GIá» TRá»NG" tag`);
                    return false;
                }
            }
        } catch (e) {
            // Náº¿u parse lá»—i, cho phÃ©p select
        }
    }

    return true;
}

function handleSelectAll() {
    const isChecked = document.getElementById("selectAll").checked;

    if (isChecked) {
        // Select ALL displayed data (not just visible rows)
        displayedData.forEach(order => {
            selectedOrderIds.add(order.Id);
        });
    } else {
        // Deselect ALL
        selectedOrderIds.clear();
    }

    // Update visible checkboxes
    const checkboxes = document.querySelectorAll('#tableBody input[type="checkbox"]');
    checkboxes.forEach((cb) => {
        cb.checked = isChecked;
    });

    // Also update employee select all checkboxes
    const employeeSelectAlls = document.querySelectorAll('.employee-select-all');
    employeeSelectAlls.forEach(cb => {
        cb.checked = isChecked;
    });

    // Trigger update action buttons
    updateActionButtons();
}

// Global event listener for checkbox changes (Delegation)
document.addEventListener('change', function (e) {
    if (e.target.matches('tbody input[type="checkbox"]')) {
        const orderId = e.target.value;
        if (e.target.checked) {
            selectedOrderIds.add(orderId);
        } else {
            selectedOrderIds.delete(orderId);
            // Uncheck "Select All" if one is unchecked
            document.getElementById("selectAll").checked = false;
        }
        updateActionButtons();
    }
});

// =====================================================
// UPDATE ACTION BUTTONS VISIBILITY
// =====================================================
function updateActionButtons() {
    const actionButtonsSection = document.getElementById('actionButtonsSection');
    const selectedCountSpan = document.getElementById('selectedOrdersCount');
    const createSaleButtonBtn = document.getElementById('createSaleButtonBtn');
    const createFastSaleBtn = document.getElementById('createFastSaleBtn');
    const checkedCount = selectedOrderIds.size;

    if (checkedCount > 0) {
        actionButtonsSection.style.display = 'flex';
        selectedCountSpan.textContent = checkedCount.toLocaleString('vi-VN');
    } else {
        actionButtonsSection.style.display = 'none';
    }

    // Show "Táº¡o nÃºt bÃ¡n hÃ ng" button only when exactly 1 order is selected
    if (createSaleButtonBtn) {
        createSaleButtonBtn.style.display = checkedCount === 1 ? 'flex' : 'none';
    }

    // Show "Táº¡o nhanh PBH" button when more than 1 order is selected
    if (createFastSaleBtn) {
        createFastSaleBtn.style.display = checkedCount > 1 ? 'flex' : 'none';
    }
}

async function handleClearCache() {
    const confirmed = await window.notificationManager.confirm(
        "Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a toÃ n bá»™ cache?",
        "XÃ¡c nháº­n xÃ³a cache"
    );
    if (confirmed) {
        window.cacheManager.clear("orders");
        window.cacheManager.clear("campaigns");
        window.notificationManager.success("ÄÃ£ xÃ³a cache");
        location.reload();
    }
}

function showLoading(show) {
    document.getElementById("loadingOverlay").classList.toggle("show", show);
}

function showInfoBanner(text) {
    const banner = document.getElementById("infoBanner");
    document.getElementById("infoText").textContent = text;
    banner.style.display = "flex";
    setTimeout(() => (banner.style.display = "none"), 5000);
}

function showSaveIndicator(type, message) {
    const indicator = document.getElementById("saveIndicator");
    const text = document.getElementById("saveIndicatorText");
    const icon = indicator.querySelector("i");
    indicator.className = "save-indicator " + type;
    text.textContent = message;
    icon.className =
        type === "success"
            ? "fas fa-check-circle"
            : "fas fa-exclamation-circle";
    indicator.classList.add("show");
    setTimeout(() => indicator.classList.remove("show"), 3000);
}

// ===============================================
// EDIT ORDER MODAL
// ===============================================
(function initEditModal() {
    if (document.getElementById("editOrderModal")) return;
    const modalHTML = `
        <div id="editOrderModal" class="edit-modal">
            <div class="edit-modal-content">
                <div class="edit-modal-header">
                    <h3><i class="fas fa-edit"></i> Sá»­a Ä‘Æ¡n hÃ ng <span class="order-code" id="modalOrderCode">...</span></h3>
                    <button class="edit-modal-close" onclick="closeEditModal()"><i class="fas fa-times"></i></button>
                </div>
                <div class="edit-tabs">
                    <button class="edit-tab-btn active" onclick="switchEditTab('info')"><i class="fas fa-user"></i> ThÃ´ng tin liÃªn há»‡</button>
                    <button class="edit-tab-btn" onclick="switchEditTab('products')"><i class="fas fa-box"></i> Sáº£n pháº©m (<span id="productCount">0</span>)</button>
                    <button class="edit-tab-btn" onclick="switchEditTab('delivery')"><i class="fas fa-shipping-fast"></i> ThÃ´ng tin giao hÃ ng</button>
                    <button class="edit-tab-btn" onclick="switchEditTab('live')"><i class="fas fa-video"></i> Lá»‹ch sá»­ Ä‘Æ¡n live</button>
                    <button class="edit-tab-btn" onclick="switchEditTab('invoices')"><i class="fas fa-file-invoice-dollar"></i> ThÃ´ng tin hÃ³a Ä‘Æ¡n</button>
                    <button class="edit-tab-btn" onclick="switchEditTab('invoice_history')"><i class="fas fa-history"></i> Lá»‹ch sá»­ hÃ³a Ä‘Æ¡n</button>
                    <button class="edit-tab-btn" onclick="switchEditTab('history')"><i class="fas fa-clock"></i> Lá»‹ch sá»­ chá»‰nh sá»­a</button>
                </div>
                <div class="edit-modal-body" id="editModalBody"><div class="loading-state"><div class="loading-spinner"></div></div></div>
                <div class="edit-modal-footer">
                    <div class="modal-footer-left"><i class="fas fa-info-circle"></i> Cáº­p nháº­t láº§n cuá»‘i: <span id="lastUpdated">...</span></div>
                    <div class="modal-footer-right">
                        <button class="btn-modal btn-modal-print" onclick="printOrder()"><i class="fas fa-print"></i> In Ä‘Æ¡n</button>
                        <button class="btn-modal btn-modal-cancel" onclick="closeEditModal()"><i class="fas fa-times"></i> ÄÃ³ng</button>
                        <button class="btn-modal btn-modal-save" onclick="saveAllOrderChanges()"><i class="fas fa-save"></i> LÆ°u táº¥t cáº£ thay Ä‘á»•i</button>
                    </div>
                </div>
            </div>
        </div>`;
    document.body.insertAdjacentHTML("beforeend", modalHTML);
})();

let hasUnsavedOrderChanges = false;

// Toggle merged order edit dropdown
function toggleMergedEditDropdown(button, event) {
    event.stopPropagation();
    const dropdown = button.parentElement;
    const options = dropdown.querySelector('.merged-edit-options');

    // Close all other dropdowns first
    document.querySelectorAll('.merged-edit-options').forEach(opt => {
        if (opt !== options) opt.style.display = 'none';
    });

    // Toggle this dropdown
    options.style.display = options.style.display === 'none' ? 'block' : 'none';
}

// Close all merged edit dropdowns
function closeMergedEditDropdown() {
    document.querySelectorAll('.merged-edit-options').forEach(opt => {
        opt.style.display = 'none';
    });
}

// Close dropdown when clicking outside
document.addEventListener('click', function (e) {
    if (!e.target.closest('.merged-edit-dropdown')) {
        closeMergedEditDropdown();
    }
});

async function openEditModal(orderId) {
    currentEditOrderId = orderId;
    hasUnsavedOrderChanges = false; // Reset dirty flag
    const modal = document.getElementById("editOrderModal");
    modal.classList.add("show");
    switchEditTab("info");
    document.getElementById("editModalBody").innerHTML =
        `<div class="loading-state"><div class="loading-spinner"></div><div class="loading-text">Äang táº£i dá»¯ liá»‡u Ä‘Æ¡n hÃ ng...</div></div>`;
    try {
        await fetchOrderData(orderId);
    } catch (error) {
        showErrorState(error.message);
    }
}

// Export to window for use in discount stats UI
window.openEditModal = openEditModal;

async function fetchOrderData(orderId) {
    const headers = await window.tokenManager.getAuthHeader();
    const apiUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${orderId})?$expand=Details,Partner,User,CRMTeam`;
    const response = await API_CONFIG.smartFetch(apiUrl, {
        headers: {
            ...headers,
            "Content-Type": "application/json",
            Accept: "application/json",
        },
    });
    if (!response.ok)
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    currentEditOrderData = await response.json();
    updateModalWithData(currentEditOrderData);
}

function updateModalWithData(data) {
    document.getElementById("modalOrderCode").textContent = data.Code || "";
    document.getElementById("lastUpdated").textContent = new Date(
        data.LastUpdated,
    ).toLocaleString("vi-VN");
    document.getElementById("productCount").textContent =
        data.Details?.length || 0;
    switchEditTab("info");

    // ğŸ”„ Refresh inline search UI after data is loaded
    // Use setTimeout to ensure DOM is ready
    setTimeout(() => {
        refreshInlineSearchUI();
    }, 100);
}

function switchEditTab(tabName) {
    document
        .querySelectorAll(".edit-tab-btn")
        .forEach((btn) => btn.classList.remove("active"));
    const activeTab = document.querySelector(
        `.edit-tab-btn[onclick*="${tabName}"]`,
    );
    if (activeTab) activeTab.classList.add("active");
    renderTabContent(tabName);
    if (tabName === "products") initInlineSearchAfterRender();
}

function renderTabContent(tabName) {
    const body = document.getElementById("editModalBody");
    if (!currentEditOrderData) {
        body.innerHTML = `<div class="loading-state"><div class="loading-spinner"></div></div>`;
        return;
    }
    const renderers = {
        info: renderInfoTab,
        products: renderProductsTab,
        delivery: renderDeliveryTab,
        live: renderLiveTab,
        invoices: renderInvoicesTab,
        invoice_history: renderInvoiceHistoryTab,
        history: renderHistoryTab,
    };
    body.innerHTML = renderers[tabName]
        ? renderers[tabName](currentEditOrderData)
        : `<div class="empty-state"><p>Tab khÃ´ng tá»“n táº¡i</p></div>`;
}

function renderInfoTab(data) {
    return `
        <div class="info-card">
            <h4><i class="fas fa-user"></i> ThÃ´ng tin khÃ¡ch hÃ ng</h4>
            <div class="info-grid">
                <div class="info-field"><div class="info-label">TÃªn khÃ¡ch hÃ ng</div><div class="info-value highlight">${data.Name || ""}</div></div>
                <div class="info-field">
                    <div class="info-label">Äiá»‡n thoáº¡i</div>
                    <div class="info-value">
                        <input type="text" class="form-control" value="${data.Telephone || ""}" 
                            onchange="updateOrderInfo('Telephone', this.value)" 
                            style="width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px;">
                    </div>
                </div>
                <div class="info-field" style="grid-column: 1 / -1;">
                    <div class="info-label">Äá»‹a chá»‰ Ä‘áº§y Ä‘á»§</div>
                    <div class="info-value">
                        <textarea class="form-control" 
                            onchange="updateOrderInfo('Address', this.value)" 
                            style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; min-height: 60px; resize: vertical;">${data.Address || ""}</textarea>
                    </div>
                </div>
                <div class="info-field" style="grid-column: 1 / -1; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
                    <div class="info-label" style="color: #2563eb; font-weight: 600;">Tra cá»©u Ä‘á»‹a chá»‰</div>
                    <div class="info-value">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="text" id="fullAddressLookupInput" class="form-control" placeholder="Nháº­p Ä‘á»‹a chá»‰ Ä‘áº§y Ä‘á»§ (VD: 28/6 pháº¡m vÄƒn chiÃªu...)" 
                                style="flex: 1; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px;"
                                onkeydown="if(event.key === 'Enter') handleFullAddressLookup()">
                            <button type="button" class="btn-primary" onclick="handleFullAddressLookup()" style="padding: 6px 12px; background: #059669; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                <i class="fas fa-magic"></i> TÃ¬m Full
                            </button>
                        </div>
                        <div id="addressLookupResults" style="display: none; border: 1px solid #e5e7eb; border-radius: 4px; max-height: 400px; overflow-y: auto; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                            <!-- Results will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="info-card">
            <h4><i class="fas fa-shopping-cart"></i> ThÃ´ng tin Ä‘Æ¡n hÃ ng</h4>
            <div class="info-grid">
                <div class="info-field"><div class="info-label">MÃ£ Ä‘Æ¡n</div><div class="info-value highlight">${data.Code || ""}</div></div>
                <div class="info-field"><div class="info-label">Tráº¡ng thÃ¡i</div><div class="info-value"><span class="status-badge-large ${data.Status === "Draft" ? "status-badge-draft" : "status-badge-order"}">${data.StatusText || data.Status || ""}</span></div></div>
                <div class="info-field"><div class="info-label">Tá»•ng tiá»n</div><div class="info-value highlight">${(data.TotalAmount || 0).toLocaleString("vi-VN")}Ä‘</div></div>
                <div class="info-field" style="grid-column: 1 / -1;">
                    <div class="info-label">Ghi chÃº</div>
                    <div class="info-value">${window.DecodingUtility ? window.DecodingUtility.formatNoteWithDecodedData(data.Note || "") : (data.Note || "")}</div>
                </div>
            </div>
        </div>`;
}

function updateOrderInfo(field, value) {
    if (!currentEditOrderData) return;
    currentEditOrderData[field] = value;
    hasUnsavedOrderChanges = true; // Set dirty flag

    // Show quick feedback
    if (window.showSaveIndicator) {
        showSaveIndicator("success", "ÄÃ£ cáº­p nháº­t thÃ´ng tin (chÆ°a lÆ°u)");
    } else if (window.notificationManager) {
        window.notificationManager.show("ÄÃ£ cáº­p nháº­t thÃ´ng tin (chÆ°a lÆ°u)", "info");
    }
}

function renderProductsTab(data) {
    const inlineSearchHTML = `
        <div class="product-search-inline">
            <div class="search-input-wrapper">
                <i class="fas fa-search search-icon"></i>
                <input type="text" id="inlineProductSearch" class="inline-search-input" placeholder="TÃ¬m sáº£n pháº©m theo tÃªn hoáº·c mÃ£..." autocomplete="off">
            </div>
            <div id="inlineSearchResults" class="inline-search-results"></div>
        </div>`;

    if (!data.Details || data.Details.length === 0) {
        return `<div class="info-card">${inlineSearchHTML}<div class="empty-state"><i class="fas fa-box-open"></i><p>ChÆ°a cÃ³ sáº£n pháº©m</p></div></div>`;
    }

    const productsHTML = data.Details.map(
        (p, i) => `
        <tr class="product-row" data-index="${i}">
            <td>${i + 1}</td>
            <td>${p.ImageUrl ? `<img src="${p.ImageUrl}" class="product-image">` : ""}</td>
            <td><div>${p.ProductNameGet || p.ProductName}</div><div style="font-size: 11px; color: #6b7280;">MÃ£: ${p.ProductCode || "N/A"}</div></td>
            <td style="text-align: center;"><div class="quantity-controls"><button onclick="updateProductQuantity(${i}, -1)" class="qty-btn"><i class="fas fa-minus"></i></button><input type="number" class="quantity-input" value="${p.Quantity || 1}" onchange="updateProductQuantity(${i}, 0, this.value)" min="1"><button onclick="updateProductQuantity(${i}, 1)" class="qty-btn"><i class="fas fa-plus"></i></button></div></td>
            <td style="text-align: right;">${(p.Price || 0).toLocaleString("vi-VN")}Ä‘</td>
            <td style="text-align: right; font-weight: 600;">${((p.Quantity || 0) * (p.Price || 0)).toLocaleString("vi-VN")}Ä‘</td>
            <td><input type="text" class="note-input" value="${p.Note || ""}" onchange="updateProductNote(${i}, this.value)"></td>
            <td style="text-align: center;"><div class="action-buttons"><button onclick="editProductDetail(${i})" class="btn-product-action btn-edit-item" title="Sá»­a"><i class="fas fa-edit"></i></button><button onclick="removeProduct(${i})" class="btn-product-action btn-delete-item" title="XÃ³a"><i class="fas fa-trash"></i></button></div></td>
        </tr>`,
    ).join("");

    return `
        <div class="info-card">
            ${inlineSearchHTML}
            <h4 style="margin-top: 24px;"><i class="fas fa-box"></i> Danh sÃ¡ch sáº£n pháº©m (${data.Details.length})</h4>
            <table class="products-table">
                <thead><tr><th>#</th><th>áº¢nh</th><th>Sáº£n pháº©m</th><th style="text-align: center;">SL</th><th style="text-align: right;">ÄÆ¡n giÃ¡</th><th style="text-align: right;">ThÃ nh tiá»n</th><th>Ghi chÃº</th><th style="text-align: center;">Thao tÃ¡c</th></tr></thead>
                <tbody id="productsTableBody">${productsHTML}</tbody>
                <tfoot style="background: #f9fafb; font-weight: 600;"><tr><td colspan="3" style="text-align: right;">Tá»•ng cá»™ng:</td><td style="text-align: center;" id="totalQuantity">${data.TotalQuantity || 0}</td><td></td><td style="text-align: right; color: #3b82f6;" id="totalAmount">${(data.TotalAmount || 0).toLocaleString("vi-VN")}Ä‘</td><td colspan="2"></td></tr></tfoot>
            </table>
        </div>`;
}

function renderDeliveryTab(data) {
    return `<div class="empty-state"><p>ThÃ´ng tin giao hÃ ng</p></div>`;
}
function renderLiveTab(data) {
    // Display live stream information if available
    const liveInfo = data.CRMTeam || {};
    const hasLiveInfo = liveInfo && liveInfo.Name;

    if (!hasLiveInfo) {
        return `
            <div class="empty-state">
                <i class="fas fa-video" style="font-size: 48px; color: #d1d5db; margin-bottom: 16px;"></i>
                <p style="color: #6b7280; margin-bottom: 8px;">KhÃ´ng cÃ³ thÃ´ng tin chiáº¿n dá»‹ch live</p>
                <p style="color: #9ca3af; font-size: 13px;">ÄÆ¡n hÃ ng nÃ y chÆ°a Ä‘Æ°á»£c liÃªn káº¿t vá»›i chiáº¿n dá»‹ch live nÃ o</p>
            </div>
        `;
    }

    return `
        <div class="info-card">
            <h4><i class="fas fa-video"></i> ThÃ´ng tin Livestream</h4>
            <div class="info-grid">
                <div class="info-field">
                    <div class="info-label">TÃªn chiáº¿n dá»‹ch</div>
                    <div class="info-value highlight">${liveInfo.Name || 'N/A'}</div>
                </div>
                <div class="info-field">
                    <div class="info-label">MÃ£ chiáº¿n dá»‹ch</div>
                    <div class="info-value">${liveInfo.Code || 'N/A'}</div>
                </div>
                ${liveInfo.Description ? `
                <div class="info-field" style="grid-column: 1 / -1;">
                    <div class="info-label">MÃ´ táº£</div>
                    <div class="info-value">${liveInfo.Description}</div>
                </div>
                ` : ''}
            </div>
        </div>
        <div class="info-card">
            <h4><i class="fas fa-info-circle"></i> ThÃ´ng tin bá»• sung</h4>
            <div class="info-grid">
                <div class="info-field">
                    <div class="info-label">NgÆ°á»i phá»¥ trÃ¡ch</div>
                    <div class="info-value">${data.User?.Name || 'N/A'}</div>
                </div>
                <div class="info-field">
                    <div class="info-label">Thá»i gian táº¡o Ä‘Æ¡n</div>
                    <div class="info-value">${data.CreatedDate ? new Date(data.CreatedDate).toLocaleString('vi-VN') : 'N/A'}</div>
                </div>
            </div>
        </div>
    `;
}
function renderInvoicesTab(data) {
    // Display invoice/payment information
    const hasInvoice = data.InvoiceNumber || data.InvoiceDate;

    return `
        <div class="info-card">
            <h4><i class="fas fa-file-invoice-dollar"></i> ThÃ´ng tin hÃ³a Ä‘Æ¡n & thanh toÃ¡n</h4>
            <div class="info-grid">
                <div class="info-field">
                    <div class="info-label">Sá»‘ hÃ³a Ä‘Æ¡n</div>
                    <div class="info-value highlight">${data.InvoiceNumber || 'ChÆ°a xuáº¥t hÃ³a Ä‘Æ¡n'}</div>
                </div>
                <div class="info-field">
                    <div class="info-label">NgÃ y xuáº¥t hÃ³a Ä‘Æ¡n</div>
                    <div class="info-value">${data.InvoiceDate ? new Date(data.InvoiceDate).toLocaleString('vi-VN') : 'N/A'}</div>
                </div>
                <div class="info-field">
                    <div class="info-label">Tá»•ng tiá»n</div>
                    <div class="info-value highlight" style="color: #059669; font-weight: 700;">
                        ${(data.TotalAmount || 0).toLocaleString('vi-VN')}Ä‘
                    </div>
                </div>
                <div class="info-field">
                    <div class="info-label">ÄÃ£ thanh toÃ¡n</div>
                    <div class="info-value" style="color: ${data.PaidAmount > 0 ? '#059669' : '#6b7280'};">
                        ${(data.PaidAmount || 0).toLocaleString('vi-VN')}Ä‘
                    </div>
                </div>
                <div class="info-field">
                    <div class="info-label">CÃ²n láº¡i</div>
                    <div class="info-value" style="color: ${(data.TotalAmount - (data.PaidAmount || 0)) > 0 ? '#ef4444' : '#059669'};">
                        ${((data.TotalAmount || 0) - (data.PaidAmount || 0)).toLocaleString('vi-VN')}Ä‘
                    </div>
                </div>
                <div class="info-field">
                    <div class="info-label">Tráº¡ng thÃ¡i thanh toÃ¡n</div>
                    <div class="info-value">
                        <span class="status-badge-large ${data.PaidAmount >= data.TotalAmount ? 'status-badge-paid' :
            data.PaidAmount > 0 ? 'status-badge-partial' : 'status-badge-unpaid'
        }">
                            ${data.PaidAmount >= data.TotalAmount ? 'ÄÃ£ thanh toÃ¡n' :
            data.PaidAmount > 0 ? 'Thanh toÃ¡n má»™t pháº§n' : 'ChÆ°a thanh toÃ¡n'
        }
                        </span>
                    </div>
                </div>
            </div>
        </div>
        
        ${data.PaymentMethod ? `
        <div class="info-card">
            <h4><i class="fas fa-credit-card"></i> PhÆ°Æ¡ng thá»©c thanh toÃ¡n</h4>
            <div class="info-grid">
                <div class="info-field">
                    <div class="info-label">PhÆ°Æ¡ng thá»©c</div>
                    <div class="info-value">${data.PaymentMethod}</div>
                </div>
                ${data.PaymentNote ? `
                <div class="info-field" style="grid-column: 1 / -1;">
                    <div class="info-label">Ghi chÃº thanh toÃ¡n</div>
                    <div class="info-value">${data.PaymentNote}</div>
                </div>
                ` : ''}
            </div>
        </div>
        ` : ''}
        
        ${!hasInvoice ? `
        <div class="empty-state">
            <i class="fas fa-file-invoice" style="font-size: 48px; color: #d1d5db; margin-bottom: 16px;"></i>
            <p style="color: #9ca3af; font-size: 13px;">ÄÆ¡n hÃ ng chÆ°a cÃ³ hÃ³a Ä‘Æ¡n chi tiáº¿t</p>
        </div>
        ` : ''}
    `;
}
async function renderHistoryTab(data) {
    // Show loading state initially
    const loadingHTML = `
        <div class="loading-state">
            <div class="loading-spinner"></div>
            <div class="loading-text">Äang táº£i lá»‹ch sá»­ chá»‰nh sá»­a...</div>
        </div>
    `;

    // Return loading first, then fetch data
    setTimeout(async () => {
        try {
            await fetchAndDisplayAuditLog(data.Id);
        } catch (error) {
            console.error('[AUDIT LOG] Error fetching audit log:', error);
            document.getElementById('editModalBody').innerHTML = `
                <div class="empty-state" style="color: #ef4444;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 16px;"></i>
                    <p>KhÃ´ng thá»ƒ táº£i lá»‹ch sá»­ chá»‰nh sá»­a</p>
                    <p style="font-size: 13px; color: #6b7280;">${error.message}</p>
                    <button class="btn-primary" style="margin-top: 16px;" onclick="switchEditTab('history')">
                        <i class="fas fa-redo"></i> Thá»­ láº¡i
                    </button>
                </div>
            `;
        }
    }, 100);

    return loadingHTML;
}

async function renderInvoiceHistoryTab(data) {
    const loadingHTML = `
        <div class="loading-state">
            <div class="loading-spinner"></div>
            <div class="loading-text">Äang táº£i lá»‹ch sá»­ hÃ³a Ä‘Æ¡n...</div>
        </div>
    `;

    // Return loading first, then fetch data
    setTimeout(async () => {
        try {
            const partnerId = data.PartnerId || (data.Partner && data.Partner.Id);
            if (!partnerId) {
                throw new Error("KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin khÃ¡ch hÃ ng (PartnerId)");
            }
            await fetchAndDisplayInvoiceHistory(partnerId);
        } catch (error) {
            console.error('[INVOICE HISTORY] Error:', error);
            document.getElementById('editModalBody').innerHTML = `
                <div class="empty-state" style="color: #ef4444;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 16px;"></i>
                    <p>KhÃ´ng thá»ƒ táº£i lá»‹ch sá»­ hÃ³a Ä‘Æ¡n</p>
                    <p style="font-size: 13px; color: #6b7280;">${error.message}</p>
                    <button class="btn-primary" style="margin-top: 16px;" onclick="switchEditTab('invoice_history')">
                        <i class="fas fa-redo"></i> Thá»­ láº¡i
                    </button>
                </div>
            `;
        }
    }, 100);

    return loadingHTML;
}

async function fetchAndDisplayInvoiceHistory(partnerId) {
    // Calculate date range (last 30 days)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 30);

    const headers = await window.tokenManager.getAuthHeader();
    const apiUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/FastSaleOrder/ODataService.GetOrdersByPartnerId?partnerId=${partnerId}&fromDate=${startDate.toISOString()}&toDate=${endDate.toISOString()}`;

    console.log('[INVOICE HISTORY] Fetching history for partner:', partnerId);

    const response = await API_CONFIG.smartFetch(apiUrl, {
        headers: {
            ...headers,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    });

    if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    console.log('[INVOICE HISTORY] Received data:', data);
    document.getElementById('editModalBody').innerHTML = renderInvoiceHistoryTable(data.value || []);
}

function renderInvoiceHistoryTable(invoices) {
    if (invoices.length === 0) {
        return `
            <div class="empty-state">
                <i class="fas fa-file-invoice" style="font-size: 48px; color: #d1d5db; margin-bottom: 16px;"></i>
                <p style="color: #6b7280; margin-bottom: 8px;">KhÃ´ng cÃ³ lá»‹ch sá»­ hÃ³a Ä‘Æ¡n</p>
                <p style="color: #9ca3af; font-size: 13px;">KhÃ¡ch hÃ ng chÆ°a cÃ³ Ä‘Æ¡n hÃ ng nÃ o trong 30 ngÃ y qua</p>
            </div>
        `;
    }

    const rows = invoices.map((inv, index) => `
        <tr>
            <td>${index + 1}</td>
            <td><a href="https://tomato.tpos.vn/#/app/fastsaleorder/invoiceform1?id=${inv.Id}" target="_blank" style="color: #3b82f6; text-decoration: none; font-weight: 500;">${inv.Number || 'N/A'}</a></td>
            <td style="text-align: right; font-weight: 600;">${(inv.AmountTotal || 0).toLocaleString('vi-VN')}Ä‘</td>
            <td style="text-align: center;">
                <span class="status-badge-large ${inv.State === 'completed' ? 'status-badge-paid' : 'status-badge-order'}">
                    ${inv.ShowState || inv.State || 'N/A'}
                </span>
            </td>
            <td>${inv.DateInvoice ? new Date(inv.DateInvoice).toLocaleString('vi-VN') : 'N/A'}</td>
        </tr>
    `).join('');

    return `
        <div class="info-card">
            <h4><i class="fas fa-history"></i> Lá»‹ch sá»­ hÃ³a Ä‘Æ¡n (30 ngÃ y gáº§n nháº¥t)</h4>
            <div class="table-wrapper" style="max-height: 400px; overflow-y: auto;">
                <table class="table" style="margin-top: 16px; width: 100%;">
                    <thead style="position: sticky; top: 0; background: white; z-index: 1;">
                        <tr>
                            <th style="width: 50px;">#</th>
                            <th>MÃ£ hÃ³a Ä‘Æ¡n</th>
                            <th style="text-align: right;">Tá»•ng tiá»n</th>
                            <th style="text-align: center;">Tráº¡ng thÃ¡i</th>
                            <th>NgÃ y táº¡o</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            </div>
        </div>
    `;
}

async function fetchAndDisplayAuditLog(orderId) {
    const headers = await window.tokenManager.getAuthHeader();
    const apiUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/AuditLog/ODataService.GetAuditLogEntity?entityName=SaleOnline_Order&entityId=${orderId}&skip=0&take=50`;

    console.log('[AUDIT LOG] Fetching audit log for order:', orderId);

    const response = await API_CONFIG.smartFetch(apiUrl, {
        headers: {
            ...headers,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    });

    if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const auditData = await response.json();
    console.log('[AUDIT LOG] Received audit log:', auditData);

    // Display the audit log
    document.getElementById('editModalBody').innerHTML = renderAuditLogTimeline(auditData.value || []);
}

function renderAuditLogTimeline(auditLogs) {
    if (auditLogs.length === 0) {
        return `
            <div class="empty-state">
                <i class="fas fa-history" style="font-size: 48px; color: #d1d5db; margin-bottom: 16px;"></i>
                <p style="color: #6b7280; margin-bottom: 8px;">ChÆ°a cÃ³ lá»‹ch sá»­ chá»‰nh sá»­a</p>
                <p style="color: #9ca3af; font-size: 13px;">CÃ¡c thay Ä‘á»•i trÃªn Ä‘Æ¡n hÃ ng sáº½ Ä‘Æ°á»£c ghi láº¡i táº¡i Ä‘Ã¢y</p>
            </div>
        `;
    }

    // Map action to icon and color
    const actionConfig = {
        'CREATE': { icon: 'plus-circle', color: '#3b82f6', label: 'Táº¡o má»›i' },
        'UPDATE': { icon: 'edit', color: '#8b5cf6', label: 'Cáº­p nháº­t' },
        'DELETE': { icon: 'trash', color: '#ef4444', label: 'XÃ³a' },
        'APPROVE': { icon: 'check-circle', color: '#10b981', label: 'PhÃª duyá»‡t' },
        'REJECT': { icon: 'x-circle', color: '#ef4444', label: 'Tá»« chá»‘i' }
    };

    return `
        <div class="history-timeline">
            <div class="timeline-header">
                <h4><i class="fas fa-history"></i> Lá»‹ch sá»­ thay Ä‘á»•i</h4>
                <span class="timeline-count">${auditLogs.length} thay Ä‘á»•i</span>
            </div>
            <div class="timeline-content">
                ${auditLogs.map((log, index) => {
        const config = actionConfig[log.Action] || { icon: 'circle', color: '#6b7280', label: log.Action };
        const date = new Date(log.DateCreated);
        const description = formatAuditDescription(log.Description);

        return `
                        <div class="timeline-item ${index === 0 ? 'timeline-item-latest' : ''}">
                            <div class="timeline-marker" style="background: ${config.color};">
                                <i class="fas fa-${config.icon}"></i>
                            </div>
                            <div class="timeline-card">
                                <div class="timeline-card-header">
                                    <div>
                                        <div class="timeline-action">
                                            <span class="action-badge" style="background: ${config.color};">${config.label}</span>
                                            ${log.Code ? `<span class="action-code">${log.Code}</span>` : ''}
                                        </div>
                                        <div class="timeline-user">
                                            <i class="fas fa-user"></i> ${log.UserName || 'Há»‡ thá»‘ng'}
                                        </div>
                                    </div>
                                    <div class="timeline-date">
                                        <i class="fas fa-clock"></i>
                                        ${date.toLocaleString('vi-VN', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        })}
                                    </div>
                                </div>
                                ${description ? `
                                <div class="timeline-details">
                                    ${description}
                                </div>
                                ` : ''}
                                ${log.TransactionId ? `
                                <div class="timeline-meta">
                                    <i class="fas fa-fingerprint"></i>
                                    <span style="font-family: monospace; font-size: 11px; color: #9ca3af;">
                                        ${log.TransactionId.substring(0, 8)}...
                                    </span>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
    }).join('')}
            </div>
        </div>
        
        <div class="audit-summary">
            <h4><i class="fas fa-chart-bar"></i> Thá»‘ng kÃª</h4>
            <div class="audit-stats">
                <div class="audit-stat-item">
                    <div class="audit-stat-value">${auditLogs.length}</div>
                    <div class="audit-stat-label">Tá»•ng thay Ä‘á»•i</div>
                </div>
                <div class="audit-stat-item">
                    <div class="audit-stat-value">${[...new Set(auditLogs.map(l => l.UserName))].length}</div>
                    <div class="audit-stat-label">NgÆ°á»i chá»‰nh sá»­a</div>
                </div>
                <div class="audit-stat-item">
                    <div class="audit-stat-value">
                        ${auditLogs.length > 0 ? new Date(auditLogs[0].DateCreated).toLocaleDateString('vi-VN') : 'N/A'}
                    </div>
                    <div class="audit-stat-label">Cáº­p nháº­t cuá»‘i</div>
                </div>
            </div>
        </div>
    `;
}

function formatAuditDescription(description) {
    if (!description) return '';

    // Try to decode encoded strings first
    if (window.DecodingUtility) {
        // Find potential encoded strings (long, no spaces, Base64URL chars)
        description = description.replace(/\b([A-Za-z0-9\-_=]{20,})\b/g, (match) => {
            // Check if it can be decoded
            const decoded = window.DecodingUtility.decodeProductLine(match);
            if (decoded) {
                // Use the utility to format it
                return window.DecodingUtility.formatNoteWithDecodedData(match);
            }
            return match;
        });
    }

    // Replace \r\n with <br> and format the text
    let formatted = description
        .replace(/\r\n/g, '<br>')
        .replace(/\n/g, '<br>');

    // Highlight changes with arrows (=>)
    formatted = formatted.replace(/(\d+(?:,\d+)*(?:\.\d+)?)\s*=>\s*(\d+(?:,\d+)*(?:\.\d+)?)/g,
        '<span class="change-from">$1</span> <i class="fas fa-arrow-right" style="color: #6b7280; font-size: 10px;"></i> <span class="change-to">$2</span>');

    // Highlight product codes and names (e.g., "0610 A3 ÃO TN HT")
    formatted = formatted.replace(/(\d{4}\s+[A-Z0-9]+\s+[^:]+):/g,
        '<strong style="color: #3b82f6;">$1</strong>:');

    // Highlight "ThÃªm chi tiáº¿t"
    formatted = formatted.replace(/ThÃªm chi tiáº¿t/g,
        '<span style="color: #10b981; font-weight: 600;"><i class="fas fa-plus-circle"></i> ThÃªm chi tiáº¿t</span>');

    // Highlight "XÃ³a chi tiáº¿t"  
    formatted = formatted.replace(/XÃ³a chi tiáº¿t/g,
        '<span style="color: #ef4444; font-weight: 600;"><i class="fas fa-minus-circle"></i> XÃ³a chi tiáº¿t</span>');

    return formatted;
}

function showErrorState(message) {
    document.getElementById("editModalBody").innerHTML =
        `<div class="empty-state" style="color: #ef4444;"><i class="fas fa-exclamation-triangle"></i><p>Lá»—i: ${message}</p><button class="btn-primary" onclick="fetchOrderData('${currentEditOrderId}')">Thá»­ láº¡i</button></div>`;
}

function closeEditModal() {
    if (hasUnsavedOrderChanges) {
        // Use custom confirm popup since native confirm may be blocked
        window.notificationManager.confirm(
            "Báº¡n cÃ³ thay Ä‘á»•i chÆ°a lÆ°u. Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n Ä‘Ã³ng khÃ´ng?",
            "Cáº£nh bÃ¡o"
        ).then(result => {
            if (result) {
                forceCloseEditModal();
            }
        });
        return;
    }
    forceCloseEditModal();
}

function forceCloseEditModal() {
    document.getElementById("editOrderModal").classList.remove("show");
    currentEditOrderData = null;
    currentEditOrderId = null;
    hasUnsavedOrderChanges = false;
}

function printOrder() {
    window.print();
}

// =====================================================
// IN-MODAL PRODUCT EDITING (NEW FUNCTIONS)
// =====================================================
function updateProductQuantity(index, change, value = null) {
    const product = currentEditOrderData.Details[index];
    let newQty =
        value !== null ? parseInt(value, 10) : (product.Quantity || 0) + change;
    if (newQty < 1) newQty = 1;
    product.Quantity = newQty;

    const row = document.querySelector(
        `#productsTableBody tr[data-index='${index}']`,
    );
    if (row) {
        row.querySelector(".quantity-input").value = newQty;
        row.querySelector("td:nth-child(6)").textContent =
            (newQty * (product.Price || 0)).toLocaleString("vi-VN") + "Ä‘";
    }
    recalculateTotals();
    showSaveIndicator("success", "Sá»‘ lÆ°á»£ng Ä‘Ã£ cáº­p nháº­t");

    // ğŸ”„ Refresh inline search UI to reflect quantity change
    refreshInlineSearchUI();
}

function updateProductNote(index, note) {
    currentEditOrderData.Details[index].Note = note;
    showSaveIndicator("success", "Ghi chÃº Ä‘Ã£ cáº­p nháº­t");
}

async function removeProduct(index) {
    const product = currentEditOrderData.Details[index];
    const confirmed = await window.notificationManager.confirm(
        `XÃ³a sáº£n pháº©m "${product.ProductNameGet || product.ProductName}"?`,
        "XÃ¡c nháº­n xÃ³a"
    );
    if (!confirmed) return;

    // Remove product from array
    currentEditOrderData.Details.splice(index, 1);

    // Recalculate totals BEFORE re-rendering
    recalculateTotals();

    // Re-render products tab with updated data
    switchEditTab("products");

    showSaveIndicator("success", "ÄÃ£ xÃ³a sáº£n pháº©m");

    // ğŸ”„ Refresh inline search UI to remove green highlight and badge
    refreshInlineSearchUI();
}

function editProductDetail(index) {
    const row = document.querySelector(
        `#productsTableBody tr[data-index='${index}']`,
    );
    const product = currentEditOrderData.Details[index];
    const priceCell = row.querySelector("td:nth-child(5)");
    const actionCell = row.querySelector("td:nth-child(8) .action-buttons");
    priceCell.innerHTML = `<input type="number" class="edit-input" id="price-edit-${index}" value="${product.Price || 0}">`;
    actionCell.innerHTML = `
        <button onclick="saveProductDetail(${index})" class="btn-product-action btn-save-item" title="LÆ°u"><i class="fas fa-check"></i></button>
        <button onclick="cancelProductDetail(${index})" class="btn-product-action btn-cancel-item" title="Há»§y"><i class="fas fa-times"></i></button>`;
    document.getElementById(`price-edit-${index}`).focus();
}

function saveProductDetail(index) {
    const product = currentEditOrderData.Details[index];
    const newPrice = parseInt(document.getElementById(`price-edit-${index}`).value, 10) || 0;

    // Update price
    product.Price = newPrice;

    // Recalculate totals BEFORE re-rendering
    recalculateTotals();

    // Re-render products tab with updated data
    switchEditTab("products");

    showSaveIndicator("success", "GiÃ¡ Ä‘Ã£ cáº­p nháº­t");

    // ğŸ”„ Refresh inline search UI (in case price affects display)
    refreshInlineSearchUI();
}

function cancelProductDetail() {
    switchEditTab("products");
}

function recalculateTotals() {
    let totalQty = 0;
    let totalAmount = 0;
    currentEditOrderData.Details.forEach((p) => {
        totalQty += p.Quantity || 0;
        totalAmount += (p.Quantity || 0) * (p.Price || 0);
    });
    currentEditOrderData.TotalQuantity = totalQty;
    currentEditOrderData.TotalAmount = totalAmount;

    // Update DOM elements if they exist (may not exist if tab is not rendered yet)
    const totalQuantityEl = document.getElementById("totalQuantity");
    const totalAmountEl = document.getElementById("totalAmount");
    const productCountEl = document.getElementById("productCount");

    if (totalQuantityEl) {
        totalQuantityEl.textContent = totalQty;
    }
    if (totalAmountEl) {
        totalAmountEl.textContent = totalAmount.toLocaleString("vi-VN") + "Ä‘";
    }
    if (productCountEl) {
        productCountEl.textContent = currentEditOrderData.Details.length;
    }
}

async function saveAllOrderChanges() {
    console.log('[SAVE DEBUG] saveAllOrderChanges called at:', new Date().toISOString());

    // Use custom confirm popup since native confirm may be blocked
    const userConfirmed = await window.notificationManager.confirm(
        "LÆ°u táº¥t cáº£ thay Ä‘á»•i cho Ä‘Æ¡n hÃ ng nÃ y?",
        "XÃ¡c nháº­n lÆ°u"
    );
    console.log('[SAVE DEBUG] User confirmed:', userConfirmed);

    if (!userConfirmed) return;

    let notifId = null;

    try {
        // Show loading notification
        if (window.notificationManager) {
            notifId = window.notificationManager.saving("Äang lÆ°u Ä‘Æ¡n hÃ ng...");
        }

        // Prepare payload
        const payload = prepareOrderPayload(currentEditOrderData);

        // Validate payload (optional but recommended)
        const validation = validatePayloadBeforePUT(payload);
        if (!validation.valid) {
            throw new Error(
                `Payload validation failed: ${validation.errors.join(", ")}`,
            );
        }

        console.log("[SAVE] Payload to send:", payload);
        console.log(
            "[SAVE] Payload size:",
            JSON.stringify(payload).length,
            "bytes",
        );

        // Get auth headers
        const headers = await window.tokenManager.getAuthHeader();

        // PUT request
        const response = await API_CONFIG.smartFetch(
            `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${currentEditOrderId})`,
            {
                method: "PUT",
                headers: {
                    ...headers,
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(payload),
            },
        );

        if (!response.ok) {
            const errorText = await response.text();
            console.error("[SAVE] Error response:", errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        // Success
        if (window.notificationManager && notifId) {
            window.notificationManager.remove(notifId);
            window.notificationManager.success("ÄÃ£ lÆ°u thÃ nh cÃ´ng!", 2000);
        }

        hasUnsavedOrderChanges = false; // Reset dirty flag after save

        // Clear cache vÃ  reload data tá»« API
        window.cacheManager.clear("orders");

        // ğŸ”’ Preserve Tags tá»« dá»¯ liá»‡u cÅ© trÆ°á»›c khi fetch
        const existingOrder = allData.find(order => order.Id === currentEditOrderId);
        const preservedTags = existingOrder ? existingOrder.Tags : null;

        await fetchOrderData(currentEditOrderId);

        // ğŸ”„ Restore Tags náº¿u API khÃ´ng tráº£ vá»
        if (currentEditOrderData && !currentEditOrderData.Tags && preservedTags) {
            currentEditOrderData.Tags = preservedTags;
        }

        // ğŸ”„ Cáº¬P NHáº¬T Báº¢NG CHÃNH Vá»šI Dá»® LIá»†U Má»šI
        updateOrderInTable(currentEditOrderId, currentEditOrderData);

        // ğŸ”„ Refresh inline search UI after save and reload
        refreshInlineSearchUI();

        console.log("[SAVE] Order saved successfully âœ“");
    } catch (error) {
        console.error("[SAVE] Error:", error);

        if (window.notificationManager) {
            if (notifId) {
                window.notificationManager.remove(notifId);
            }
            window.notificationManager.error(
                `Lá»—i khi lÆ°u: ${error.message}`,
                5000,
            );
        }
    }
}

// =====================================================
// PREPARE PAYLOAD FOR PUT REQUEST
// =====================================================
function prepareOrderPayload(orderData) {
    console.log("[PAYLOAD] Preparing payload for PUT request...");

    // Clone dá»¯ liá»‡u Ä‘á»ƒ khÃ´ng áº£nh hÆ°á»Ÿng original
    const payload = JSON.parse(JSON.stringify(orderData));

    // THÃŠM @odata.context
    if (!payload["@odata.context"]) {
        payload["@odata.context"] =
            "http://tomato.tpos.vn/odata/$metadata#SaleOnline_Order(Details(),Partner(),User(),CRMTeam())/$entity";
        console.log("[PAYLOAD] âœ“ Added @odata.context");
    }

    // âœ… CRITICAL FIX: Xá»¬ LÃ DETAILS ARRAY
    if (payload.Details && Array.isArray(payload.Details)) {
        payload.Details = payload.Details.map((detail, index) => {
            const cleaned = { ...detail };

            // âœ… XÃ“A Id náº¿u null/undefined
            if (
                !cleaned.Id ||
                cleaned.Id === null ||
                cleaned.Id === undefined
            ) {
                delete cleaned.Id;
                console.log(
                    `[PAYLOAD FIX] Detail[${index}]: Removed Id:null for ProductId:`,
                    cleaned.ProductId,
                );
            } else {
                console.log(
                    `[PAYLOAD] Detail[${index}]: Keeping existing Id:`,
                    cleaned.Id,
                );
            }

            // Äáº£m báº£o OrderId match
            cleaned.OrderId = payload.Id;

            return cleaned;
        });
    }

    // Statistics
    const newDetailsCount = payload.Details?.filter((d) => !d.Id).length || 0;
    const existingDetailsCount =
        payload.Details?.filter((d) => d.Id).length || 0;

    const summary = {
        orderId: payload.Id,
        orderCode: payload.Code,
        topLevelFields: Object.keys(payload).length,
        detailsCount: payload.Details?.length || 0,
        newDetails: newDetailsCount,
        existingDetails: existingDetailsCount,
        hasContext: !!payload["@odata.context"],
        hasPartner: !!payload.Partner,
        hasUser: !!payload.User,
        hasCRMTeam: !!payload.CRMTeam,
        hasRowVersion: !!payload.RowVersion,
    };

    console.log("[PAYLOAD] âœ“ Payload prepared successfully:", summary);

    // Validate critical fields
    if (!payload.RowVersion) {
        console.warn("[PAYLOAD] âš ï¸ WARNING: Missing RowVersion!");
    }
    if (!payload["@odata.context"]) {
        console.error("[PAYLOAD] âŒ ERROR: Missing @odata.context!");
    }

    // âœ… VALIDATION: Check for Id: null
    const detailsWithNullId =
        payload.Details?.filter(
            (d) =>
                d.hasOwnProperty("Id") && (d.Id === null || d.Id === undefined),
        ) || [];

    if (detailsWithNullId.length > 0) {
        console.error(
            "[PAYLOAD] âŒ ERROR: Found details with null Id:",
            detailsWithNullId,
        );
        throw new Error(
            "Payload contains details with null Id - this will cause API error",
        );
    }

    return payload;
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                    SECTION 11: INLINE PRODUCT SEARCH                        â•‘
// â•‘                            search: #PRODUCT                                 â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// INLINE PRODUCT SEARCH #PRODUCT
// =====================================================
let inlineSearchTimeout = null;

function initInlineSearchAfterRender() {
    setTimeout(() => {
        const searchInput = document.getElementById("inlineProductSearch");
        if (searchInput && typeof initInlineProductSearch === "function") {
            initInlineProductSearch();
        }

        // ğŸ”„ Refresh inline search UI when switching to products tab
        refreshInlineSearchUI();
    }, 100);
}

function initInlineProductSearch() {
    const searchInput = document.getElementById("inlineProductSearch");
    if (!searchInput) return;
    searchInput.addEventListener("input", () => {
        const query = searchInput.value.trim();
        if (inlineSearchTimeout) clearTimeout(inlineSearchTimeout);
        if (query.length < 2) {
            hideInlineResults();
            return;
        }
        inlineSearchTimeout = setTimeout(() => performInlineSearch(query), 500);
    });
}

async function performInlineSearch(query) {
    const resultsDiv = document.getElementById("inlineSearchResults");
    const searchInput = document.getElementById("inlineProductSearch");
    searchInput.classList.add("searching");
    resultsDiv.className = "inline-search-results loading show";
    resultsDiv.innerHTML = `<div class="inline-search-loading"></div>`;
    try {
        if (!window.productSearchManager.isLoaded)
            await window.productSearchManager.fetchExcelProducts();
        const results = window.productSearchManager.search(query, 20);
        displayInlineResults(results);
    } catch (error) {
        resultsDiv.className = "inline-search-results empty show";
        resultsDiv.innerHTML = `<div style="color: #ef4444;">Lá»—i: ${error.message}</div>`;
    } finally {
        searchInput.classList.remove("searching");
    }
}

function displayInlineResults(results) {
    const resultsDiv = document.getElementById("inlineSearchResults");
    if (!results || results.length === 0) {
        resultsDiv.className = "inline-search-results empty show";
        resultsDiv.innerHTML = `<div>KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m</div>`;
        return;
    }
    resultsDiv.className = "inline-search-results show";

    // Check which products are already in the order
    const productsInOrder = new Map();
    if (currentEditOrderData && currentEditOrderData.Details) {
        currentEditOrderData.Details.forEach(detail => {
            productsInOrder.set(detail.ProductId, detail.Quantity || 0);
        });
    }

    resultsDiv.innerHTML = results
        .map((p) => {
            const isInOrder = productsInOrder.has(p.Id);
            const currentQty = productsInOrder.get(p.Id) || 0;
            const itemClass = isInOrder ? 'inline-result-item in-order' : 'inline-result-item';
            const buttonIcon = isInOrder ? 'fa-check' : 'fa-plus';
            const buttonText = isInOrder ? 'ThÃªm ná»¯a' : 'ThÃªm';

            return `
        <div class="${itemClass}" onclick="addProductToOrderFromInline(${p.Id})" data-product-id="${p.Id}">
            ${isInOrder ? `<div class="inline-result-quantity-badge"><i class="fas fa-shopping-cart"></i> SL: ${currentQty}</div>` : ''}
            ${p.ImageUrl ? `<img src="${p.ImageUrl}" class="inline-result-image">` : `<div class="inline-result-image placeholder"><i class="fas fa-image"></i></div>`}
            <div class="inline-result-info">
                <div class="inline-result-name">${p.Name}</div>
                <div class="inline-result-code">MÃ£: ${p.Code}</div>
            </div>
            <div class="inline-result-price">${(p.Price || 0).toLocaleString("vi-VN")}Ä‘</div>
            <button class="inline-result-add" onclick="event.stopPropagation(); addProductToOrderFromInline(${p.Id})">
                <i class="fas ${buttonIcon}"></i> ${buttonText}
            </button>
        </div>`;
        })
        .join("");
}

function hideInlineResults() {
    const resultsDiv = document.getElementById("inlineSearchResults");
    if (resultsDiv) resultsDiv.classList.remove("show");
}

// =====================================================
// HIGHLIGHT PRODUCT ROW AFTER UPDATE
// =====================================================
function highlightProductRow(index) {
    // Wait for DOM to update
    setTimeout(() => {
        const row = document.querySelector(
            `#productsTableBody tr[data-index="${index}"]`,
        );
        if (!row) return;

        // Add highlight class
        row.classList.add("product-row-highlight");

        // Scroll to the row
        row.scrollIntoView({ behavior: "smooth", block: "center" });

        // Remove highlight after animation
        setTimeout(() => {
            row.classList.remove("product-row-highlight");
        }, 2000);
    }, 100);
}

// =====================================================
// UPDATE PRODUCT ITEM UI AFTER ADDING TO ORDER
// =====================================================
function updateProductItemUI(productId) {
    // Find the product item in search results
    const productItem = document.querySelector(
        `.inline-result-item[data-product-id="${productId}"]`
    );

    if (!productItem) return;

    // Add animation
    productItem.classList.add("just-added");

    // Remove animation class after it completes
    setTimeout(() => {
        productItem.classList.remove("just-added");
    }, 500);

    // Get updated quantity from order
    let updatedQty = 0;
    if (currentEditOrderData && currentEditOrderData.Details) {
        const product = currentEditOrderData.Details.find(
            p => p.ProductId == productId
        );
        updatedQty = product ? (product.Quantity || 0) : 0;
    }

    // Update the item to show it's in order
    if (!productItem.classList.contains("in-order")) {
        productItem.classList.add("in-order");
    }

    // Update or add quantity badge
    let badge = productItem.querySelector(".inline-result-quantity-badge");
    if (!badge) {
        badge = document.createElement("div");
        badge.className = "inline-result-quantity-badge";
        productItem.insertBefore(badge, productItem.firstChild);
    }

    badge.innerHTML = `<i class="fas fa-shopping-cart"></i> SL: ${updatedQty}`;

    // Update button
    const button = productItem.querySelector(".inline-result-add");
    if (button) {
        const icon = button.querySelector("i");
        if (icon) {
            icon.className = "fas fa-check";
        }
        // Update button text
        const textNode = Array.from(button.childNodes).find(
            node => node.nodeType === Node.TEXT_NODE
        );
        if (textNode) {
            textNode.textContent = " ThÃªm ná»¯a";
        }
    }

    console.log(`[UI UPDATE] Product ${productId} UI updated with quantity: ${updatedQty}`);
}

// =====================================================
// REFRESH INLINE SEARCH UI AFTER ANY DATA CHANGE
// =====================================================
function refreshInlineSearchUI() {
    // Get all product items currently displayed in search results
    const productItems = document.querySelectorAll('.inline-result-item');

    if (productItems.length === 0) {
        console.log('[REFRESH UI] No search results to refresh');
        return;
    }

    console.log(`[REFRESH UI] Refreshing ${productItems.length} items in search results`);

    // Create a map of current quantities
    const productsInOrder = new Map();
    if (currentEditOrderData && currentEditOrderData.Details) {
        currentEditOrderData.Details.forEach(detail => {
            productsInOrder.set(detail.ProductId, detail.Quantity || 0);
        });
    }

    // Update each product item
    productItems.forEach(item => {
        const productId = parseInt(item.getAttribute('data-product-id'));
        if (!productId) return;

        const isInOrder = productsInOrder.has(productId);
        const currentQty = productsInOrder.get(productId) || 0;

        // Update classes
        if (isInOrder) {
            if (!item.classList.contains('in-order')) {
                item.classList.add('in-order');
            }
        } else {
            item.classList.remove('in-order');
        }

        // Update or remove badge
        let badge = item.querySelector('.inline-result-quantity-badge');

        if (isInOrder && currentQty > 0) {
            // Product is in order - show/update badge
            if (!badge) {
                badge = document.createElement('div');
                badge.className = 'inline-result-quantity-badge';
                item.insertBefore(badge, item.firstChild);
            }
            badge.innerHTML = `<i class="fas fa-shopping-cart"></i> SL: ${currentQty}`;
        } else if (badge) {
            // Product removed from order - remove badge
            badge.remove();
        }

        // Update button
        const button = item.querySelector('.inline-result-add');
        if (button) {
            const icon = button.querySelector('i');
            if (icon) {
                icon.className = isInOrder ? 'fas fa-check' : 'fas fa-plus';
            }

            // Update button text
            const textNode = Array.from(button.childNodes).find(
                node => node.nodeType === Node.TEXT_NODE
            );
            if (textNode) {
                textNode.textContent = isInOrder ? ' ThÃªm ná»¯a' : ' ThÃªm';
            }
        }
    });

    console.log('[REFRESH UI] UI refresh completed');
}

async function addProductToOrderFromInline(productId) {
    let notificationId = null;

    try {
        // Show loading notification
        if (window.notificationManager) {
            notificationId = window.notificationManager.show(
                "Äang táº£i thÃ´ng tin sáº£n pháº©m...",
                "info",
                0,
                {
                    showOverlay: true,
                    persistent: true,
                    icon: "package",
                },
            );
        }

        // Get full product details from API
        console.log(
            "[INLINE ADD] Fetching full product details for ID:",
            productId,
        );
        const fullProduct =
            await window.productSearchManager.getFullProductDetails(productId);

        if (!fullProduct) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin sáº£n pháº©m");
        }

        console.log("[INLINE ADD] Full product details:", fullProduct);

        // Close loading notification
        if (window.notificationManager && notificationId) {
            window.notificationManager.remove(notificationId);
        }

        // Ensure Details is an array
        if (!currentEditOrderData.Details) {
            currentEditOrderData.Details = [];
        }

        // Check if product already exists in order
        const existingProductIndex = currentEditOrderData.Details.findIndex(
            (p) => p.ProductId == productId,
        );

        if (existingProductIndex > -1) {
            // Product exists - increase quantity
            const existingProduct =
                currentEditOrderData.Details[existingProductIndex];
            const oldQty = existingProduct.Quantity || 0;
            const newQty = oldQty + 1;

            updateProductQuantity(existingProductIndex, 1);

            console.log(
                `[INLINE ADD] Product already exists, increased quantity: ${oldQty} â†’ ${newQty}`,
            );

            showSaveIndicator(
                "success",
                `${existingProduct.ProductNameGet || existingProduct.ProductName} (SL: ${oldQty} â†’ ${newQty})`,
            );

            highlightProductRow(existingProductIndex);
        } else {
            // ============================================
            // QUAN TRá»ŒNG: Product má»›i - THÃŠM Äáº¦Y Äá»¦ COMPUTED FIELDS
            // ============================================
            // Validate sale price (only use PriceVariant or ListPrice, never StandardPrice)
            const salePrice = fullProduct.PriceVariant || fullProduct.ListPrice;
            if (salePrice == null || salePrice < 0) {
                showSaveIndicator("error", `Sáº£n pháº©m "${fullProduct.Name || fullProduct.DefaultCode}" (ID: ${fullProduct.Id}) khÃ´ng cÃ³ giÃ¡ bÃ¡n.`);
                throw new Error(`Sáº£n pháº©m "${fullProduct.Name || fullProduct.DefaultCode}" (ID: ${fullProduct.Id}) khÃ´ng cÃ³ giÃ¡ bÃ¡n.`);
            }

            const newProduct = {
                // ============================================
                // REQUIRED FIELDS
                // ============================================
                // âœ… KHÃ”NG cÃ³ Id: null cho sáº£n pháº©m má»›i
                ProductId: fullProduct.Id,
                Quantity: 1,
                Price: salePrice,
                Note: null,
                UOMId: fullProduct.UOM?.Id || 1,
                Factor: 1,
                Priority: 0,
                OrderId: currentEditOrderData.Id,
                LiveCampaign_DetailId: null,
                ProductWeight: 0,

                // ============================================
                // COMPUTED FIELDS - PHáº¢I CÃ“!
                // ============================================
                ProductName: fullProduct.Name || fullProduct.NameTemplate,
                ProductNameGet:
                    fullProduct.NameGet ||
                    `[${fullProduct.DefaultCode}] ${fullProduct.Name}`,
                ProductCode: fullProduct.DefaultCode || fullProduct.Barcode,
                UOMName: fullProduct.UOM?.Name || "CÃ¡i",
                ImageUrl: fullProduct.ImageUrl,
                IsOrderPriority: null,
                QuantityRegex: null,
                IsDisabledLiveCampaignDetail: false,

                // Creator ID
                CreatedById:
                    currentEditOrderData.UserId ||
                    currentEditOrderData.CreatedById,
            };

            currentEditOrderData.Details.push(newProduct);
            showSaveIndicator("success", "ÄÃ£ thÃªm sáº£n pháº©m");
            console.log(
                "[INLINE ADD] Product added with computed fields:",
                newProduct,
            );
        }

        // âš ï¸ QUAN TRá»ŒNG: KHÃ”NG xÃ³a input vÃ  KHÃ”NG áº©n results 
        // Äiá»u nÃ y cho phÃ©p user tiáº¿p tá»¥c thÃªm sáº£n pháº©m khÃ¡c tá»« cÃ¹ng danh sÃ¡ch gá»£i Ã½
        // document.getElementById("inlineProductSearch").value = "";
        // hideInlineResults();

        // Update UI to show product was added
        updateProductItemUI(productId);

        // Chá»‰ focus láº¡i vÃ o input Ä‘á»ƒ tiá»‡n thao tÃ¡c
        const searchInput = document.getElementById("inlineProductSearch");
        if (searchInput) {
            searchInput.focus();
            // Select text Ä‘á»ƒ user cÃ³ thá»ƒ tiáº¿p tá»¥c search hoáº·c giá»¯ nguyÃªn
            searchInput.select();
        }

        // Recalculate totals BEFORE re-rendering
        recalculateTotals();

        // âœ… FIX: Use switchEditTab instead of renderTabContent to re-init event listeners
        switchEditTab("products");
    } catch (error) {
        console.error("[INLINE ADD] Error:", error);

        // Close loading and show error
        if (window.notificationManager) {
            if (notificationId) {
                window.notificationManager.remove(notificationId);
            }
            window.notificationManager.error(
                "KhÃ´ng thá»ƒ táº£i thÃ´ng tin sáº£n pháº©m: " + error.message,
                4000,
            );
        } else {
            alert("Lá»—i: " + error.message);
        }
    }
}

// ============================================
// 3. VALIDATION HELPER (Optional)
// ============================================
function validatePayloadBeforePUT(payload) {
    const errors = [];

    // Check @odata.context
    if (!payload["@odata.context"]) {
        errors.push("Missing @odata.context");
    }

    // Check required fields
    if (!payload.Id) errors.push("Missing Id");
    if (!payload.Code) errors.push("Missing Code");
    if (!payload.RowVersion) errors.push("Missing RowVersion");

    // Check Details
    if (payload.Details && Array.isArray(payload.Details)) {
        payload.Details.forEach((detail, index) => {
            if (!detail.ProductId) {
                errors.push(`Detail[${index}]: Missing ProductId`);
            }

            // Check computed fields (should exist for all products)
            const requiredComputedFields = [
                "ProductName",
                "ProductCode",
                "UOMName",
            ];
            requiredComputedFields.forEach((field) => {
                if (!detail[field]) {
                    errors.push(
                        `Detail[${index}]: Missing computed field ${field}`,
                    );
                }
            });
        });
    }

    if (errors.length > 0) {
        console.error("[VALIDATE] Payload validation errors:", errors);
        return { valid: false, errors };
    }

    console.log("[VALIDATE] Payload is valid âœ“");
    return { valid: true, errors: [] };
}

// Debug payload trÆ°á»›c khi gá»­i API
function debugPayloadBeforeSend(payload) {
    console.group("ğŸ” PAYLOAD DEBUG");

    console.log("Order Info:", {
        id: payload.Id,
        code: payload.Code,
        detailsCount: payload.Details?.length || 0,
    });

    if (payload.Details) {
        console.log("\nğŸ“¦ Details Analysis:");

        const detailsWithId = payload.Details.filter((d) => d.Id);
        const detailsWithoutId = payload.Details.filter((d) => !d.Id);
        const detailsWithNullId = payload.Details.filter(
            (d) =>
                d.hasOwnProperty("Id") && (d.Id === null || d.Id === undefined),
        );

        console.log(`  âœ… Details with valid Id: ${detailsWithId.length}`);
        console.log(
            `  âœ… Details without Id (new): ${detailsWithoutId.length}`,
        );
        console.log(
            `  ${detailsWithNullId.length > 0 ? "âŒ" : "âœ…"} Details with null Id: ${detailsWithNullId.length}`,
        );

        if (detailsWithNullId.length > 0) {
            console.error("\nâŒ FOUND DETAILS WITH NULL ID:");
            detailsWithNullId.forEach((d, i) => {
                console.error(
                    `  Detail[${i}]: ProductId=${d.ProductId}, Id=${d.Id}`,
                );
            });
        }

        console.log("\nğŸ“‹ Details List:");
        payload.Details.forEach((d, i) => {
            console.log(
                `  [${i}] ${d.Id ? "âœ…" : "ğŸ†•"} ProductId=${d.ProductId}, Id=${d.Id || "N/A"}`,
            );
        });
    }

    console.groupEnd();

    // Return validation result
    const hasNullIds =
        payload.Details?.some(
            (d) =>
                d.hasOwnProperty("Id") && (d.Id === null || d.Id === undefined),
        ) || false;

    return {
        valid: !hasNullIds,
        message: hasNullIds
            ? "Payload has details with null Id"
            : "Payload is valid",
    };
}

// =====================================================
// MESSAGE HANDLER FOR CROSS-TAB COMMUNICATION
// =====================================================
window.addEventListener("message", function (event) {
    // Handle request for orders data from product assignment tab
    if (event.data.type === "REQUEST_ORDERS_DATA") {
        console.log('ğŸ“¨ Nháº­n request orders data, allData length:', allData.length);

        // Check if data is loaded
        if (!allData || allData.length === 0) {
            console.log('âš ï¸ allData chÆ°a cÃ³ dá»¯ liá»‡u, sáº½ retry sau 1s');
            // Retry after 1 second
            setTimeout(() => {
                if (allData && allData.length > 0) {
                    sendOrdersDataToTab3();
                } else {
                    console.log('âŒ Váº«n chÆ°a cÃ³ dá»¯ liá»‡u sau khi retry');
                }
            }, 1000);
            return;
        }

        sendOrdersDataToTab3();
    }

    // Handle request for orders data from overview tab
    if (event.data.type === "REQUEST_ORDERS_DATA_FROM_OVERVIEW") {
        console.log('ğŸ“¨ [OVERVIEW] Nháº­n request orders data tá»« tab BÃ¡o CÃ¡o Tá»•ng Há»£p');
        console.log('ğŸ“Š [OVERVIEW] allData length:', allData.length);

        // Check if data is loaded
        if (!allData || allData.length === 0) {
            console.log('âš ï¸ [OVERVIEW] allData chÆ°a cÃ³ dá»¯ liá»‡u, sáº½ retry sau 1s');
            // Retry after 1 second
            setTimeout(() => {
                if (allData && allData.length > 0) {
                    sendOrdersDataToOverview();
                } else {
                    console.log('âŒ [OVERVIEW] Váº«n chÆ°a cÃ³ dá»¯ liá»‡u sau khi retry');
                }
            }, 1000);
            return;
        }

        sendOrdersDataToOverview();
    }

    // Handle request to fetch conversations for orders loaded from Firebase
    if (event.data.type === "FETCH_CONVERSATIONS_FOR_ORDERS") {
        handleFetchConversationsRequest(event.data.orders || []);
    }

    // Handle request for employee ranges from overview tab
    if (event.data.type === "REQUEST_EMPLOYEE_RANGES") {
        console.log('ğŸ“¨ [EMPLOYEE] Nháº­n request employee ranges tá»« tab BÃ¡o CÃ¡o Tá»•ng Há»£p');
        console.log('ğŸ“Š [EMPLOYEE] employeeRanges length:', employeeRanges.length);

        // Send employee ranges back to overview
        window.parent.postMessage({
            type: 'EMPLOYEE_RANGES_RESPONSE',
            ranges: employeeRanges || []
        }, '*');
    }

    // Handle request for campaign info from overview tab
    if (event.data.type === "REQUEST_CAMPAIGN_INFO") {
        console.log('ğŸ“¨ [CAMPAIGN] Nháº­n request campaign info tá»« tab BÃ¡o CÃ¡o Tá»•ng Há»£p');

        // Send campaign info back to overview
        window.parent.postMessage({
            type: 'CAMPAIGN_INFO_RESPONSE',
            campaignInfo: {
                allCampaigns: window.campaignManager?.allCampaigns || {},
                activeCampaign: window.campaignManager?.activeCampaign || null,
                activeCampaignId: window.campaignManager?.activeCampaignId || null
            }
        }, '*');

        console.log('âœ… [CAMPAIGN] Sent campaign info:', {
            campaignCount: Object.keys(window.campaignManager?.allCampaigns || {}).length,
            activeCampaign: window.campaignManager?.activeCampaign?.name
        });
    }
});

// Anti-spam: Track fetched channelIds and debounce requests
const fetchedChannelIdsCache = new Set();
let fetchConversationsDebounceTimer = null;
let isFetchingConversationsFromOverview = false;

function handleFetchConversationsRequest(orders) {
    console.log('ğŸ“¨ [CONVERSATIONS] Nháº­n request fetch conversations tá»« tab-overview');
    console.log('ğŸ“Š [CONVERSATIONS] Orders count:', orders.length);

    if (orders.length === 0 || !window.chatDataManager) {
        console.log('[CONVERSATIONS] â­ï¸ Skipping - no orders or chatDataManager not ready');
        return;
    }

    // Prevent concurrent fetches
    if (isFetchingConversationsFromOverview) {
        console.log('[CONVERSATIONS] â­ï¸ Skipping - already fetching');
        return;
    }

    // Parse channelIds from orders
    const allChannelIds = [...new Set(
        orders
            .map(order => {
                const postId = order.Facebook_PostId;
                if (!postId) return null;
                // Parse channelId from Facebook_PostId (format: "pageId_postId")
                const parts = postId.split('_');
                return parts.length > 0 ? parts[0] : null;
            })
            .filter(id => id)
    )];

    // Filter out already fetched channelIds (anti-spam)
    const newChannelIds = allChannelIds.filter(id => !fetchedChannelIdsCache.has(id));

    console.log('[CONVERSATIONS] All channel IDs:', allChannelIds.length);
    console.log('[CONVERSATIONS] New channel IDs (not cached):', newChannelIds.length);
    console.log('[CONVERSATIONS] Cached channel IDs:', fetchedChannelIdsCache.size);

    if (newChannelIds.length === 0) {
        console.log('[CONVERSATIONS] âœ… All channels already fetched, skipping API call');
        // Still re-render in case data changed
        performTableSearch();
        return;
    }

    // Debounce: Wait 500ms before fetching to avoid rapid consecutive calls
    if (fetchConversationsDebounceTimer) {
        clearTimeout(fetchConversationsDebounceTimer);
    }

    fetchConversationsDebounceTimer = setTimeout(async () => {
        isFetchingConversationsFromOverview = true;

        try {
            console.log('[CONVERSATIONS] ğŸ”„ Fetching conversations for', newChannelIds.length, 'channels...');

            // Fetch conversations
            await window.chatDataManager.fetchConversations(true, newChannelIds);

            // Add to cache after successful fetch
            newChannelIds.forEach(id => fetchedChannelIdsCache.add(id));

            console.log('[CONVERSATIONS] âœ… Conversations fetched for Firebase orders');
            console.log('[CONVERSATIONS] Cache size now:', fetchedChannelIdsCache.size);

            // Re-render table to show messages
            performTableSearch();
        } catch (err) {
            console.error('[CONVERSATIONS] âŒ Error fetching conversations:', err);
        } finally {
            isFetchingConversationsFromOverview = false;
        }
    }, 500); // 500ms debounce
}

function sendOrdersDataToTab3() {
    // Prepare orders data with STT (SessionIndex)
    const ordersDataToSend = allData.map((order, index) => ({
        stt: order.SessionIndex || (index + 1).toString(), // Use SessionIndex as STT
        orderId: order.Id,
        orderCode: order.Code,
        customerName: order.PartnerName || order.Name,
        phone: order.PartnerPhone || order.Telephone,
        address: order.PartnerAddress || order.Address,
        totalAmount: order.TotalAmount || order.AmountTotal || 0,
        quantity: order.TotalQuantity || order.Details?.reduce((sum, d) => sum + (d.Quantity || d.ProductUOMQty || 0), 0) || 0,
        note: order.Note,
        state: order.Status || order.State,
        dateOrder: order.DateCreated || order.DateOrder,
        Tags: order.Tags, // Tags JSON array for overview aggregation
        LiveCampaignName: order.LiveCampaignName, // Campaign name for overview filtering
        products: order.Details?.map(d => ({
            id: d.ProductId,
            name: d.ProductName,
            nameGet: d.ProductNameGet,
            code: d.ProductCode,
            quantity: d.Quantity || d.ProductUOMQty || 0,
            price: d.Price || 0,
            imageUrl: d.ImageUrl,
            uom: d.UOMName
        })) || []
    }));

    // Save to localStorage for persistence
    localStorage.setItem('ordersData', JSON.stringify(ordersDataToSend));

    // Send to product assignment tab via parent window forwarding
    // Updated to avoid "SecurityError: Blocked a frame with origin 'null'"
    if (window.parent) {
        window.parent.postMessage({
            type: 'ORDERS_DATA_RESPONSE_TAB3', // Specific type for Tab3 only
            orders: ordersDataToSend
        }, '*');
        console.log(`ğŸ“¤ ÄÃ£ gá»­i ${ordersDataToSend.length} Ä‘Æ¡n hÃ ng vá» parent Ä‘á»ƒ forward sang tab 3`);
    }
}

function sendOrdersDataToOverview() {
    // Prepare orders data with STT (SessionIndex) - use ALL data (not filtered)
    const ordersDataToSend = allData.map((order, index) => ({
        stt: order.SessionIndex || (index + 1).toString(), // Use SessionIndex as STT
        orderId: order.Id,
        orderCode: order.Code,
        customerName: order.PartnerName || order.Name,
        phone: order.PartnerPhone || order.Telephone,
        address: order.PartnerAddress || order.Address,
        totalAmount: order.TotalAmount || order.AmountTotal || 0,
        quantity: order.TotalQuantity || order.Details?.reduce((sum, d) => sum + (d.Quantity || d.ProductUOMQty || 0), 0) || 0,
        note: order.Note,
        state: order.Status || order.State,
        dateOrder: order.DateCreated || order.DateOrder,
        Tags: order.Tags, // Tags JSON array for overview aggregation
        liveCampaignName: order.LiveCampaignName, // Campaign name for overview filtering
        products: order.Details?.map(d => ({
            id: d.ProductId,
            name: d.ProductName,
            nameGet: d.ProductNameGet,
            code: d.ProductCode,
            quantity: d.Quantity || d.ProductUOMQty || 0,
            price: d.Price || 0,
            imageUrl: d.ImageUrl,
            uom: d.UOMName
        })) || []
    }));

    // Send to overview tab via parent window forwarding
    if (window.parent) {
        // FIXED: Get campaign name from multiple sources for reliability
        let campaignName = null;

        // 1. Primary source: window.campaignManager.activeCampaign (most reliable)
        if (window.campaignManager && window.campaignManager.activeCampaign && window.campaignManager.activeCampaign.name) {
            campaignName = window.campaignManager.activeCampaign.name;
            console.log('[OVERVIEW] ğŸ“‹ Campaign name from campaignManager:', campaignName);
        }

        // 2. Fallback: DOM element activeCampaignLabel
        if (!campaignName) {
            const activeCampaignLabel = document.getElementById('activeCampaignLabel');
            if (activeCampaignLabel) {
                // Extract text content, remove icon HTML
                const labelText = activeCampaignLabel.textContent.trim();
                // Check if it's still loading or empty
                if (labelText && labelText !== 'Äang táº£i...' && labelText !== '') {
                    campaignName = labelText;
                    console.log('[OVERVIEW] ğŸ“‹ Campaign name from DOM label:', campaignName);
                }
            }
        }

        // 3. Last fallback: Get from first order's LiveCampaignName
        if (!campaignName && allData.length > 0 && allData[0].LiveCampaignName) {
            campaignName = allData[0].LiveCampaignName;
            console.log('[OVERVIEW] ğŸ“‹ Campaign name from first order:', campaignName);
        }

        console.log('[OVERVIEW] ğŸ“‹ Final campaign name to send:', campaignName);

        window.parent.postMessage({
            type: 'ORDERS_DATA_RESPONSE_OVERVIEW', // Specific type for Overview only
            orders: ordersDataToSend,
            tableName: campaignName, // Campaign name (null if not selected)
            timestamp: Date.now()
        }, '*');
        console.log(`ğŸ“¤ [OVERVIEW] ÄÃ£ gá»­i ${ordersDataToSend.length} Ä‘Æ¡n hÃ ng vá»›i campaign "${campaignName}" vá» tab BÃ¡o CÃ¡o Tá»•ng Há»£p`);
    }
}

// =====================================================
// CHAT MODAL FUNCTIONS
// =====================================================
// Make these global so they can be accessed from other modules (e.g., chat-modal-products.js)
window.currentChatChannelId = null;
window.currentChatPSID = null;
window.currentRealFacebookPSID = null;  // Real Facebook PSID (from_psid) for Graph API
window.currentConversationId = null;  // LÆ°u conversation ID cho reply

// Module-scoped variables (not needed externally)
let currentChatType = null;
let currentChatCursor = null;
window.allChatMessages = []; // Make global for WebSocket access
let skipWebhookUpdate = false; // Flag to skip webhook updates right after sending message
let isSendingMessage = false; // Flag to prevent double message sending
window.allChatComments = []; // Make global for WebSocket access
let isLoadingMoreMessages = false;
let currentOrder = null;  // LÆ°u order hiá»‡n táº¡i Ä‘á»ƒ gá»­i reply

// ============================================================================
// MARK READ/UNREAD STATE MANAGEMENT
// ============================================================================

/**
 * Global state for current conversation read status
 */
window.currentConversationReadState = {
    isRead: false,           // Current read status
    conversationId: null,    // Conversation ID
    pageId: null,            // Page ID
    lastMarkedAt: null,      // Last marked timestamp
    chatType: null           // 'message' or 'comment'
};

/**
 * Timer for auto mark as read debounce
 */
let markReadTimer = null;

/**
 * Update read badge UI
 * @param {boolean} isRead - Read status
 */
function updateReadBadge(isRead) {
    const badge = document.getElementById('chatReadBadge');
    if (!badge) return;

    badge.style.display = 'inline-flex'; // Show badge

    if (isRead) {
        badge.innerHTML = '<i class="fas fa-check-circle"></i> ÄÃ£ Ä‘á»c';
        badge.style.color = '#10b981'; // Green
        badge.style.background = 'rgba(16, 185, 129, 0.2)';
        badge.style.border = '1px solid rgba(16, 185, 129, 0.3)';
    } else {
        badge.innerHTML = '<i class="fas fa-circle"></i> ChÆ°a Ä‘á»c';
        badge.style.color = '#f59e0b'; // Orange
        badge.style.background = 'rgba(245, 158, 11, 0.2)';
        badge.style.border = '1px solid rgba(245, 158, 11, 0.3)';
    }
}

/**
 * Update mark read/unread toggle button UI
 * @param {boolean} isRead - Read status
 */
function updateMarkButton(isRead) {
    const btn = document.getElementById('btnMarkReadToggle');
    if (!btn) return;

    btn.style.display = 'flex'; // Show button

    if (isRead) {
        btn.innerHTML = '<i class="fas fa-envelope-open"></i>';
        btn.style.background = 'rgba(245, 158, 11, 0.8)'; // Orange
        btn.title = 'ÄÃ¡nh dáº¥u chÆ°a Ä‘á»c';
    } else {
        btn.innerHTML = '<i class="fas fa-envelope"></i>';
        btn.style.background = 'rgba(16, 185, 129, 0.8)'; // Green
        btn.title = 'ÄÃ¡nh dáº¥u Ä‘Ã£ Ä‘á»c';
    }
}

/**
 * Auto mark conversation as read with debounce
 * @param {number} delayMs - Delay in milliseconds before marking
 */
function autoMarkAsRead(delayMs = 0) {
    clearTimeout(markReadTimer);

    markReadTimer = setTimeout(async () => {
        const { pageId, conversationId, isRead, chatType } = window.currentConversationReadState;

        // Skip if already marked as read
        if (isRead) {
            console.log('[MARK-READ] Already marked as read, skipping');
            return;
        }

        // Skip for comments (if comment read status not supported)
        if (chatType === 'comment') {
            console.log('[MARK-READ] Skipping auto-mark for comment type');
            return;
        }

        if (!pageId || !conversationId) {
            console.warn('[MARK-READ] Missing pageId or conversationId');
            return;
        }

        console.log('[MARK-READ] Auto marking as read...', conversationId);

        const success = await window.pancakeDataManager.markConversationAsRead(pageId, conversationId);

        if (success) {
            window.currentConversationReadState.isRead = true;
            window.currentConversationReadState.lastMarkedAt = Date.now();
            updateReadBadge(true);
            updateMarkButton(true);

            // âœ¨ NEW: Update conversation data locally and refresh table UI
            if (window.pancakeDataManager) {
                window.pancakeDataManager.updateConversationReadStatus(conversationId, true);

                // Re-render table to show updated badge/count
                if (typeof renderTable === 'function') {
                    console.log('[MARK-READ] ğŸ”„ Auto-refresh table UI...');
                    renderTable();
                }
            }
        }
    }, delayMs);
}

/**
 * Toggle conversation read/unread state manually
 */
window.toggleConversationReadState = async function () {
    const { pageId, conversationId, isRead } = window.currentConversationReadState;

    if (!pageId || !conversationId) {
        alert('KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin cuá»™c há»™i thoáº¡i');
        return;
    }

    const btn = document.getElementById('btnMarkReadToggle');
    if (!btn) return;

    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

    try {
        let success;
        if (isRead) {
            // Mark as unread
            console.log('[MARK-READ] Toggling to unread');
            success = await window.pancakeDataManager.markConversationAsUnread(pageId, conversationId);
        } else {
            // Mark as read
            console.log('[MARK-READ] Toggling to read');
            success = await window.pancakeDataManager.markConversationAsRead(pageId, conversationId);
        }

        if (success) {
            window.currentConversationReadState.isRead = !isRead;
            window.currentConversationReadState.lastMarkedAt = Date.now();
            updateReadBadge(!isRead);
            updateMarkButton(!isRead);

            // âœ¨ NEW: Update conversation data locally and refresh table UI
            if (window.pancakeDataManager) {
                window.pancakeDataManager.updateConversationReadStatus(conversationId, !isRead);

                // Re-render table to show updated badge/count
                if (typeof renderTable === 'function') {
                    console.log('[MARK-READ] ğŸ”„ Refreshing table UI...');
                    renderTable();
                }
            }
        } else {
            alert('KhÃ´ng thá»ƒ thay Ä‘á»•i tráº¡ng thÃ¡i Ä‘á»c');
        }
    } catch (error) {
        console.error('[MARK-READ] Toggle failed:', error);
        alert('Lá»—i khi thay Ä‘á»•i tráº¡ng thÃ¡i Ä‘á»c');
    } finally {
        btn.disabled = false;
        updateMarkButton(window.currentConversationReadState.isRead);
    }
};

// ============================================================================
// END MARK READ/UNREAD STATE MANAGEMENT
// ============================================================================
let currentParentCommentId = null;  // LÆ°u parent comment ID
let currentPostId = null; // LÆ°u post ID cá»§a comment Ä‘ang reply
window.availableChatPages = []; // Cache pages for selector
window.currentSendPageId = null; // Page ID selected for SENDING messages (independent from view)
window.allMatchingConversations = []; // Store all matching conversations for selector
let messageReplyType = 'reply_inbox'; // 'reply_inbox' or 'private_replies' for message modal

// =====================================================
// MESSAGE REPLY TYPE TOGGLE FUNCTIONS
// =====================================================

/**
 * Set the message reply type (toggle between reply_inbox and private_replies)
 * @param {string} type - 'reply_inbox' or 'private_replies'
 */
window.setMessageReplyType = function (type) {
    messageReplyType = type;

    const btnInbox = document.getElementById('btnMsgReplyInbox');
    const btnPrivate = document.getElementById('btnMsgPrivateReply');
    const hintText = document.getElementById('msgReplyTypeHint');

    if (type === 'reply_inbox') {
        // Messenger selected
        if (btnInbox) {
            btnInbox.style.borderColor = '#3b82f6';
            btnInbox.style.background = '#eff6ff';
            btnInbox.style.color = '#1d4ed8';
        }
        if (btnPrivate) {
            btnPrivate.style.borderColor = '#e5e7eb';
            btnPrivate.style.background = 'white';
            btnPrivate.style.color = '#6b7280';
        }
        if (hintText) {
            hintText.textContent = 'Gá»­i tin nháº¯n qua Messenger';
        }
    } else {
        // Private reply from comment selected
        if (btnInbox) {
            btnInbox.style.borderColor = '#e5e7eb';
            btnInbox.style.background = 'white';
            btnInbox.style.color = '#6b7280';
        }
        if (btnPrivate) {
            btnPrivate.style.borderColor = '#3b82f6';
            btnPrivate.style.background = '#eff6ff';
            btnPrivate.style.color = '#1d4ed8';
        }
        if (hintText) {
            hintText.textContent = 'Gá»­i tin nháº¯n riÃªng tá»« comment Ä‘áº·t hÃ ng';
        }
    }

    console.log('[MESSAGE] Reply type set to:', type);
};

/**
 * Show or hide message reply type toggle based on comment availability
 */
window.updateMessageReplyTypeToggle = function () {
    const toggle = document.getElementById('messageReplyTypeToggle');
    if (!toggle) return;

    // Only show toggle for message type and when order has comment
    const hasComment = window.purchaseCommentId && window.purchaseFacebookPostId;
    const isMessageType = currentChatType === 'message';

    if (isMessageType && hasComment) {
        toggle.style.display = 'block';
        console.log('[MESSAGE] Reply type toggle shown - order has comment:', window.purchaseCommentId);
    } else {
        toggle.style.display = 'none';
        // Reset to default when hidden
        messageReplyType = 'reply_inbox';
    }
};

// =====================================================
// CONVERSATION TYPE TOGGLE FUNCTIONS
// =====================================================

// Track current conversation type being viewed
let currentConversationType = 'INBOX'; // 'INBOX' or 'COMMENT'

/**
 * Update conversation type toggle button states
 * @param {string} type - 'INBOX' or 'COMMENT'
 */
window.updateConversationTypeToggle = function (type) {
    const btnInbox = document.getElementById('btnViewInbox');
    const btnComment = document.getElementById('btnViewComment');

    if (!btnInbox || !btnComment) return;

    if (type === 'INBOX') {
        // INBOX selected
        btnInbox.style.borderColor = 'rgba(255, 255, 255, 0.8)';
        btnInbox.style.background = 'rgba(255, 255, 255, 0.2)';
        btnInbox.style.color = 'white';

        btnComment.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        btnComment.style.background = 'transparent';
        btnComment.style.color = 'rgba(255, 255, 255, 0.7)';
    } else {
        // COMMENT selected
        btnInbox.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        btnInbox.style.background = 'transparent';
        btnInbox.style.color = 'rgba(255, 255, 255, 0.7)';

        btnComment.style.borderColor = 'rgba(255, 255, 255, 0.8)';
        btnComment.style.background = 'rgba(255, 255, 255, 0.2)';
        btnComment.style.color = 'white';
    }

    currentConversationType = type;
    console.log('[CONV-TYPE] Conversation type set to:', type);
};

/**
 * Switch between INBOX and COMMENT conversation types
 * @param {string} type - 'INBOX' or 'COMMENT'
 */
window.switchConversationType = async function (type) {
    if (currentConversationType === type) {
        console.log('[CONV-TYPE] Already viewing', type);
        return;
    }

    console.log('[CONV-TYPE] Switching from', currentConversationType, 'to', type);

    // Update toggle button states
    window.updateConversationTypeToggle(type);

    // Update modal title
    const titleText = type === 'COMMENT' ? 'BÃ¬nh luáº­n' : 'Tin nháº¯n';
    const titleElement = document.getElementById('chatModalTitle');
    if (titleElement && currentOrder) {
        titleElement.textContent = `${titleText} vá»›i ${currentOrder.Name}`;
    }

    // Reset state
    window.allChatMessages = [];
    window.allChatComments = [];
    currentChatCursor = null;
    isLoadingMoreMessages = false;
    window.currentConversationId = null;
    currentParentCommentId = null;
    currentPostId = null;

    // Hide conversation selector
    window.hideConversationSelector();

    // Show loading
    const modalBody = document.getElementById('chatModalBody');
    const loadingText = type === 'COMMENT' ? 'Äang táº£i bÃ¬nh luáº­n...' : 'Äang táº£i tin nháº¯n...';
    modalBody.innerHTML = `
        <div class="chat-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>${loadingText}</p>
        </div>`;

    // Update input state based on conversation type
    const chatInput = document.getElementById('chatReplyInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const markReadBtn = document.getElementById('chatMarkReadBtn');

    if (type === 'COMMENT') {
        // Disable input for comments (only enable when replying to specific comment)
        if (chatInput) {
            chatInput.disabled = true;
            chatInput.placeholder = 'Chá»n "Tráº£ lá»i" má»™t bÃ¬nh luáº­n Ä‘á»ƒ reply...';
            chatInput.style.background = '#f3f4f6';
            chatInput.style.cursor = 'not-allowed';
        }
        if (chatSendBtn) {
            chatSendBtn.disabled = true;
            chatSendBtn.style.opacity = '0.5';
            chatSendBtn.style.cursor = 'not-allowed';
        }
        if (markReadBtn) {
            markReadBtn.style.display = 'none';
        }
    } else {
        // Enable input for INBOX messages
        if (chatInput) {
            chatInput.disabled = false;
            chatInput.placeholder = 'Nháº­p tin nháº¯n tráº£ lá»i... (Shift+Enter Ä‘á»ƒ xuá»‘ng dÃ²ng)';
            chatInput.style.background = '#f9fafb';
            chatInput.style.cursor = 'text';
        }
        if (chatSendBtn) {
            chatSendBtn.disabled = false;
            chatSendBtn.style.opacity = '1';
            chatSendBtn.style.cursor = 'pointer';
        }
        if (markReadBtn) {
            markReadBtn.style.display = 'none'; // Keep hidden for now
        }

        // Auto-focus chat input when switching to INBOX (message mode)
        setTimeout(() => {
            if (chatInput) chatInput.focus();
        }, 150);
    }

    // Update current chat type for other functions to use
    currentChatType = type === 'COMMENT' ? 'comment' : 'message';

    // Fetch messages or comments based on type
    // NOTE: Conversations are already fetched when modal opened, just reuse cached IDs
    try {
        if (type === 'COMMENT') {
            // Use cached COMMENT conversation ID (already fetched when modal opened)
            const commentConvId = window.currentCommentConversationId;

            if (!commentConvId) {
                console.warn('[CONV-TYPE] âš ï¸ No COMMENT conversation ID found');
                modalBody.innerHTML = `
                    <div class="chat-error">
                        <i class="fas fa-info-circle"></i>
                        <p>KhÃ´ng tÃ¬m tháº¥y bÃ¬nh luáº­n cho khÃ¡ch hÃ ng nÃ y</p>
                    </div>`;
                return;
            }

            // Use the cached conversation ID
            window.currentConversationId = commentConvId;
            console.log('[CONV-TYPE] âœ… Using cached COMMENT conversationId:', window.currentConversationId);

            // Fetch messages for COMMENT conversation
            console.log('[CONV-TYPE] ğŸ“¥ Fetching messages for COMMENT conversation...');

            const messagesResponse = await window.pancakeDataManager.fetchMessagesForConversation(
                window.currentChatChannelId,
                window.currentConversationId,
                null,
                window.currentCustomerUUID
            );

            // Store as comments (they are actually messages from COMMENT conversation)
            window.allChatComments = messagesResponse.messages || [];
            currentChatCursor = messagesResponse.after;

            console.log('[CONV-TYPE] âœ… Loaded', window.allChatComments.length, 'comments/messages');

            // Render comments
            renderComments(window.allChatComments, true);

            // Setup infinite scroll
            setupChatInfiniteScroll();
            setupNewMessageIndicatorListener();

        } else {
            // Use cached INBOX conversation ID (already fetched when modal opened)
            const inboxConvId = window.currentInboxConversationId;

            if (inboxConvId) {
                window.currentConversationId = inboxConvId;
                console.log('[CONV-TYPE] âœ… Using cached INBOX conversationId:', window.currentConversationId);
            } else {
                // Fallback if not cached
                window.currentConversationId = `${window.currentChatChannelId}_${window.currentChatPSID}`;
                console.log('[CONV-TYPE] Using fallback conversationId:', window.currentConversationId);
            }

            // Fetch messages for INBOX conversation
            console.log('[CONV-TYPE] ğŸ“¥ Fetching messages for INBOX conversation...');

            const response = await window.pancakeDataManager.fetchMessagesForConversation(
                window.currentChatChannelId,
                window.currentConversationId,
                null,
                window.currentCustomerUUID
            );

            window.allChatMessages = response.messages || [];
            currentChatCursor = response.after;

            // Update conversationId from response if available
            if (response.conversationId) {
                window.currentConversationId = response.conversationId;
                console.log('[CONV-TYPE] âœ… Updated conversationId from response:', window.currentConversationId);
            }

            console.log('[CONV-TYPE] âœ… Loaded', window.allChatMessages.length, 'messages');
            renderChatMessages(window.allChatMessages, true);

            // Setup infinite scroll and realtime
            setupChatInfiniteScroll();
            setupNewMessageIndicatorListener();
            setupRealtimeMessages();
        }
    } catch (error) {
        console.error('[CONV-TYPE] Error fetching data:', error);
        modalBody.innerHTML = `
            <div class="chat-error">
                <i class="fas fa-exclamation-triangle"></i>
                <p>Lá»—i khi táº£i ${type === 'COMMENT' ? 'bÃ¬nh luáº­n' : 'tin nháº¯n'}</p>
                <p style="font-size: 12px; color: #6b7280;">${error.message}</p>
            </div>`;
    }
};

// =====================================================
// PAGE SELECTOR FUNCTIONS
// =====================================================

/**
 * Populate SEND page selector dropdown (for sending messages)
 * @param {string} currentPageId - Current page ID to pre-select
 */
window.populateSendPageSelector = async function (currentPageId) {
    console.log('[SEND-PAGE] Populating send page selector, current:', currentPageId);

    const select = document.getElementById('chatSendPageSelect');
    if (!select) {
        console.warn('[SEND-PAGE] Select element not found');
        return;
    }

    // Show loading state
    select.innerHTML = '<option value="">Äang táº£i...</option>';
    select.disabled = true;

    try {
        // Use cached pages if available
        let pages = window.availableChatPages;
        if (!pages || pages.length === 0) {
            // Fetch pages if not cached
            if (window.pancakeDataManager) {
                await window.pancakeDataManager.fetchPages();
                pages = await window.pancakeDataManager.fetchPagesWithUnreadCount();
                window.availableChatPages = pages;
            }
        }

        if (!pages || pages.length === 0) {
            select.innerHTML = '<option value="">KhÃ´ng cÃ³ page</option>';
            select.disabled = true;
            return;
        }

        // Build options
        let optionsHtml = '';
        pages.forEach(page => {
            const isSelected = page.page_id === currentPageId ? 'selected' : '';
            optionsHtml += `<option value="${page.page_id}" ${isSelected}>${page.page_name}</option>`;
        });

        select.innerHTML = optionsHtml;
        select.disabled = false;

        // Set current send page
        window.currentSendPageId = currentPageId;

        // If current page not in list, add it as first option
        if (currentPageId && !pages.find(p => p.page_id === currentPageId)) {
            const currentOption = document.createElement('option');
            currentOption.value = currentPageId;
            currentOption.textContent = `Page ${currentPageId}`;
            currentOption.selected = true;
            select.insertBefore(currentOption, select.firstChild);
        }

        console.log('[SEND-PAGE] âœ… Populated with', pages.length, 'pages, selected:', currentPageId);

    } catch (error) {
        console.error('[SEND-PAGE] âŒ Error:', error);
        select.innerHTML = '<option value="">Lá»—i táº£i</option>';
        select.disabled = true;
    }
};

/**
 * Handle SEND page selection change
 * @param {string} pageId - Selected page ID for sending
 */
window.onSendPageChanged = function (pageId) {
    console.log('[SEND-PAGE] Send page changed to:', pageId);

    if (!pageId) return;

    // Update send page ID (independent from view page)
    window.currentSendPageId = pageId;

    // Show notification
    const selectedPage = window.availableChatPages.find(p => p.page_id === pageId);
    const pageName = selectedPage?.page_name || pageId;

    if (window.notificationManager) {
        window.notificationManager.show(`Sáº½ gá»­i tin nháº¯n tá»« page: ${pageName}`, 'info', 2000);
    }

    console.log('[SEND-PAGE] âœ… Updated currentSendPageId to:', pageId);
};

/**
 * Populate VIEW page selector dropdown with pages from Pancake API
 * @param {string} currentPageId - Current page ID to pre-select
 */
window.populateChatPageSelector = async function (currentPageId) {
    console.log('[PAGE-SELECTOR] Populating page selector, current:', currentPageId);

    const select = document.getElementById('chatPageSelect');
    if (!select) {
        console.warn('[PAGE-SELECTOR] Select element not found');
        return;
    }

    // Show loading state
    select.innerHTML = '<option value="">Äang táº£i pages...</option>';
    select.disabled = true;

    try {
        // Ensure pages are fetched first (for page names)
        if (window.pancakeDataManager) {
            await window.pancakeDataManager.fetchPages();
        }

        // Fetch pages with unread count
        const pagesWithUnread = window.pancakeDataManager ?
            await window.pancakeDataManager.fetchPagesWithUnreadCount() : [];

        if (pagesWithUnread.length === 0) {
            select.innerHTML = '<option value="">KhÃ´ng cÃ³ page nÃ o</option>';
            select.disabled = true;
            return;
        }

        // Cache pages
        window.availableChatPages = pagesWithUnread;

        // Build options
        let optionsHtml = '';
        pagesWithUnread.forEach(page => {
            const isSelected = page.page_id === currentPageId ? 'selected' : '';
            const unreadBadge = page.unread_conv_count > 0 ? ` (${page.unread_conv_count})` : '';
            optionsHtml += `<option value="${page.page_id}" ${isSelected}>${page.page_name}${unreadBadge}</option>`;
        });

        select.innerHTML = optionsHtml;
        select.disabled = false;

        // If current page not in list, add it as first option
        if (currentPageId && !pagesWithUnread.find(p => p.page_id === currentPageId)) {
            const currentOption = document.createElement('option');
            currentOption.value = currentPageId;
            currentOption.textContent = `Page ${currentPageId}`;
            currentOption.selected = true;
            select.insertBefore(currentOption, select.firstChild);
        }

        console.log('[PAGE-SELECTOR] âœ… Populated with', pagesWithUnread.length, 'pages');

    } catch (error) {
        console.error('[PAGE-SELECTOR] âŒ Error populating:', error);
        select.innerHTML = '<option value="">Lá»—i táº£i pages</option>';
        select.disabled = true;
    }
};

/**
 * Handle page selection change
 * @param {string} pageId - Selected page ID
 */
window.onChatPageChanged = async function (pageId) {
    console.log('[PAGE-SELECTOR] Page changed to:', pageId);

    if (!pageId) return;

    // Update currentChatChannelId to use selected page
    const oldChannelId = window.currentChatChannelId;
    window.currentChatChannelId = pageId;

    // Show notification
    const selectedPage = window.availableChatPages.find(p => p.page_id === pageId);
    const pageName = selectedPage?.page_name || pageId;

    if (window.notificationManager) {
        window.notificationManager.show(`Äang táº£i tin nháº¯n tá»« page: ${pageName}...`, 'info', 2000);
    }

    console.log('[PAGE-SELECTOR] âœ… Updated currentChatChannelId to:', pageId);

    // Reload messages/comments for the new page
    await window.reloadChatForSelectedPage(pageId);
};

/**
 * Reload messages/comments when page is changed
 * @param {string} pageId - New page ID to load messages from
 */
window.reloadChatForSelectedPage = async function (pageId) {
    console.log('[PAGE-RELOAD] Reloading chat for page:', pageId);

    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) return;

    const psid = window.currentChatPSID;
    if (!psid) {
        console.error('[PAGE-RELOAD] No PSID available');
        return;
    }

    // Show loading
    const loadingText = currentChatType === 'comment' ? 'Äang táº£i bÃ¬nh luáº­n...' : 'Äang táº£i tin nháº¯n...';
    modalBody.innerHTML = `
        <div class="chat-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>${loadingText}</p>
        </div>`;

    try {
        if (currentChatType === 'comment') {
            // Fetch comments for new page
            const response = await window.chatDataManager.fetchComments(pageId, psid);
            window.allChatComments = response.comments || [];
            currentChatCursor = response.after;

            console.log(`[PAGE-RELOAD] Loaded ${window.allChatComments.length} comments from page ${pageId}`);

            // Update parent comment ID if available
            if (window.allChatComments.length > 0) {
                const rootComment = window.allChatComments.find(c => !c.ParentId) || window.allChatComments[0];
                if (rootComment && rootComment.Id) {
                    currentParentCommentId = getFacebookCommentId(rootComment);
                    console.log(`[PAGE-RELOAD] Updated parent comment ID: ${currentParentCommentId}`);
                }
            }

            renderComments(window.allChatComments, true);
        } else {
            // Fetch messages for new page
            const response = await window.chatDataManager.fetchMessages(pageId, psid);
            window.allChatMessages = response.messages || [];
            currentChatCursor = response.after;

            console.log(`[PAGE-RELOAD] Loaded ${window.allChatMessages.length} messages from page ${pageId}`);

            renderChatMessages(window.allChatMessages, true);

            // Re-setup infinite scroll
            setupChatInfiniteScroll();
            setupNewMessageIndicatorListener();
        }

        // Update conversationId for new page
        if (currentOrder && window.pancakeDataManager) {
            const facebookPsid = currentOrder.Facebook_ASUserId;
            if (facebookPsid) {
                const conversation = window.pancakeDataManager.getConversationByUserId(facebookPsid);
                if (conversation && conversation.customers && conversation.customers.length > 0) {
                    const customerUuid = conversation.customers[0].id;
                    try {
                        const inboxPreview = await window.pancakeDataManager.fetchInboxPreview(pageId, customerUuid);
                        if (inboxPreview.success) {
                            // Use appropriate conversationId based on current chat type
                            if (currentChatType === 'comment') {
                                window.currentConversationId = inboxPreview.commentConversationId
                                    || inboxPreview.inboxConversationId
                                    || inboxPreview.conversationId;
                            } else {
                                window.currentConversationId = inboxPreview.inboxConversationId
                                    || inboxPreview.conversationId;
                            }
                            window.currentInboxConversationId = inboxPreview.inboxConversationId;
                            window.currentCommentConversationId = inboxPreview.commentConversationId;
                            console.log('[PAGE-RELOAD] âœ… Updated conversationIds:', {
                                using: window.currentConversationId,
                                inbox: window.currentInboxConversationId,
                                comment: window.currentCommentConversationId
                            });
                        }
                    } catch (error) {
                        console.warn('[PAGE-RELOAD] Could not fetch inbox_preview:', error);
                    }
                }
            }
        }

        // Show success notification
        const selectedPage = window.availableChatPages.find(p => p.page_id === pageId);
        const pageName = selectedPage?.page_name || pageId;
        if (window.notificationManager) {
            window.notificationManager.show(`âœ… ÄÃ£ táº£i tin nháº¯n tá»« page: ${pageName}`, 'success', 2000);
        }

    } catch (error) {
        console.error('[PAGE-RELOAD] Error loading chat:', error);
        const errorText = currentChatType === 'comment' ? 'Lá»—i khi táº£i bÃ¬nh luáº­n' : 'Lá»—i khi táº£i tin nháº¯n';
        modalBody.innerHTML = `
            <div class="chat-error">
                <i class="fas fa-exclamation-triangle"></i>
                <p>${errorText}</p>
                <p style="font-size: 12px; color: #9ca3af;">${error.message}</p>
            </div>`;
    }
};

// =====================================================
// CONVERSATION SELECTOR FUNCTIONS
// =====================================================

/**
 * Format time ago for conversation selector
 * @param {number} timestamp - Unix timestamp in seconds
 * @returns {string} - Formatted time ago string
 */
function formatConversationTimeAgo(timestamp) {
    if (!timestamp) return '';
    const now = Date.now() / 1000;
    const diff = now - timestamp;

    if (diff < 60) return 'vá»«a xong';
    if (diff < 3600) return `${Math.floor(diff / 60)} phÃºt trÆ°á»›c`;
    if (diff < 86400) return `${Math.floor(diff / 3600)} giá» trÆ°á»›c`;
    if (diff < 604800) return `${Math.floor(diff / 86400)} ngÃ y trÆ°á»›c`;
    return `${Math.floor(diff / 604800)} tuáº§n trÆ°á»›c`;
}

/**
 * Populate conversation selector with all matching conversations
 * Sort by most recent (updated_time) and select the most recent by default
 * @param {Array} conversations - Array of matching conversations
 * @param {string} selectedConvId - Optional conversation ID to pre-select
 */
window.populateConversationSelector = function (conversations, selectedConvId = null) {
    console.log('[CONV-SELECTOR] Populating with', conversations?.length || 0, 'conversations');

    const selectorContainer = document.getElementById('chatConversationSelector');
    const select = document.getElementById('chatConversationSelect');

    if (!selectorContainer || !select) {
        console.error('[CONV-SELECTOR] Selector elements not found');
        return;
    }

    // Hide selector if only 1 or no conversations
    if (!conversations || conversations.length <= 1) {
        selectorContainer.style.display = 'none';
        window.allMatchingConversations = conversations || [];
        return;
    }

    // Store all conversations globally
    window.allMatchingConversations = conversations;

    // Sort by updated_time descending (most recent first)
    const sortedConversations = [...conversations].sort((a, b) => {
        const timeA = a.updated_time || a.last_message_at || 0;
        const timeB = b.updated_time || b.last_message_at || 0;
        return timeB - timeA;
    });

    // Build options HTML
    let optionsHtml = '';
    sortedConversations.forEach((conv, index) => {
        const convId = conv.id || conv.conversation_id || `conv_${index}`;
        const convType = conv.type || 'INBOX';
        const typeIcon = convType === 'COMMENT' ? 'ğŸ’¬' : 'ğŸ“¨';
        const timeAgo = formatConversationTimeAgo(conv.updated_time || conv.last_message_at);
        const lastMessage = conv.last_message?.content || conv.snippet || '';
        const preview = lastMessage.length > 30 ? lastMessage.substring(0, 30) + '...' : lastMessage;
        const pageName = conv.page_name || '';

        // Label format: [Type Icon] [Time] - [Preview] (Page)
        let label = `${typeIcon} ${convType}`;
        if (timeAgo) label += ` â€¢ ${timeAgo}`;
        if (preview) label += ` - ${preview}`;
        if (pageName) label += ` (${pageName})`;

        const isSelected = selectedConvId ? (convId === selectedConvId) : (index === 0);
        optionsHtml += `<option value="${convId}" ${isSelected ? 'selected' : ''}>${label}</option>`;
    });

    select.innerHTML = optionsHtml;
    selectorContainer.style.display = 'block';

    console.log('[CONV-SELECTOR] âœ… Populated with', sortedConversations.length, 'conversations, default:', sortedConversations[0]?.id);

    // Return the most recent conversation (for initial load)
    return sortedConversations[0];
};

/**
 * Handle conversation selection change
 * @param {string} conversationId - Selected conversation ID
 */
window.onChatConversationChanged = async function (conversationId) {
    console.log('[CONV-SELECTOR] Conversation changed to:', conversationId);

    if (!conversationId) return;

    // Find the selected conversation
    const selectedConv = window.allMatchingConversations.find(c =>
        (c.id || c.conversation_id) === conversationId
    );

    if (!selectedConv) {
        console.error('[CONV-SELECTOR] Selected conversation not found:', conversationId);
        return;
    }

    // Show notification
    const convType = selectedConv.type || 'INBOX';
    if (window.notificationManager) {
        window.notificationManager.show(`Äang táº£i ${convType === 'COMMENT' ? 'bÃ¬nh luáº­n' : 'tin nháº¯n'}...`, 'info', 2000);
    }

    // Reload chat for selected conversation
    await window.reloadChatForSelectedConversation(selectedConv);
};

/**
 * Reload messages/comments for selected conversation
 * @param {Object} conversation - Selected conversation object
 */
window.reloadChatForSelectedConversation = async function (conversation) {
    console.log('[CONV-RELOAD] Reloading chat for conversation:', conversation);

    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) return;

    // Get customer UUID from conversation
    const customerUuid = conversation.customers?.[0]?.id || conversation.customer_id;
    const pageId = conversation.page_id || window.currentChatChannelId;
    const convId = conversation.id || conversation.conversation_id;
    const convType = conversation.type || 'INBOX';

    if (!customerUuid) {
        console.error('[CONV-RELOAD] No customer UUID in conversation');
        return;
    }

    // Update global state
    window.currentCustomerUUID = customerUuid;
    window.currentConversationId = convId;
    if (pageId) window.currentChatChannelId = pageId;

    // Show loading
    const loadingText = convType === 'COMMENT' ? 'Äang táº£i bÃ¬nh luáº­n...' : 'Äang táº£i tin nháº¯n...';
    modalBody.innerHTML = `
        <div class="chat-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>${loadingText}</p>
        </div>`;

    try {
        // Fetch inbox_preview to get correct conversationId
        const inboxPreview = await window.pancakeDataManager.fetchInboxPreview(pageId, customerUuid);

        if (inboxPreview.success) {
            // Use appropriate conversationId based on conversation type
            if (convType === 'COMMENT') {
                window.currentConversationId = inboxPreview.commentConversationId
                    || inboxPreview.inboxConversationId
                    || convId;
            } else {
                window.currentConversationId = inboxPreview.inboxConversationId
                    || convId;
            }
            window.currentInboxConversationId = inboxPreview.inboxConversationId;
            window.currentCommentConversationId = inboxPreview.commentConversationId;

            console.log('[CONV-RELOAD] âœ… Got conversationIds from inbox_preview:', {
                using: window.currentConversationId,
                inbox: window.currentInboxConversationId,
                comment: window.currentCommentConversationId
            });
        }

        // Fetch messages based on type
        if (convType === 'COMMENT' || currentChatType === 'comment') {
            const response = await window.chatDataManager.fetchComments(
                pageId,
                window.currentChatPSID,
                null,
                conversation.post_id,
                null
            );
            window.allChatComments = response.comments || [];
            currentChatCursor = response.after;

            console.log(`[CONV-RELOAD] Loaded ${window.allChatComments.length} comments`);

            // Update parent comment ID
            if (window.allChatComments.length > 0) {
                const rootComment = window.allChatComments.find(c => !c.ParentId) || window.allChatComments[0];
                if (rootComment && rootComment.Id) {
                    currentParentCommentId = getFacebookCommentId(rootComment);
                }
            }

            renderComments(window.allChatComments, true);
        } else {
            // Fetch messages for INBOX
            const response = await window.chatDataManager.fetchMessages(
                pageId,
                window.currentChatPSID,
                window.currentConversationId,
                customerUuid
            );
            window.allChatMessages = response.messages || [];
            currentChatCursor = response.after;

            // Update conversationId from response if available
            if (response.conversationId) {
                window.currentConversationId = response.conversationId;
            }

            console.log(`[CONV-RELOAD] Loaded ${window.allChatMessages.length} messages`);

            renderChatMessages(window.allChatMessages, true);
        }

        // Re-setup infinite scroll
        setupChatInfiniteScroll();
        setupNewMessageIndicatorListener();

        // Update input state based on conversation type
        const chatInput = document.getElementById('chatReplyInput');
        const chatSendBtn = document.getElementById('chatSendBtn');

        if (convType === 'COMMENT') {
            // Disable input for COMMENT - require selecting specific comment to reply
            if (chatInput) {
                chatInput.disabled = true;
                chatInput.placeholder = 'Chá»n "Tráº£ lá»i" má»™t bÃ¬nh luáº­n Ä‘á»ƒ reply...';
                chatInput.style.background = '#f3f4f6';
                chatInput.style.cursor = 'not-allowed';
            }
            if (chatSendBtn) {
                chatSendBtn.disabled = true;
                chatSendBtn.style.opacity = '0.5';
                chatSendBtn.style.cursor = 'not-allowed';
            }
            // Update currentChatType to 'comment'
            currentChatType = 'comment';
        } else {
            // Enable input for INBOX
            if (chatInput) {
                chatInput.disabled = false;
                chatInput.placeholder = 'Nháº­p tin nháº¯n tráº£ lá»i... (Shift+Enter Ä‘á»ƒ xuá»‘ng dÃ²ng)';
                chatInput.style.background = '#f9fafb';
                chatInput.style.cursor = 'text';
            }
            if (chatSendBtn) {
                chatSendBtn.disabled = false;
                chatSendBtn.style.opacity = '1';
                chatSendBtn.style.cursor = 'pointer';
                chatSendBtn.title = 'Gá»­i tin nháº¯n';
            }
            // Update currentChatType to 'message'
            currentChatType = 'message';
        }

        // Show success notification
        const convTypeLabel = convType === 'COMMENT' ? 'bÃ¬nh luáº­n' : 'tin nháº¯n';
        if (window.notificationManager) {
            window.notificationManager.show(`âœ… ÄÃ£ táº£i ${convTypeLabel}`, 'success', 2000);
        }

    } catch (error) {
        console.error('[CONV-RELOAD] Error loading chat:', error);
        const errorText = convType === 'COMMENT' ? 'Lá»—i khi táº£i bÃ¬nh luáº­n' : 'Lá»—i khi táº£i tin nháº¯n';
        modalBody.innerHTML = `
            <div class="chat-error">
                <i class="fas fa-exclamation-triangle"></i>
                <p>${errorText}</p>
                <p style="font-size: 12px; color: #9ca3af;">${error.message}</p>
            </div>`;
    }
};

/**
 * Hide conversation selector
 */
window.hideConversationSelector = function () {
    const selectorContainer = document.getElementById('chatConversationSelector');
    if (selectorContainer) {
        selectorContainer.style.display = 'none';
    }
    window.allMatchingConversations = [];
};

// =====================================================
// AVATAR ZOOM MODAL
// =====================================================
window.openAvatarZoom = function (avatarUrl, senderName) {
    // Remove existing modal if any
    const existingModal = document.getElementById('avatar-zoom-modal');
    if (existingModal) existingModal.remove();

    // Create modal
    const modal = document.createElement('div');
    modal.id = 'avatar-zoom-modal';
    modal.innerHTML = `
        <div class="avatar-zoom-overlay" onclick="closeAvatarZoom()" style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100000;
            cursor: zoom-out;
            animation: fadeIn 0.2s ease-out;
        ">
            <div style="text-align: center;">
                <img src="${avatarUrl}" 
                     alt="${senderName}"
                     style="
                        max-width: 90vw;
                        max-height: 80vh;
                        border-radius: 16px;
                        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                        animation: zoomIn 0.3s ease-out;
                     "
                     onclick="event.stopPropagation();"
                     onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 200 200%22><circle cx=%22100%22 cy=%22100%22 r=%22100%22 fill=%22%23e5e7eb%22/><circle cx=%22100%22 cy=%2280%22 r=%2235%22 fill=%22%239ca3af%22/><ellipse cx=%22100%22 cy=%22160%22 rx=%2255%22 ry=%2240%22 fill=%22%239ca3af%22/></svg>'"
                />
                <p style="color: white; font-size: 16px; margin-top: 16px; font-weight: 500;">${senderName}</p>
                <button onclick="closeAvatarZoom()" style="
                    margin-top: 12px;
                    padding: 10px 24px;
                    background: white;
                    color: #111827;
                    border: none;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: transform 0.2s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    <i class="fas fa-times" style="margin-right: 6px;"></i>ÄÃ³ng
                </button>
            </div>
        </div>
    `;

    // Add animation styles
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes zoomIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    `;
    modal.appendChild(style);

    document.body.appendChild(modal);

    // Close on Escape key
    document.addEventListener('keydown', function escHandler(e) {
        if (e.key === 'Escape') {
            closeAvatarZoom();
            document.removeEventListener('keydown', escHandler);
        }
    });
};

window.closeAvatarZoom = function () {
    const modal = document.getElementById('avatar-zoom-modal');
    if (modal) {
        modal.style.opacity = '0';
        setTimeout(() => modal.remove(), 200);
    }
};

window.openChatModal = async function (orderId, channelId, psid, type = 'message') {
    console.log('[CHAT] Opening modal:', { orderId, channelId, psid, type });
    if (!channelId || !psid) {
        alert('KhÃ´ng cÃ³ thÃ´ng tin tin nháº¯n cho Ä‘Æ¡n hÃ ng nÃ y');
        return;
    }

    // Reset pagination state
    window.currentChatChannelId = channelId;
    window.currentChatPSID = psid;
    currentChatType = type;
    currentChatCursor = null;
    window.allChatMessages = [];
    window.allChatComments = [];
    isLoadingMoreMessages = false;
    currentOrder = null;
    currentChatOrderId = null;
    window.currentConversationId = null;
    currentParentCommentId = null;
    currentPostId = null;

    // Hide conversation selector initially (will show if multiple conversations found)
    window.hideConversationSelector();

    // Get order info
    // First try to find order by exact ID match
    let order = allData.find(o => o.Id === orderId);
    // If not found, check if this orderId is in a merged order's OriginalIds
    if (!order) {
        order = allData.find(o => o.IsMerged && o.OriginalIds && o.OriginalIds.includes(orderId));
    }
    if (!order) {
        alert('KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng');
        return;
    }

    // LÆ°u order hiá»‡n táº¡i
    currentOrder = order;
    currentChatOrderId = orderId;

    // Update modal title based on type
    const titleText = type === 'comment' ? 'BÃ¬nh luáº­n' : 'Tin nháº¯n';
    document.getElementById('chatModalTitle').textContent = `${titleText} vá»›i ${order.Name}`;
    document.getElementById('chatModalSubtitleText').textContent = `SÄT: ${order.Telephone || 'N/A'} â€¢ MÃ£ ÄH: ${order.Code}`;

    // Initialize conversation type toggle
    const initialConvType = type === 'comment' ? 'COMMENT' : 'INBOX';
    window.updateConversationTypeToggle(initialConvType);
    // IMPORTANT: Also set currentConversationType so switchConversationType works correctly
    currentConversationType = initialConvType;

    // Show modal
    document.getElementById('chatModal').classList.add('show');

    // Prevent body scroll when modal is open
    document.body.style.overflow = 'hidden';

    // Load and display debt for this order's phone
    loadChatDebt(order.Telephone);

    // Populate page selectors with current channelId
    window.populateChatPageSelector(channelId);  // View page selector
    window.populateSendPageSelector(channelId);  // Send page selector (independent)

    // OPTIMIZATION: Fetch TPOS order details in parallel (non-blocking)
    // This runs independently while messages are being fetched
    // Uses cache to avoid redundant API calls (TTL: 5 minutes)
    const orderDetailsPromise = (async () => {
        try {
            // Check cache first
            let fullOrderData = getOrderDetailsFromCache(orderId);

            if (!fullOrderData) {
                // Cache miss - fetch from API
                console.log(`[CACHE] âŒ Order details cache MISS for ${orderId}, fetching from API...`);
                const headers = await window.tokenManager.getAuthHeader();
                const apiUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${orderId})?$expand=Details,Partner,User,CRMTeam`;
                const response = await API_CONFIG.smartFetch(apiUrl, {
                    headers: {
                        ...headers,
                        'Content-Type': 'application/json',
                        Accept: 'application/json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                fullOrderData = await response.json();

                // Save to cache for future use
                saveOrderDetailsToCache(orderId, fullOrderData);
            }

            // Store full order data for dropped products manager (needed by moveDroppedToOrder)
            window.currentChatOrderData = fullOrderData;

            // Store Facebook data for highlighting purchase comment
            window.purchaseFacebookPostId = fullOrderData.Facebook_PostId || null;
            window.purchaseFacebookASUserId = fullOrderData.Facebook_ASUserId || null;
            window.purchaseCommentId = fullOrderData.Facebook_CommentId || null;

            console.log('[CHAT] Order Facebook data loaded:', {
                PostId: window.purchaseFacebookPostId,
                ASUserId: window.purchaseFacebookASUserId,
                CommentId: window.purchaseCommentId
            });

            // Store CRMTeam for Facebook_PageToken access (for 24h bypass)
            window.currentCRMTeam = fullOrderData.CRMTeam || null;
            if (window.currentCRMTeam && window.currentCRMTeam.Facebook_PageToken) {
                console.log('[CHAT] CRMTeam loaded with Facebook_PageToken');
            }

            // Store order details for products display
            currentChatOrderDetails = fullOrderData.Details ? JSON.parse(JSON.stringify(fullOrderData.Details)) : [];
            console.log('[CHAT] Order details loaded:', currentChatOrderDetails.length, 'products');

            // Render products table
            renderChatProductsTable();

            // Initialize search after render (with delay for DOM ready)
            setTimeout(() => {
                initChatProductSearch();
            }, 100);

            // Setup realtime listener for held products (multi-user collaboration)
            if (typeof window.setupHeldProductsListener === 'function') {
                window.setupHeldProductsListener();
            }

            // Update message reply type toggle (show if order has comment)
            window.updateMessageReplyTypeToggle();
        } catch (error) {
            console.error('[CHAT] Error loading order details:', error);
            // Reset order data
            window.currentChatOrderData = null;
            // Reset Facebook data on error
            window.purchaseFacebookPostId = null;
            window.purchaseFacebookASUserId = null;
            window.purchaseCommentId = null;
            // Reset order details
            currentChatOrderDetails = [];
            renderChatProductsTable();

            // Hide message reply type toggle on error
            window.updateMessageReplyTypeToggle();
        }
    })(); // Execute immediately but don't await - runs in parallel

    // Show loading
    const modalBody = document.getElementById('chatModalBody');
    const loadingText = type === 'comment' ? 'Äang táº£i bÃ¬nh luáº­n...' : 'Äang táº£i tin nháº¯n...';
    modalBody.innerHTML = `
        <div class="chat-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>${loadingText}</p>
        </div>`;

    // Show/hide reply container and mark as read button
    // Show/hide reply container and mark as read button
    const replyContainer = document.getElementById('chatReplyContainer');
    const markReadBtn = document.getElementById('chatMarkReadBtn');

    // Always show reply container for both comment and message
    replyContainer.style.display = 'block';
    const chatInput = document.getElementById('chatReplyInput');
    chatInput.value = '';

    // Reset pasted image and uploaded images array
    currentPastedImage = null;
    window.currentPastedImage = null;
    window.uploadedImagesData = [];
    window.isUploadingImages = false;
    const previewContainer = document.getElementById('chatImagePreviewContainer');
    if (previewContainer) {
        previewContainer.innerHTML = '';
        previewContainer.style.display = 'none';
    }

    // Remove old listener to avoid duplicates (if any) and add new one
    chatInput.removeEventListener('paste', handleChatInputPaste);
    chatInput.addEventListener('paste', handleChatInputPaste);

    // Remove old Enter key listener and add new one with proper event handling
    chatInput.removeEventListener('keydown', handleChatInputKeyDown);
    chatInput.addEventListener('keydown', handleChatInputKeyDown);

    // Add input event listener for auto-resize
    chatInput.removeEventListener('input', handleChatInputInput);
    chatInput.addEventListener('input', handleChatInputInput);

    // Add file input listener for attachment button
    const fileInput = document.getElementById('uploadFileInput');
    if (fileInput) {
        fileInput.removeEventListener('change', handleFileInputChange);
        fileInput.addEventListener('change', handleFileInputChange);
    }

    if (type === 'comment') {
        if (markReadBtn) {
            markReadBtn.style.display = 'none';
        }

        // Disable input and send button by default for comments
        // Only enable when replying to a specific comment
        const chatSendBtn = document.getElementById('chatSendBtn');
        chatInput.disabled = true;
        chatInput.placeholder = 'Chá»n "Tráº£ lá»i" má»™t bÃ¬nh luáº­n Ä‘á»ƒ reply...';
        chatInput.style.background = '#f3f4f6';
        chatInput.style.cursor = 'not-allowed';
        if (chatSendBtn) {
            chatSendBtn.disabled = true;
            chatSendBtn.style.opacity = '0.5';
            chatSendBtn.style.cursor = 'not-allowed';
        }
    } else {
        if (markReadBtn) {
            markReadBtn.style.display = 'none'; // Keep hidden for now or show if needed
        }

        // Re-enable input and send button for chat (message mode)
        // Reset to default state in case it was disabled from previous comment modal
        const chatSendBtn = document.getElementById('chatSendBtn');
        chatInput.disabled = false;
        chatInput.placeholder = 'Nháº­p tin nháº¯n tráº£ lá»i... (Shift+Enter Ä‘á»ƒ xuá»‘ng dÃ²ng)';
        chatInput.style.background = '#f9fafb';
        chatInput.style.cursor = 'text';
        chatInput.style.opacity = '1';
        if (chatSendBtn) {
            chatSendBtn.disabled = false;
            chatSendBtn.style.opacity = '1';
            chatSendBtn.style.cursor = 'pointer';
            chatSendBtn.title = 'Gá»­i tin nháº¯n';
        }

        // Auto-focus chat input for immediate typing (message mode only)
        setTimeout(() => {
            chatInput.focus();
        }, 150);
    }

    // Ensure send button is in correct state after modal initialization
    updateSendButtonState();

    // Fetch messages or comments based on type
    try {
        if (type === 'comment') {
            // Fetch COMMENT conversations from Pancake to get conversation IDs
            const facebookPsid = order.Facebook_ASUserId;
            const facebookPostId = order.Facebook_PostId;

            console.log('[CHAT-MODAL] ğŸ” Fetching COMMENT conversations by fb_id:', facebookPsid, 'post_id:', facebookPostId);

            if (window.pancakeDataManager && facebookPsid) {
                try {
                    // OPTIMIZATION: Fetch conversations AND page access token in parallel
                    console.log('[CHAT-MODAL] âš¡ Starting parallel fetch: conversations + pageAccessToken');
                    const parallelStartTime = Date.now();

                    const [result, preloadedPageAccessToken] = await Promise.all([
                        window.pancakeDataManager.fetchConversationsByCustomerFbId(channelId, facebookPsid),
                        window.pancakeTokenManager?.getOrGeneratePageAccessToken(channelId)
                    ]);

                    console.log(`[CHAT-MODAL] âš¡ Parallel fetch completed in ${Date.now() - parallelStartTime}ms`);

                    if (result.success && result.conversations.length > 0) {
                        console.log('[CHAT-MODAL] âœ… Found', result.conversations.length, 'conversations for fb_id:', facebookPsid);

                        // Save customer UUID
                        window.currentCustomerUUID = result.customerUuid;
                        console.log('[CHAT-MODAL] âœ… Got customer UUID:', window.currentCustomerUUID);

                        // Filter COMMENT conversations
                        // Note: COMMENT conversations don't have post_id field, but their ID format is:
                        // conversation.id = "POST_ID_COMMENT_ID" (e.g., "1300821062062414_1636143350714534")
                        // order.Facebook_PostId = "PAGE_ID_POST_ID" (e.g., "270136663390370_1300821062062414")
                        // Match by: extract POST_ID from order.Facebook_PostId and match with first part of conversation.id

                        let commentConversations;

                        // First, get all COMMENT conversations
                        const allCommentConvs = result.conversations.filter(conv => conv.type === 'COMMENT');

                        // Log all COMMENT conversations for debugging
                        console.log('[CHAT-MODAL] All COMMENT conversations:', allCommentConvs.map(c => ({
                            id: c.id,
                            snippet: c.snippet,
                            updated_at: c.updated_at
                        })));

                        if (facebookPostId && allCommentConvs.length > 0) {
                            // Extract POST_ID from order.Facebook_PostId (format: "PAGE_ID_POST_ID")
                            const postIdParts = facebookPostId.split('_');
                            const postId = postIdParts.length > 1 ? postIdParts[postIdParts.length - 1] : facebookPostId;

                            console.log('[CHAT-MODAL] Extracted POST_ID from order:', postId);

                            // Match conversation where conversation.id starts with POST_ID
                            commentConversations = allCommentConvs.filter(conv => {
                                const convIdFirstPart = conv.id.split('_')[0];
                                const match = convIdFirstPart === postId;
                                if (match) {
                                    console.log('[CHAT-MODAL] âœ“ Match found:', conv.id, 'starts with', postId);
                                }
                                return match;
                            });

                            // If no match, use most recent COMMENT conversation
                            if (commentConversations.length === 0) {
                                console.warn('[CHAT-MODAL] âš ï¸ No match by post_id, using most recent COMMENT conversation');
                                commentConversations = allCommentConvs;
                            }

                            console.log('[CHAT-MODAL] Filtered COMMENT conversations by post_id:', facebookPostId, 'â†’', commentConversations.length, 'found');
                        } else {
                            commentConversations = allCommentConvs;
                            console.log('[CHAT-MODAL] No post_id or no COMMENT conversations, getting all â†’', commentConversations.length, 'found');
                        }

                        if (commentConversations.length > 0) {
                            // Populate conversation selector if multiple COMMENT conversations
                            const mostRecentConv = window.populateConversationSelector(commentConversations, commentConversations[0]?.id);
                            const selectedConv = mostRecentConv || commentConversations[0];

                            // Save COMMENT conversation ID
                            window.currentConversationId = selectedConv.id;
                            window.currentCommentConversationId = selectedConv.id;

                            console.log('[CHAT-MODAL] âœ… Found', commentConversations.length, 'COMMENT conversations matching post_id:', facebookPostId);
                            console.log('[CHAT-MODAL] âœ… Using conversationId:', window.currentConversationId);

                            // Initialize read state for COMMENT (will skip auto-mark since chatType = 'comment')
                            window.currentConversationReadState = {
                                isRead: false,
                                conversationId: window.currentConversationId,
                                pageId: channelId,
                                lastMarkedAt: null,
                                chatType: 'comment'
                            };
                            updateReadBadge(false); // Show badge (but won't auto-mark for comments)
                            updateMarkButton(false);

                            // Now fetch messages for this COMMENT conversation
                            // Pass preloaded pageAccessToken to skip redundant token fetch
                            console.log('[CHAT-MODAL] ğŸ“¥ Fetching messages for COMMENT conversation (using preloaded token)...');

                            const messagesResponse = await window.pancakeDataManager.fetchMessagesForConversation(
                                channelId,
                                window.currentConversationId,
                                null,
                                window.currentCustomerUUID,
                                preloadedPageAccessToken  // Use preloaded token from parallel fetch
                            );

                            // Store as comments (they are messages from COMMENT conversation)
                            window.allChatComments = messagesResponse.messages || [];
                            currentChatCursor = messagesResponse.after;

                            console.log('[CHAT-MODAL] âœ… Loaded', window.allChatComments.length, 'comments/messages');

                            // Render comments
                            renderComments(window.allChatComments, true);

                        } else {
                            console.warn('[CHAT-MODAL] âš ï¸ No COMMENT conversation found for post:', facebookPostId);
                            modalBody.innerHTML = `
                                <div class="chat-error">
                                    <i class="fas fa-info-circle"></i>
                                    <p>KhÃ´ng tÃ¬m tháº¥y bÃ¬nh luáº­n cho bÃ i viáº¿t nÃ y</p>
                                </div>`;
                        }

                        // Also save INBOX conversation ID for quick switching
                        const inboxConv = result.conversations.find(conv => conv.type === 'INBOX');
                        if (inboxConv) {
                            window.currentInboxConversationId = inboxConv.id;
                            console.log('[CHAT-MODAL] âœ… Found INBOX conversationId:', window.currentInboxConversationId);
                        }

                    } else {
                        console.warn('[CHAT-MODAL] âš ï¸ No conversations found for fb_id:', facebookPsid);
                        modalBody.innerHTML = `
                            <div class="chat-error">
                                <i class="fas fa-info-circle"></i>
                                <p>KhÃ´ng tÃ¬m tháº¥y cuá»™c há»™i thoáº¡i</p>
                            </div>`;
                    }
                } catch (fetchError) {
                    console.error('[CHAT-MODAL] âŒ Error fetching COMMENT conversations:', fetchError);
                    modalBody.innerHTML = `
                        <div class="chat-error">
                            <i class="fas fa-exclamation-triangle"></i>
                            <p>Lá»—i khi táº£i bÃ¬nh luáº­n</p>
                            <p style="font-size: 12px; color: #6b7280;">${fetchError.message}</p>
                        </div>`;
                }
            } else {
                console.warn('[CHAT-MODAL] âš ï¸ Missing pancakeDataManager or required data');
                modalBody.innerHTML = `
                    <div class="chat-error">
                        <i class="fas fa-info-circle"></i>
                        <p>Thiáº¿u thÃ´ng tin Ä‘á»ƒ táº£i bÃ¬nh luáº­n</p>
                    </div>`;
            }

            // Setup infinite scroll for comments
            setupChatInfiniteScroll();
            setupNewMessageIndicatorListener();

        } else {
            // Fetch INBOX messages from Pancake
            const facebookPsid = order.Facebook_ASUserId;
            const facebookPostId = order.Facebook_PostId;

            console.log('[CHAT-MODAL] ğŸ” Fetching INBOX conversations by fb_id:', facebookPsid);

            if (window.pancakeDataManager && facebookPsid) {
                try {
                    // OPTIMIZATION: Fetch conversations AND page access token in parallel
                    // This saves ~600ms by not waiting for token after conversations
                    console.log('[CHAT-MODAL] âš¡ Starting parallel fetch: conversations + pageAccessToken');
                    const parallelStartTime = Date.now();

                    const [result, preloadedPageAccessToken] = await Promise.all([
                        window.pancakeDataManager.fetchConversationsByCustomerFbId(channelId, facebookPsid),
                        window.pancakeTokenManager?.getOrGeneratePageAccessToken(channelId)
                    ]);

                    console.log(`[CHAT-MODAL] âš¡ Parallel fetch completed in ${Date.now() - parallelStartTime}ms`);

                    if (result.success && result.conversations.length > 0) {
                        console.log('[CHAT-MODAL] âœ… Found', result.conversations.length, 'conversations for fb_id:', facebookPsid);

                        // Save customer UUID
                        window.currentCustomerUUID = result.customerUuid;
                        console.log('[CHAT-MODAL] âœ… Got customer UUID:', window.currentCustomerUUID);

                        // Filter INBOX conversations
                        const inboxConversations = result.conversations.filter(conv => conv.type === 'INBOX');

                        // Also save COMMENT conversations for quick switching
                        const commentConversations = result.conversations.filter(conv => conv.type === 'COMMENT');

                        console.log('[CHAT-MODAL] - INBOX:', inboxConversations.length, 'conversations, COMMENT:', commentConversations.length, 'conversations');

                        if (inboxConversations.length > 0) {
                            // Use first INBOX conversation
                            const inboxConv = inboxConversations[0];
                            window.currentConversationId = inboxConv.id;
                            window.currentInboxConversationId = inboxConv.id;

                            // DEBUG: Log conversation structure to find real PSID field
                            console.log('[CHAT-MODAL] ğŸ” DEBUG Conversation data:', JSON.stringify({
                                id: inboxConv.id,
                                from_psid: inboxConv.from_psid,
                                from: inboxConv.from,
                                customers: inboxConv.customers,
                                page_id: inboxConv.page_id
                            }, null, 2));

                            // IMPORTANT: Save the real Facebook PSID from conversation data
                            // This is needed for Facebook Graph API (different from Pancake internal ID)
                            // Try multiple sources: from_psid, from.id, customers[0].fb_id
                            window.currentRealFacebookPSID = inboxConv.from_psid
                                || inboxConv.from?.id
                                || (inboxConv.customers && inboxConv.customers[0]?.fb_id);
                            console.log('[CHAT-MODAL] âœ… Real Facebook PSID:', window.currentRealFacebookPSID);

                            console.log('[CHAT-MODAL] âœ… Using INBOX conversationId:', window.currentConversationId);

                            // Initialize read state for INBOX
                            window.currentConversationReadState = {
                                isRead: false,
                                conversationId: window.currentConversationId,
                                pageId: channelId,
                                lastMarkedAt: null,
                                chatType: 'message'
                            };
                            updateReadBadge(false);
                            updateMarkButton(false);

                            // Populate conversation selector if multiple INBOX conversations
                            if (inboxConversations.length > 1) {
                                window.populateConversationSelector(inboxConversations, window.currentConversationId);
                            } else {
                                window.hideConversationSelector();
                            }

                            // Now fetch messages for this INBOX conversation
                            // Pass preloaded pageAccessToken to skip redundant token fetch
                            console.log('[CHAT-MODAL] ğŸ“¥ Fetching messages for INBOX conversation (using preloaded token)...');

                            const messagesResponse = await window.pancakeDataManager.fetchMessagesForConversation(
                                channelId,
                                window.currentConversationId,
                                null,
                                window.currentCustomerUUID,
                                preloadedPageAccessToken  // Use preloaded token from parallel fetch
                            );

                            window.allChatMessages = messagesResponse.messages || [];
                            currentChatCursor = messagesResponse.after;

                            console.log('[CHAT-MODAL] âœ… Loaded', window.allChatMessages.length, 'messages');

                            // Render messages
                            renderChatMessages(window.allChatMessages, true);

                        } else {
                            console.warn('[CHAT-MODAL] âš ï¸ No INBOX conversation found');
                            modalBody.innerHTML = `
                                <div class="chat-error">
                                    <i class="fas fa-info-circle"></i>
                                    <p>KhÃ´ng tÃ¬m tháº¥y tin nháº¯n cho khÃ¡ch hÃ ng nÃ y</p>
                                </div>`;
                        }

                        // Save COMMENT conversation ID for quick switching
                        if (commentConversations.length > 0) {
                            // Filter by post_id if available
                            let targetCommentConv;
                            if (facebookPostId) {
                                targetCommentConv = commentConversations.find(conv => conv.post_id === facebookPostId);
                            }
                            if (!targetCommentConv) {
                                targetCommentConv = commentConversations[0];
                            }

                            window.currentCommentConversationId = targetCommentConv.id;
                            console.log('[CHAT-MODAL] âœ… Found COMMENT conversationId:', window.currentCommentConversationId);
                        }

                    } else {
                        console.warn('[CHAT-MODAL] âš ï¸ No conversations found for fb_id:', facebookPsid);
                        modalBody.innerHTML = `
                            <div class="chat-error">
                                <i class="fas fa-info-circle"></i>
                                <p>KhÃ´ng tÃ¬m tháº¥y cuá»™c há»™i thoáº¡i</p>
                            </div>`;
                    }
                } catch (fetchError) {
                    console.error('[CHAT-MODAL] âŒ Error fetching INBOX conversations:', fetchError);
                    modalBody.innerHTML = `
                        <div class="chat-error">
                            <i class="fas fa-exclamation-triangle"></i>
                            <p>Lá»—i khi táº£i tin nháº¯n</p>
                            <p style="font-size: 12px; color: #6b7280;">${fetchError.message}</p>
                        </div>`;
                }
            } else {
                console.warn('[CHAT-MODAL] âš ï¸ Missing pancakeDataManager or required data');
                modalBody.innerHTML = `
                    <div class="chat-error">
                        <i class="fas fa-info-circle"></i>
                        <p>Thiáº¿u thÃ´ng tin Ä‘á»ƒ táº£i tin nháº¯n</p>
                    </div>`;
            }

            // Setup infinite scroll and realtime
            setupChatInfiniteScroll();
            setupNewMessageIndicatorListener();
            setupRealtimeMessages();
        }

        /* LEGACY CODE REMOVED
        // Initialize Chat Product State
        initChatProductSearch();
     
        // Firebase Sync Logic - Shared products across all orders
        if (database) {
            currentChatProductsRef = database.ref('order_products/shared');
            currentChatProductsRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    console.log('[CHAT-FIREBASE] Loaded shared products from Firebase:', data);
                    currentChatOrderDetails = data;
                    renderChatProductsPanel();
                } else {
                    console.log('[CHAT-FIREBASE] No shared data in Firebase, initializing from order details');
                    // If no data in Firebase, initialize from order and save to shared
                    currentChatOrderDetails = order.Details ? JSON.parse(JSON.stringify(order.Details)) : [];
                    renderChatProductsPanel();
                    // Save initial state to shared Firebase path
                    saveChatProductsToFirebase('shared', currentChatOrderDetails);
                }
            });
        } else {
            // Fallback if no firebase
            currentChatOrderDetails = order.Details ? JSON.parse(JSON.stringify(order.Details)) : [];
            renderChatProductsPanel();
        }
        */



    } catch (error) {
        console.error(`[CHAT] Error loading ${type}:`, error);
        const errorText = type === 'comment' ? 'Lá»—i khi táº£i bÃ¬nh luáº­n' : 'Lá»—i khi táº£i tin nháº¯n';
        modalBody.innerHTML = `
            <div class="chat-error">
                <i class="fas fa-exclamation-triangle"></i>
                <p>${errorText}</p>
                <p style="font-size: 12px; color: #9ca3af;">${error.message}</p>
            </div>`;
    }
}

window.closeChatModal = async function () {
    // Cleanup temporary held products (isDraft: false) - return them to dropped
    // Only persisted held products (isDraft: true, user clicked "LÆ°u giá»¯") will remain
    if (typeof window.cleanupHeldProducts === 'function') {
        await window.cleanupHeldProducts();
    }

    // Cleanup held products listener
    if (typeof window.cleanupHeldProductsListener === 'function') {
        window.cleanupHeldProductsListener();
    }

    // Cleanup realtime messages (stop polling, remove event listeners)
    cleanupRealtimeMessages();

    document.getElementById('chatModal').classList.remove('show');

    // Restore body scroll when modal is closed
    document.body.style.overflow = '';

    // Clean up scroll listener
    const modalBody = document.getElementById('chatModalBody');
    if (modalBody) {
        modalBody.removeEventListener('scroll', handleChatScroll);
    }

    // Reset pagination state
    window.currentChatChannelId = null;
    window.currentChatPSID = null;
    window.currentRealFacebookPSID = null;
    currentChatType = null;
    currentChatCursor = null;
    window.allChatMessages = [];
    window.allChatComments = [];
    window.chatMessagesById = {}; // Clear messages map for reply functionality
    isLoadingMoreMessages = false;
    currentOrder = null;
    currentChatOrderId = null;
    currentChatOrderDetails = [];
    window.currentChatOrderData = null;
    window.currentConversationId = null;
    currentParentCommentId = null;
    currentPostId = null;

    // Reset conversation selector
    window.hideConversationSelector();

    // Reset image upload state
    currentPastedImage = null;
    window.currentPastedImage = null;
    window.uploadedImagesData = [];
    window.isUploadingImages = false;

    // Reset purchase comment highlight state
    window.purchaseCommentId = null;
    window.purchaseFacebookPostId = null;
    window.purchaseFacebookASUserId = null;

    // Reset message reply type and hide toggle
    messageReplyType = 'reply_inbox';
    const msgReplyToggle = document.getElementById('messageReplyTypeToggle');
    if (msgReplyToggle) {
        msgReplyToggle.style.display = 'none';
    }

    // Hide reply preview
    const replyPreviewContainer = document.getElementById('chatReplyPreviewContainer');
    if (replyPreviewContainer) {
        replyPreviewContainer.style.display = 'none';
    }

    // Detach Firebase listener
    if (currentChatProductsRef) {
        currentChatProductsRef.off();
        currentChatProductsRef = null;
    }
}

// Close chat modal when clicking outside (on backdrop)
document.addEventListener('click', function (event) {
    const modal = document.getElementById('chatModal');
    if (!modal || !modal.classList.contains('show')) return;

    const modalContent = modal.querySelector('.chat-modal-content');
    // If click is on the backdrop (modal itself, not its content), close the modal
    if (event.target === modal && modalContent && !modalContent.contains(event.target)) {
        closeChatModal();
    }
});

/**
 * Upload image with Firebase cache check
 * Returns uploaded image data or error
 * @param {Blob} imageBlob - Image blob to upload
 * @param {string|number} productId - Product ID (optional, for cache)
 * @param {string} productName - Product name (optional, for cache)
 * @param {string} channelId - Channel ID for Pancake upload
 * @param {string} productCode - Product code (optional, for cache key)
 * @returns {Promise<{success: boolean, data?: object, error?: string}>}
 */
window.uploadImageWithCache = async function uploadImageWithCache(imageBlob, productId, productName, channelId, productCode = null) {
    try {
        let contentUrl = null;
        let contentId = null;
        let dimensions = null;

        // Check Firebase cache if productId exists
        if ((productId || productName || productCode) && window.firebaseImageCache) {
            console.log('[UPLOAD-CACHE] Checking Firebase cache for product:', productId, productName, 'Code:', productCode);

            const cached = await window.firebaseImageCache.get(productId, productName, productCode);

            if (cached && (cached.content_id || cached.content_url)) {
                // âœ… CACHE HIT - prioritize content_id over content_url
                console.log('[UPLOAD-CACHE] âœ… Cache HIT! Reusing content_id:', cached.content_id, 'content_url:', cached.content_url);
                contentUrl = cached.content_url || null;
                contentId = cached.content_id || null;
                dimensions = await getImageDimensions(imageBlob);

                return {
                    success: true,
                    data: {
                        content_url: contentUrl,
                        content_id: contentId,
                        width: dimensions.width,
                        height: dimensions.height,
                        cached: true
                    }
                };
            }
        }

        // Cache miss or no productId - Upload to Pancake
        console.log('[UPLOAD-CACHE] Preparing upload to Pancake...');

        // â­ NEW: Auto-compress if image is too large (Pancake limit: 500KB)
        const MAX_SIZE = 500 * 1024; // 500KB
        let blobToUpload = imageBlob;
        let compressionInfo = null;

        if (imageBlob.size > MAX_SIZE) {
            console.log(`[UPLOAD-CACHE] Image too large (${(imageBlob.size / 1024).toFixed(2)} KB > 500 KB), compressing...`);

            if (window.compressImage) {
                try {
                    const compressed = await window.compressImage(imageBlob, MAX_SIZE, 1920, 0.85);
                    blobToUpload = compressed.blob;
                    compressionInfo = compressed;
                    console.log(`[UPLOAD-CACHE] âœ… Compressed: ${(compressed.originalSize / 1024).toFixed(2)} KB â†’ ${(compressed.compressedSize / 1024).toFixed(2)} KB (${compressed.compressionRatio} reduction)`);
                } catch (compressError) {
                    console.warn('[UPLOAD-CACHE] Compression failed, uploading original:', compressError);
                    // Continue with original blob
                }
            } else {
                console.warn('[UPLOAD-CACHE] compressImage function not available, uploading original (may fail)');
            }
        } else {
            console.log(`[UPLOAD-CACHE] Image size OK: ${(imageBlob.size / 1024).toFixed(2)} KB`);
        }

        // Upload to Pancake
        const [uploadResult, dims] = await Promise.all([
            window.pancakeDataManager.uploadImage(channelId, blobToUpload),
            compressionInfo ? Promise.resolve({ width: compressionInfo.width, height: compressionInfo.height }) : getImageDimensions(imageBlob)
        ]);

        // â­ NEW: Check for error response from Pancake
        if (uploadResult.success === false || (!uploadResult.content_url && !uploadResult.id)) {
            const errorMsg = uploadResult.message || 'Upload failed';
            console.error('[UPLOAD-CACHE] âŒ Pancake upload error:', errorMsg);
            throw new Error(errorMsg);
        }

        contentUrl = uploadResult.content_url;
        contentId = uploadResult.id;
        dimensions = dims;

        console.log('[UPLOAD-CACHE] âœ… Upload success, content_id:', contentId);

        // Save to Firebase cache
        if ((productId || productName || productCode) && window.firebaseImageCache) {
            console.log('[UPLOAD-CACHE] Saving to Firebase cache...');
            await window.firebaseImageCache.set(productId, productName, contentUrl, contentId, productCode, dimensions?.width, dimensions?.height)
                .catch(err => {
                    console.warn('[UPLOAD-CACHE] Cache save failed (non-critical):', err);
                });
        }

        return {
            success: true,
            data: {
                content_url: contentUrl,
                content_id: contentId,
                width: dimensions.width,
                height: dimensions.height,
                cached: false
            }
        };

    } catch (error) {
        console.error('[UPLOAD-CACHE] Upload failed:', error);
        return {
            success: false,
            error: error.message || 'Upload failed'
        };
    }
}

/**
 * Handle paste event on chat input
 * NOW: Upload immediately after paste
 */
function handleChatInputPaste(event) {
    const items = (event.clipboardData || event.originalEvent.clipboardData).items;
    let hasImage = false;

    for (let index in items) {
        const item = items[index];
        if (item.kind === 'file' && item.type.startsWith('image/')) {
            hasImage = true;
            event.preventDefault(); // Prevent default paste to avoid clearing text input

            const blob = item.getAsFile();
            currentPastedImage = blob;

            // Keep input enabled so user can press Enter to send or type additional text
            const chatInput = document.getElementById('chatReplyInput');
            if (chatInput) {
                chatInput.placeholder = 'Báº¥m Enter Ä‘á»ƒ gá»­i áº£nh, hoáº·c nháº­p thÃªm tin nháº¯n...';
            }

            // Show preview with loading state
            const reader = new FileReader();
            reader.onload = async function (e) {
                try {
                    const previewContainer = document.getElementById('chatImagePreviewContainer');
                    if (!previewContainer) return;

                    // Show preview with loading overlay
                    previewContainer.style.display = 'flex';
                    previewContainer.style.alignItems = 'center';
                    previewContainer.style.justifyContent = 'space-between';

                    previewContainer.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; position: relative;">
                        <img id="pastedImagePreview" src="${e.target.result}" style="height: 50px; border-radius: 4px; border: 1px solid #ddd; opacity: 0.5;">
                        <div id="uploadOverlay" style="position: absolute; left: 0; top: 0; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.8);">
                            <i class="fas fa-spinner fa-spin" style="color: #3b82f6;"></i>
                        </div>
                        <span id="uploadStatus" style="font-size: 12px; color: #3b82f6;">Äang táº£i lÃªn Pancake...</span>
                    </div>
                    <button onclick="clearPastedImage()" style="background: none; border: none; color: #ef4444; cursor: pointer; font-size: 16px;">
                        <i class="fas fa-times"></i>
                    </button>
                `;

                    // Upload immediately
                    const productId = null; // Paste doesn't have productId
                    const productName = null;
                    const channelId = window.currentChatChannelId;

                    if (!channelId) {
                        console.warn('[PASTE] No channelId available, skipping upload');
                        // Initialize array if needed
                        if (!window.uploadedImagesData) {
                            window.uploadedImagesData = [];
                        }
                        window.uploadedImagesData.push({
                            blob: blob,
                            productId: null,
                            productName: null,
                            error: 'Thiáº¿u thÃ´ng tin channel',
                            uploadFailed: true
                        });
                        updateMultipleImagesPreview();
                        return;
                    }

                    const result = await uploadImageWithCache(blob, productId, productName, channelId);

                    // Initialize array if needed
                    if (!window.uploadedImagesData) {
                        window.uploadedImagesData = [];
                    }

                    if (result.success) {
                        // Upload success - ADD to array (not replace)
                        window.uploadedImagesData.push({
                            ...result.data,
                            blob: blob,
                            productId: productId,
                            productName: productName
                        });
                        updateMultipleImagesPreview(); // NEW: Update preview with all images
                    } else {
                        // Upload failed - still show in preview with error
                        window.uploadedImagesData.push({
                            blob: blob,
                            productId: productId,
                            productName: productName,
                            error: result.error,
                            uploadFailed: true
                        });
                        updateMultipleImagesPreview();
                    }
                } catch (error) {
                    console.error('[PASTE] Error handling paste:', error);
                    // Initialize array if needed
                    if (!window.uploadedImagesData) {
                        window.uploadedImagesData = [];
                    }
                    // Add failed image to array
                    window.uploadedImagesData.push({
                        blob: blob,
                        productId: null,
                        productName: null,
                        error: error.message || 'Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh',
                        uploadFailed: true
                    });
                    updateMultipleImagesPreview();
                }
            };
            reader.readAsDataURL(blob);
            break; // Only handle first image
        }
    }
}

/**
 * Handle file input change event (when user selects files via attachment button)
 * Supports multiple files selection
 */
function handleFileInputChange(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    const channelId = window.currentChatChannelId;
    if (!channelId) {
        if (window.notificationManager) {
            window.notificationManager.show('Vui lÃ²ng má»Ÿ chat trÆ°á»›c khi gá»­i file', 'warning');
        }
        return;
    }

    // Initialize array if needed
    if (!window.uploadedImagesData) {
        window.uploadedImagesData = [];
    }

    // Process each selected file
    Array.from(files).forEach(async (file) => {
        // Only process image files for now
        if (!file.type.startsWith('image/')) {
            console.log('[FILE-INPUT] Skipping non-image file:', file.name, file.type);
            if (window.notificationManager) {
                window.notificationManager.show(`Bá» qua file khÃ´ng pháº£i áº£nh: ${file.name}`, 'warning');
            }
            return;
        }

        console.log('[FILE-INPUT] Processing image:', file.name, file.size, file.type);

        // Add to preview first (showing as uploading)
        const tempIndex = window.uploadedImagesData.length;
        window.uploadedImagesData.push({
            blob: file,
            productId: null,
            productName: file.name,
            uploading: true
        });
        updateMultipleImagesPreview();

        try {
            // Upload image
            const result = await window.uploadImageWithCache(file, null, file.name, channelId, null);

            if (result.success) {
                // Update with success data
                window.uploadedImagesData[tempIndex] = {
                    ...result.data,
                    blob: file,
                    productId: null,
                    productName: file.name
                };
                console.log('[FILE-INPUT] âœ“ Upload success:', file.name);
            } else {
                // Update with error
                window.uploadedImagesData[tempIndex] = {
                    blob: file,
                    productId: null,
                    productName: file.name,
                    error: result.error || 'Upload failed',
                    uploadFailed: true
                };
                console.error('[FILE-INPUT] âœ— Upload failed:', file.name, result.error);
            }
        } catch (error) {
            console.error('[FILE-INPUT] Error uploading:', file.name, error);
            window.uploadedImagesData[tempIndex] = {
                blob: file,
                productId: null,
                productName: file.name,
                error: error.message || 'Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh',
                uploadFailed: true
            };
        }

        updateMultipleImagesPreview();
    });

    // Reset file input so same file can be selected again
    event.target.value = '';

    // Focus on chat input
    const chatInput = document.getElementById('chatReplyInput');
    if (chatInput) {
        chatInput.focus();
    }
}

/**
 * NEW: Update preview UI for multiple images (horizontal scroll)
 */
window.updateMultipleImagesPreview = function updateMultipleImagesPreview() {
    const previewContainer = document.getElementById('chatImagePreviewContainer');
    if (!previewContainer) return;

    if (!window.uploadedImagesData || window.uploadedImagesData.length === 0) {
        // No images - hide preview
        previewContainer.innerHTML = '';
        previewContainer.style.display = 'none';

        // Re-enable text input
        const chatInput = document.getElementById('chatReplyInput');
        if (chatInput) {
            chatInput.disabled = false;
            chatInput.style.opacity = '1';
            chatInput.style.cursor = 'text';
            chatInput.placeholder = 'Nháº­p tin nháº¯n tráº£ lá»i... (Shift+Enter Ä‘á»ƒ xuá»‘ng dÃ²ng)';
        }
        return;
    }

    // Show preview with horizontal scroll
    previewContainer.style.display = 'block';
    previewContainer.style.overflowX = 'auto';
    previewContainer.style.whiteSpace = 'nowrap';
    previewContainer.style.padding = '8px';
    previewContainer.style.background = '#f9fafb';
    previewContainer.style.borderRadius = '4px';

    let html = '<div style="display: flex; gap: 8px; align-items: flex-start;">';

    window.uploadedImagesData.forEach((imageData, index) => {
        const imageUrl = imageData.blob ? URL.createObjectURL(imageData.blob) : '';
        // Check content_id (from upload) instead of content_url (not returned by API)
        const hasContentId = !!(imageData.content_id || imageData.id);
        const isUploading = !hasContentId && !imageData.uploadFailed;
        const isSuccess = hasContentId && !imageData.uploadFailed;
        const isFailed = imageData.uploadFailed;
        const isCached = imageData.cached;

        html += `
            <div style="display: inline-flex; flex-direction: column; align-items: center; gap: 4px; position: relative;">
                <!-- Image preview -->
                <div style="position: relative; width: 80px; height: 80px;">
                    <img src="${imageUrl}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 4px; border: 2px solid ${isFailed ? '#ef4444' : isSuccess ? '#10b981' : '#3b82f6'}; opacity: ${isUploading ? '0.5' : '1'};">

                    ${isUploading ? `
                        <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.8);">
                            <i class="fas fa-spinner fa-spin" style="color: #3b82f6;"></i>
                        </div>
                    ` : ''}

                    <!-- Delete button (top-right) -->
                    <button onclick="removeImageAtIndex(${index})" style="position: absolute; top: -6px; right: -6px; width: 20px; height: 20px; border-radius: 50%; background: #ef4444; color: white; border: 2px solid white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; padding: 0;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Status text -->
                <span style="font-size: 10px; max-width: 80px; text-align: center; white-space: normal; line-height: 1.2;">
                    ${isUploading ? '<span style="color: #3b82f6;">Äang táº£i...</span>' :
                isFailed ? `<span style="color: #ef4444;">${imageData.error || 'Lá»—i'}</span><br><button onclick="retryUploadAtIndex(${index})" style="margin-top: 2px; padding: 2px 6px; font-size: 9px; background: #3b82f6; color: white; border: none; border-radius: 3px; cursor: pointer;">Retry</button>` :
                    isCached ? '<span style="color: #10b981;"><i class="fas fa-recycle"></i> ÄÃ£ cÃ³ sáºµn</span>' :
                        `<span style="color: #10b981;"><i class="fas fa-check"></i> ${Math.round((imageData.blob?.size || 0) / 1024)} KB</span>`}
                </span>
            </div>
        `;
    });

    html += `
        <!-- Clear all button -->
        <button onclick="clearAllImages()" style="margin-left: 8px; padding: 8px 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; align-self: center; white-space: normal; font-size: 12px;">
            <i class="fas fa-trash"></i><br>XÃ³a táº¥t cáº£
        </button>
    </div>`;

    previewContainer.innerHTML = html;

    // Keep input enabled so user can press Enter to send or type additional text
    const chatInput = document.getElementById('chatReplyInput');
    if (chatInput) {
        chatInput.disabled = false;
        chatInput.style.opacity = '1';
        chatInput.style.cursor = 'text';
        chatInput.placeholder = 'Báº¥m Enter Ä‘á»ƒ gá»­i áº£nh, hoáº·c nháº­p thÃªm tin nháº¯n...';
    }

    // Update send button state based on upload status
    updateSendButtonState();
};

/**
 * Update send button state - disable if any image is still uploading
 */
function updateSendButtonState() {
    const sendBtn = document.getElementById('chatSendBtn');
    if (!sendBtn) return;

    // Check if any image is still uploading (check content_id instead of content_url)
    const hasUploadingImages = window.uploadedImagesData && window.uploadedImagesData.some(img =>
        !(img.content_id || img.id) && !img.uploadFailed
    );

    if (hasUploadingImages) {
        // Disable send button
        sendBtn.disabled = true;
        sendBtn.style.opacity = '0.5';
        sendBtn.style.cursor = 'not-allowed';
        sendBtn.title = 'Äang táº£i áº£nh... Vui lÃ²ng Ä‘á»£i';
        window.isUploadingImages = true;
    } else {
        // Enable send button
        sendBtn.disabled = false;
        sendBtn.style.opacity = '1';
        sendBtn.style.cursor = 'pointer';
        sendBtn.title = 'Gá»­i tin nháº¯n';
        window.isUploadingImages = false;
    }
}

/**
 * Update upload preview UI based on upload result (DEPRECATED - use updateMultipleImagesPreview)
 */
window.updateUploadPreviewUI = function updateUploadPreviewUI(success, message, cached) {
    const preview = document.getElementById('pastedImagePreview');
    const overlay = document.getElementById('uploadOverlay');
    const status = document.getElementById('uploadStatus');

    if (!preview || !overlay || !status) return;

    if (success) {
        // Success - show normal preview
        preview.style.opacity = '1';
        overlay.style.display = 'none';

        if (cached) {
            status.innerHTML = '<i class="fas fa-recycle" style="color: #10b981; margin-right: 4px;"></i>áº¢nh Ä‘Ã£ cÃ³ sáºµn';
            status.style.color = '#10b981';
        } else {
            status.innerHTML = '<i class="fas fa-check-circle" style="color: #10b981; margin-right: 4px;"></i>' + message;
            status.style.color = '#10b981';
        }
    } else {
        // Failed - show error with retry option
        preview.style.opacity = '1';
        overlay.style.display = 'none';
        status.innerHTML = `<i class="fas fa-exclamation-triangle" style="color: #ef4444; margin-right: 4px;"></i>${message} <button onclick="retryUpload()" style="margin-left: 6px; padding: 2px 8px; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">Retry</button>`;
        status.style.color = '#ef4444';
    }
}

/**
 * NEW: Remove a single image at index
 */
window.removeImageAtIndex = function (index) {
    if (!window.uploadedImagesData || index < 0 || index >= window.uploadedImagesData.length) return;

    // Revoke blob URL if exists
    const imageData = window.uploadedImagesData[index];
    if (imageData.blob) {
        URL.revokeObjectURL(URL.createObjectURL(imageData.blob));
    }

    // Remove from array
    window.uploadedImagesData.splice(index, 1);

    // Update preview
    updateMultipleImagesPreview();

    console.log('[REMOVE-IMAGE] Removed image at index', index, '- remaining:', window.uploadedImagesData.length);
};

/**
 * NEW: Clear all images
 */
window.clearAllImages = function () {
    // Revoke all blob URLs
    if (window.uploadedImagesData) {
        window.uploadedImagesData.forEach(imageData => {
            if (imageData.blob) {
                URL.revokeObjectURL(URL.createObjectURL(imageData.blob));
            }
        });
    }

    // Clear array
    window.uploadedImagesData = [];

    // Update preview (will hide it)
    updateMultipleImagesPreview();

    console.log('[CLEAR-ALL-IMAGES] Cleared all images');
};

/**
 * NEW: Retry upload at specific index (for failed uploads)
 */
window.retryUploadAtIndex = async function (index) {
    if (!window.uploadedImagesData || index < 0 || index >= window.uploadedImagesData.length) return;

    const imageData = window.uploadedImagesData[index];
    if (!imageData.blob) return;

    console.log('[RETRY-UPLOAD] Retrying upload at index', index);

    // Mark as uploading
    window.uploadedImagesData[index] = {
        blob: imageData.blob,
        productId: imageData.productId,
        productName: imageData.productName
    };
    updateMultipleImagesPreview();

    // Retry upload
    const channelId = window.currentChatChannelId;
    if (!channelId) {
        window.uploadedImagesData[index].uploadFailed = true;
        window.uploadedImagesData[index].error = 'KhÃ´ng thá»ƒ upload: Thiáº¿u thÃ´ng tin';
        updateMultipleImagesPreview();
        return;
    }

    const result = await window.uploadImageWithCache(
        imageData.blob,
        imageData.productId,
        imageData.productName,
        channelId,
        imageData.productCode
    );

    if (result.success) {
        // Update with success data
        window.uploadedImagesData[index] = {
            ...result.data,
            blob: imageData.blob,
            productId: imageData.productId,
            productName: imageData.productName
        };
    } else {
        // Update with error
        window.uploadedImagesData[index] = {
            blob: imageData.blob,
            productId: imageData.productId,
            productName: imageData.productName,
            error: result.error,
            uploadFailed: true
        };
    }

    updateMultipleImagesPreview();
};

/**
 * Retry upload when failed (DEPRECATED - use retryUploadAtIndex)
 */
window.retryUpload = async function () {
    if (!currentPastedImage) return;

    const status = document.getElementById('uploadStatus');
    const overlay = document.getElementById('uploadOverlay');
    const preview = document.getElementById('pastedImagePreview');

    if (status && overlay && preview) {
        status.textContent = 'Äang thá»­ láº¡i...';
        status.style.color = '#3b82f6';
        overlay.style.display = 'flex';
        preview.style.opacity = '0.5';
    }

    const productId = window.currentPastedImageProductId || null;
    const productName = window.currentPastedImageProductName || null;
    const channelId = window.currentChatChannelId;

    const result = await uploadImageWithCache(currentPastedImage, productId, productName, channelId);

    if (result.success) {
        uploadedImageData = result.data;
        window.uploadedImageData = result.data;
        updateUploadPreviewUI(true, `${Math.round(currentPastedImage.size / 1024)} KB`, result.data.cached);
    } else {
        uploadedImageData = null;
        window.uploadedImageData = null;
        updateUploadPreviewUI(false, result.error, false);
    }
};

/**
 * Clear pasted image (UI only - keeps uploaded image on Pancake/Firebase)
 */
window.clearPastedImage = function () {
    // NEW: Use clearAllImages for multiple images
    clearAllImages();

    // Legacy cleanup
    currentPastedImage = null;
    window.currentPastedImage = null;
    window.currentPastedImageProductId = null;
    window.currentPastedImageProductName = null;

    console.log('[CLEAR-IMAGE] Cleared all images (UI only - images still on Pancake/Firebase)');
}

/**
 * Send product image to chat input
 * Checks Firebase cache first, if found uses cached content_id
 * Otherwise fetches image from URL, uploads to Pancake, and caches result
 * Called from Dropped Products tab and Orders tab (right-click on product image)
 * @param {string} imageUrl - URL of the product image
 * @param {string} productName - Name of the product
 * @param {number|string} productId - Product ID (optional, for Firebase cache)
 * @param {string} productCode - Product code (optional, for Firebase cache key)
 */
window.sendImageToChat = async function (imageUrl, productName, productId = null, productCode = null) {
    // Check if chat modal is open
    const chatModal = document.getElementById('chatModal');
    if (!chatModal || !chatModal.classList.contains('show')) {
        if (window.notificationManager) {
            window.notificationManager.show('Vui lÃ²ng má»Ÿ chat trÆ°á»›c khi gá»­i áº£nh', 'warning');
        } else {
            alert('Vui lÃ²ng má»Ÿ chat trÆ°á»›c khi gá»­i áº£nh');
        }
        return;
    }

    // Check if we have channel ID for upload
    const channelId = window.currentChatChannelId;
    if (!channelId) {
        if (window.notificationManager) {
            window.notificationManager.show('KhÃ´ng cÃ³ thÃ´ng tin channel Ä‘á»ƒ upload áº£nh', 'error');
        }
        return;
    }

    // Initialize uploaded images array if needed
    if (!window.uploadedImagesData) {
        window.uploadedImagesData = [];
    }

    try {
        console.log('[SEND-IMAGE-TO-CHAT] Product:', productId, productName, 'Code:', productCode);
        console.log('[SEND-IMAGE-TO-CHAT] Image URL:', imageUrl);

        // Check Firebase cache first (using productCode as primary cache key)
        if (window.firebaseImageCache && (productId || productName || productCode)) {
            console.log('[SEND-IMAGE-TO-CHAT] ğŸ” Checking Firebase cache...');

            // Pass productId, productName, and productCode - cache will use productCode as primary key
            const cached = await window.firebaseImageCache.get(productId, productName, productCode);

            if (cached && cached.content_id) {
                // âœ… CACHE HIT - Use cached content_id directly (no upload needed!)
                console.log('[SEND-IMAGE-TO-CHAT] âœ… Cache HIT! Using cached content_id:', cached.content_id);

                if (window.notificationManager) {
                    window.notificationManager.show('âœ“ ÄÃ£ dÃ¹ng áº£nh Ä‘Ã£ lÆ°u (khÃ´ng cáº§n upload)', 'success');
                }

                // Fetch blob from imageUrl for preview display
                const WORKER_URL = API_CONFIG?.WORKER_URL || 'https://chatomni-proxy.nhijudyshop.workers.dev';
                const proxyUrl = `${WORKER_URL}/api/image-proxy?url=${encodeURIComponent(imageUrl)}`;

                let blob = null;
                try {
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                        blob = await response.blob();
                    }
                } catch (err) {
                    console.warn('[SEND-IMAGE-TO-CHAT] Could not fetch blob for preview:', err);
                }

                // Add to preview with cached data
                window.uploadedImagesData.push({
                    content_url: cached.content_url || null,
                    content_id: cached.content_id,
                    width: cached.width || 0,
                    height: cached.height || 0,
                    blob: blob,  // Include blob for preview
                    productId: productId,
                    productName: productName,
                    productCode: productCode,
                    cached: true
                });
                window.updateMultipleImagesPreview();

                // Focus on chat input
                const chatInput = document.getElementById('chatReplyInput');
                if (chatInput) {
                    chatInput.focus();
                }

                return; // Done - no need to upload
            }

            console.log('[SEND-IMAGE-TO-CHAT] âŒ Cache miss, proceeding to upload...');
        }

        // Show loading notification
        if (window.notificationManager) {
            window.notificationManager.show('Äang táº£i áº£nh...', 'info');
        }

        // Use Cloudflare Worker image proxy to bypass CORS
        const WORKER_URL = API_CONFIG?.WORKER_URL || 'https://chatomni-proxy.nhijudyshop.workers.dev';
        const proxyUrl = `${WORKER_URL}/api/image-proxy?url=${encodeURIComponent(imageUrl)}`;

        console.log('[SEND-IMAGE-TO-CHAT] Using proxy URL:', proxyUrl);

        // Fetch image through proxy and convert to blob
        const response = await fetch(proxyUrl);
        if (!response.ok) {
            throw new Error('KhÃ´ng thá»ƒ táº£i áº£nh tá»« URL');
        }

        const blob = await response.blob();

        // Add to preview first (showing as uploading)
        window.uploadedImagesData.push({
            blob: blob,
            productId: productId,
            productName: productName,
            productCode: productCode,
            uploading: true
        });
        window.updateMultipleImagesPreview();

        // Upload to Pancake
        console.log('[SEND-IMAGE-TO-CHAT] ğŸ“¤ Uploading to Pancake...');

        const uploadResult = await window.pancakeDataManager.uploadImage(channelId, blob);

        // Update the last added item with upload result
        const lastIndex = window.uploadedImagesData.length - 1;

        if (uploadResult && uploadResult.id) {
            const contentId = uploadResult.id;
            const contentUrl = uploadResult.content_url;

            // Get dimensions for cache storage
            const dimensions = await getImageDimensions(blob);

            window.uploadedImagesData[lastIndex] = {
                content_url: contentUrl,
                content_id: contentId,
                blob: blob,
                width: dimensions.width,
                height: dimensions.height,
                productId: productId,
                productName: productName,
                productCode: productCode
            };

            console.log('[SEND-IMAGE-TO-CHAT] âœ“ Upload success! content_id:', contentId);

            // Save to Firebase cache (using productCode as primary cache key)
            if (window.firebaseImageCache && (productId || productName || productCode)) {
                console.log('[SEND-IMAGE-TO-CHAT] ğŸ’¾ Saving to Firebase cache...');
                await window.firebaseImageCache.set(productId, productName, contentUrl, contentId, productCode, dimensions.width, dimensions.height)
                    .catch(err => {
                        console.warn('[SEND-IMAGE-TO-CHAT] Cache save failed (non-critical):', err);
                    });
            }

            if (window.notificationManager) {
                window.notificationManager.show('âœ“ ÄÃ£ thÃªm áº£nh vÃ o tin nháº¯n', 'success');
            }
        } else {
            window.uploadedImagesData[lastIndex] = {
                blob: blob,
                productId: productId,
                productName: productName,
                productCode: productCode,
                error: 'Upload failed - no content_id returned',
                uploadFailed: true
            };
            console.error('[SEND-IMAGE-TO-CHAT] âœ— Upload failed: no content_id');
            if (window.notificationManager) {
                window.notificationManager.show('Lá»—i upload áº£nh', 'error');
            }
        }

        // Update preview
        window.updateMultipleImagesPreview();

        // Focus on chat input
        const chatInput = document.getElementById('chatReplyInput');
        if (chatInput) {
            chatInput.focus();
        }

    } catch (error) {
        console.error('[SEND-IMAGE-TO-CHAT] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.show('Lá»—i khi gá»­i áº£nh: ' + error.message, 'error');
        }
    }
};

/**
 * Send product name/info to chat input
 * Inserts product name into the chat message textarea
 * Called from Dropped Products tab (click on send button)
 * @param {number} productId - Product ID
 * @param {string} productName - Name of the product
 */
window.sendProductToChat = function (productId, productName) {
    // Check if chat modal is open
    const chatModal = document.getElementById('chatModal');
    if (!chatModal || !chatModal.classList.contains('show')) {
        if (window.notificationManager) {
            window.notificationManager.show('Vui lÃ²ng má»Ÿ chat trÆ°á»›c khi gá»­i tÃªn sáº£n pháº©m', 'warning');
        } else {
            alert('Vui lÃ²ng má»Ÿ chat trÆ°á»›c khi gá»­i tÃªn sáº£n pháº©m');
        }
        return;
    }

    const chatInput = document.getElementById('chatReplyInput');
    if (!chatInput) {
        console.error('[SEND-PRODUCT-TO-CHAT] Chat input not found');
        return;
    }

    // Insert product name at cursor position or append
    const currentValue = chatInput.value;
    const cursorPos = chatInput.selectionStart;

    if (currentValue) {
        // Append with newline if there's existing text
        const before = currentValue.substring(0, cursorPos);
        const after = currentValue.substring(cursorPos);
        const separator = before.endsWith('\n') || before === '' ? '' : '\n';
        chatInput.value = before + separator + productName + after;
    } else {
        chatInput.value = productName;
    }

    // Focus and trigger resize
    chatInput.focus();
    chatInput.dispatchEvent(new Event('input', { bubbles: true }));

    console.log('[SEND-PRODUCT-TO-CHAT] âœ“ Added product name:', productName);

    if (window.notificationManager) {
        window.notificationManager.show('âœ“ ÄÃ£ thÃªm tÃªn sáº£n pháº©m vÃ o tin nháº¯n', 'success');
    }
};

// Message Queue Management
window.chatMessageQueue = window.chatMessageQueue || [];
window.chatIsProcessingQueue = false;

// Reply Message State
window.currentReplyingToMessage = null; // Stores the message being replied to

/**
 * Auto-resize textarea based on content
 */
function autoResizeTextarea(textarea) {
    // Reset height to auto to get the correct scrollHeight
    textarea.style.height = 'auto';
    // Set height based on scrollHeight, but don't exceed max-height
    const maxHeight = 120; // matches max-height in CSS
    const newHeight = Math.min(textarea.scrollHeight, maxHeight);
    textarea.style.height = newHeight + 'px';
}

/**
 * Handle Enter key in chat input - prevent double submission, allow Shift+Enter for newlines
 */
function handleChatInputKeyDown(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        // Skip if autocomplete is active (let quick-reply-manager handle the Enter)
        if (window.quickReplyManager && window.quickReplyManager.autocompleteActive) {
            console.log('[CHAT] Enter pressed but autocomplete is active, skipping sendReplyComment');
            return; // Don't prevent default - let quick-reply-manager handle it
        }

        event.preventDefault(); // Prevent default form submission and double trigger
        event.stopPropagation(); // Stop event bubbling

        // Call sendReplyComment only once
        window.sendReplyComment();
    }
    // Shift+Enter will use default behavior (insert newline)
    // After newline is inserted, resize will happen via input event
}

/**
 * Handle input event for auto-resize
 */
function handleChatInputInput(event) {
    autoResizeTextarea(event.target);
}

/**
 * Set a message to reply to by ID (lookup from chatMessagesById map)
 */
window.setReplyMessageById = function (messageId) {
    const message = window.chatMessagesById?.[messageId];
    if (message) {
        window.setReplyMessage(message);
    } else {
        console.warn('[REPLY] Message not found in map:', messageId);
    }
};

/**
 * Set a message to reply to
 */
window.setReplyMessage = function (message) {
    window.currentReplyingToMessage = message;

    // Show reply preview
    const previewContainer = document.getElementById('chatReplyPreviewContainer');
    const previewText = document.getElementById('chatReplyPreviewText');

    if (previewContainer && previewText) {
        // Extract text from message (handle both text and HTML)
        const messageText = extractMessageText(message);
        const truncated = messageText.length > 100 ? messageText.substring(0, 100) + '...' : messageText;

        // Get sender name and Facebook ID
        const senderName = message.FromName || message.from?.name || 'KhÃ¡ch hÃ ng';
        const fbId = message.From?.id || message.from?.id || message.FromId || null;

        // Get timestamp
        const timestamp = message.CreatedTime || message.updated_at || message.created_at;
        let timeStr = '';
        if (timestamp) {
            const date = new Date(timestamp);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            timeStr = `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        // Verify fb_id matches current conversation's customer (if available)
        if (fbId && window.currentChatPSID && fbId !== window.currentChatPSID) {
            console.warn('[REPLY] âš ï¸ Facebook ID mismatch!', {
                messageFbId: fbId,
                conversationPSID: window.currentChatPSID
            });
        }

        // Display with timestamp
        previewText.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start; gap: 8px;">
                <div style="flex: 1; min-width: 0;">
                    <strong>${senderName}:</strong> ${truncated}
                </div>
                ${timeStr ? `<div style="color: #6b7280; font-size: 12px; white-space: nowrap; flex-shrink: 0;">${timeStr}</div>` : ''}
            </div>
        `;
        previewContainer.style.display = 'block';
    }

    // Focus input
    const input = document.getElementById('chatReplyInput');
    if (input) input.focus();

    console.log('[REPLY] Set reply to message:', message.id || message.Id, 'fb_id:', fbId, 'at', timestamp);
};

/**
 * Cancel replying to a message
 */
window.cancelReplyMessage = function () {
    window.currentReplyingToMessage = null;

    // Hide reply preview
    const previewContainer = document.getElementById('chatReplyPreviewContainer');
    if (previewContainer) {
        previewContainer.style.display = 'none';
    }

    console.log('[REPLY] Cancelled reply');
};

/**
 * Cancel replying to a comment
 */
window.cancelReplyComment = function () {
    // Clear reply state
    currentParentCommentId = null;
    currentPostId = null;

    // Hide reply preview
    const previewContainer = document.getElementById('chatReplyPreviewContainer');
    if (previewContainer) {
        previewContainer.style.display = 'none';
    }

    // Reset input and disable it (only allow replying to comments)
    const input = document.getElementById('chatReplyInput');
    const sendBtn = document.getElementById('chatSendBtn');

    if (input) {
        input.value = ''; // Clear input content
        input.disabled = true;
        input.placeholder = 'Chá»n "Tráº£ lá»i" má»™t bÃ¬nh luáº­n Ä‘á»ƒ reply...';
        input.style.background = '#f3f4f6';
        input.style.cursor = 'not-allowed';
    }

    // Disable send button
    if (sendBtn) {
        sendBtn.disabled = true;
        sendBtn.style.opacity = '0.5';
        sendBtn.style.cursor = 'not-allowed';
    }

    console.log('[REPLY] Cancelled comment reply');
};

/**
 * Cancel reply - works for both messages and comments
 */
window.cancelReply = function () {
    // Check if we're in comment or message mode
    if (currentChatType === 'comment') {
        window.cancelReplyComment();
    } else {
        window.cancelReplyMessage();
    }
};

/**
 * Extract text from message object (handles both text and HTML)
 */
function extractMessageText(message) {
    // Try different message fields
    let text = message.message || message.Message || message.text || '';

    // If HTML, extract text
    if (text.includes('<')) {
        const div = document.createElement('div');
        div.innerHTML = text;
        text = div.textContent || div.innerText || '';
    }

    return text.trim();
}

/**
 * Show/Hide sending indicator in chat modal
 */
window.showChatSendingIndicator = function (text = 'Äang gá»­i...', queueCount = 0) {
    const indicator = document.getElementById('chatSendingIndicator');
    const textSpan = document.getElementById('chatSendingText');
    const queueSpan = document.getElementById('chatQueueCount');

    if (indicator) {
        indicator.style.display = 'flex';
        if (textSpan) textSpan.textContent = text;
        if (queueSpan) {
            if (queueCount > 0) {
                queueSpan.textContent = `+${queueCount}`;
                queueSpan.style.display = 'block';
            } else {
                queueSpan.style.display = 'none';
            }
        }
    }
}

window.hideChatSendingIndicator = function () {
    const indicator = document.getElementById('chatSendingIndicator');
    if (indicator) {
        indicator.style.display = 'none';
    }
}

/**
 * Process message queue
 */
async function processChatMessageQueue() {
    if (window.chatIsProcessingQueue || window.chatMessageQueue.length === 0) {
        return;
    }

    window.chatIsProcessingQueue = true;

    while (window.chatMessageQueue.length > 0) {
        const queueCount = window.chatMessageQueue.length - 1;
        showChatSendingIndicator('Äang gá»­i...', queueCount);

        const messageData = window.chatMessageQueue.shift();
        try {
            // Route to correct function based on chatType
            if (messageData.chatType === 'message') {
                await sendMessageInternal(messageData);
            } else if (messageData.chatType === 'comment') {
                await sendCommentInternal(messageData);
            } else {
                console.error('[QUEUE] Unknown chatType:', messageData.chatType);
                throw new Error('Unknown chatType: ' + messageData.chatType);
            }
        } catch (error) {
            console.error('[QUEUE] Error sending:', error);
            // Continue with next message even if this one fails
        }
    }

    window.chatIsProcessingQueue = false;
    hideChatSendingIndicator();
}

// =====================================================
// PUBLIC API - Message Modal
// =====================================================

/**
 * Split long messages into multiple parts (max 2000 characters each)
 * This is required because Facebook Messenger API has a 2000 character limit per message.
 * Splits at newlines first, then spaces, to avoid breaking words.
 * @param {string} message - The message to split
 * @param {number} maxLength - Maximum length per part (default: 2000)
 * @returns {string[]} Array of message parts
 */
function splitMessageIntoParts(message, maxLength = 2000) {
    if (!message || message.length <= maxLength) {
        return [message];
    }

    const parts = [];
    let remaining = message;

    while (remaining.length > 0) {
        if (remaining.length <= maxLength) {
            parts.push(remaining);
            break;
        }

        // Find the nearest newline before maxLength
        let cutIndex = remaining.lastIndexOf('\n', maxLength);

        // If no newline found or too far back, find nearest space
        if (cutIndex === -1 || cutIndex < maxLength * 0.5) {
            cutIndex = remaining.lastIndexOf(' ', maxLength);
        }

        // If still no good cut point, hard cut at maxLength
        if (cutIndex === -1 || cutIndex < maxLength * 0.3) {
            cutIndex = maxLength;
        }

        const part = remaining.substring(0, cutIndex).trim();
        if (part.length > 0) {
            parts.push(part);
        }
        remaining = remaining.substring(cutIndex).trim();
    }

    console.log(`[MESSAGE] Split message into ${parts.length} parts (${message.length} chars total)`);
    return parts;
}

/**
 * Send message (MESSAGE modal only)
 * Public wrapper - adds to queue
 */
window.sendMessage = async function () {
    if (isSendingMessage) {
        console.log('[MESSAGE] Already sending, skipping duplicate call');
        return;
    }

    // Check if images are still uploading
    if (window.isUploadingImages) {
        alert('áº¢nh Ä‘ang Ä‘Æ°á»£c táº£i lÃªn. Vui lÃ²ng Ä‘á»£i cho Ä‘áº¿n khi táº£i xong.');
        console.warn('[MESSAGE] Cannot send while images are uploading');
        return;
    }

    isSendingMessage = true;

    try {
        const messageInput = document.getElementById('chatReplyInput');
        let message = messageInput.value.trim();

        // Add signature
        if (message) {
            const auth = window.authManager ? window.authManager.getAuthState() : null;
            const displayName = auth && auth.displayName ? auth.displayName : null;
            if (displayName) {
                message = message + '\nNv. ' + displayName;
            }
        }

        // Validate - skip if quick reply is sending
        const hasImages = (window.uploadedImagesData && window.uploadedImagesData.length > 0);
        if (!message && !hasImages) {
            // Don't show alert if quick reply is currently sending
            if (window.isQuickReplySending) {
                console.log('[MESSAGE] Skipping validation - quick reply is sending');
                return;
            }
            alert('Vui lÃ²ng nháº­p tin nháº¯n hoáº·c dÃ¡n áº£nh!');
            return;
        }

        // Validate required info
        if (!currentOrder || !window.currentConversationId || !window.currentChatChannelId) {
            alert('Thiáº¿u thÃ´ng tin Ä‘á»ƒ gá»­i tin nháº¯n. Vui lÃ²ng Ä‘Ã³ng vÃ  má»Ÿ láº¡i modal.');
            console.error('[MESSAGE] Missing required info');
            return;
        }

        // Capture replied message ID
        const repliedMessageId = window.currentReplyingToMessage ?
            (window.currentReplyingToMessage.id || window.currentReplyingToMessage.Id || null) : null;

        // Add to queue - use currentSendPageId for sending (independent from view page)
        const sendPageId = window.currentSendPageId || window.currentChatChannelId;
        console.log('[MESSAGE] Adding to queue', {
            repliedMessageId,
            imageCount: window.uploadedImagesData?.length || 0,
            sendPageId,
            replyType: messageReplyType
        });

        // Split message into parts if too long (Facebook Messenger limit: 2000 chars)
        const messageParts = splitMessageIntoParts(message);
        const uploadedImages = window.uploadedImagesData || [];

        // Add each message part to the queue
        for (let i = 0; i < messageParts.length; i++) {
            const messagePart = messageParts[i];
            const isLastPart = i === messageParts.length - 1;

            // Build queue data for this part
            const queueData = {
                message: messagePart,
                // Only include images in the last part
                uploadedImagesData: isLastPart ? uploadedImages : [],
                order: currentOrder,
                conversationId: window.currentConversationId,
                channelId: sendPageId,
                chatType: 'message', // EXPLICITLY set to message
                // Only include repliedMessageId in the first part
                repliedMessageId: i === 0 ? repliedMessageId : null,
                customerId: window.currentCustomerUUID, // Add customer_id for Pancake API
                messageReplyType: messageReplyType // Add reply type for private_replies support
            };

            // Add Facebook data if using private_replies (only for first part)
            if (messageReplyType === 'private_replies' && i === 0) {
                queueData.postId = window.purchaseFacebookPostId;
                queueData.commentId = window.purchaseCommentId;
                queueData.psid = window.currentChatPSID;
                console.log('[MESSAGE] Private reply data:', {
                    postId: queueData.postId,
                    commentId: queueData.commentId,
                    psid: queueData.psid
                });
            }

            window.chatMessageQueue.push(queueData);

            if (messageParts.length > 1) {
                console.log(`[MESSAGE] Queued part ${i + 1}/${messageParts.length} (${messagePart.length} chars)`);
            }
        }

        // Clear input
        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Clear images
        if (window.clearAllImages) {
            window.clearAllImages();
        }

        // Legacy cleanup
        currentPastedImage = null;
        window.currentPastedImage = null;
        window.currentPastedImageProductId = null;
        window.currentPastedImageProductName = null;

        // Clear reply state
        window.cancelReply();

        // Process queue
        processChatMessageQueue();
    } finally {
        setTimeout(() => {
            isSendingMessage = false;
        }, 100);
    }
};

// =====================================================
// PUBLIC API - Comment Modal
// =====================================================

/**
 * Send comment reply (COMMENT modal only)
 * Public wrapper - adds to queue
 */
window.sendComment = async function () {
    if (isSendingMessage) {
        console.log('[COMMENT] Already sending, skipping duplicate call');
        return;
    }

    // Check if images are still uploading
    if (window.isUploadingImages) {
        alert('áº¢nh Ä‘ang Ä‘Æ°á»£c táº£i lÃªn. Vui lÃ²ng Ä‘á»£i cho Ä‘áº¿n khi táº£i xong.');
        console.warn('[COMMENT] Cannot send while images are uploading');
        return;
    }

    isSendingMessage = true;

    try {
        const messageInput = document.getElementById('chatReplyInput');
        let message = messageInput.value.trim();

        // Add signature
        if (message) {
            const auth = window.authManager ? window.authManager.getAuthState() : null;
            const displayName = auth && auth.displayName ? auth.displayName : null;
            if (displayName) {
                message = message + '\nNv. ' + displayName;
            }
        }

        // Validate - skip if quick reply is sending
        const hasImages = (window.uploadedImagesData && window.uploadedImagesData.length > 0);
        if (!message && !hasImages) {
            // Don't show alert if quick reply is currently sending
            if (window.isQuickReplySending) {
                console.log('[COMMENT] Skipping validation - quick reply is sending');
                return;
            }
            alert('Vui lÃ²ng nháº­p bÃ¬nh luáº­n hoáº·c dÃ¡n áº£nh!');
            return;
        }

        // Validate required info
        // Note: conversationId will be built from order data in sendCommentInternal, so it's OK if null here
        if (!currentOrder || !window.currentChatChannelId) {
            alert('Thiáº¿u thÃ´ng tin Ä‘á»ƒ gá»­i bÃ¬nh luáº­n. Vui lÃ²ng Ä‘Ã³ng vÃ  má»Ÿ láº¡i modal.');
            console.error('[COMMENT] Missing required info');
            return;
        }

        // Add to queue - use currentSendPageId for sending (independent from view page)
        const sendPageId = window.currentSendPageId || window.currentChatChannelId;
        console.log('[COMMENT] Adding to queue', { imageCount: window.uploadedImagesData?.length || 0, sendPageId });

        // Split message into parts if too long (Facebook limit: 2000 chars)
        const messageParts = splitMessageIntoParts(message);
        const uploadedImages = window.uploadedImagesData || [];

        // Add each message part to the queue
        for (let i = 0; i < messageParts.length; i++) {
            const messagePart = messageParts[i];
            const isLastPart = i === messageParts.length - 1;

            window.chatMessageQueue.push({
                message: messagePart,
                // Only include images in the last part
                uploadedImagesData: isLastPart ? uploadedImages : [],
                order: currentOrder,
                conversationId: window.currentConversationId,
                channelId: sendPageId,
                chatType: 'comment', // EXPLICITLY set to comment
                // Only include parentCommentId in the first part
                parentCommentId: i === 0 ? currentParentCommentId : null,
                postId: currentPostId || currentOrder.Facebook_PostId,
                customerId: window.currentCustomerUUID // Add customer_id for Pancake API
            });

            if (messageParts.length > 1) {
                console.log(`[COMMENT] Queued part ${i + 1}/${messageParts.length} (${messagePart.length} chars)`);
            }
        }

        // Clear input
        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Clear images
        if (window.clearAllImages) {
            window.clearAllImages();
        }

        // Legacy cleanup
        currentPastedImage = null;
        window.currentPastedImage = null;
        window.currentPastedImageProductId = null;
        window.currentPastedImageProductName = null;

        // Clear reply state (for nested comments)
        if (window.cancelReply) {
            window.cancelReply();
        }

        // Process queue
        processChatMessageQueue();
    } finally {
        setTimeout(() => {
            isSendingMessage = false;
        }, 100);
    }
};

// =====================================================
// LEGACY WRAPPER - For backwards compatibility
// =====================================================

/**
 * Legacy wrapper - routes to correct function based on currentChatType
 * @deprecated Use window.sendMessage() or window.sendComment() directly
 */
window.sendReplyComment = async function () {
    console.log('[LEGACY] sendReplyComment called, routing to:', currentChatType);

    // Route to correct function based on chat type
    if (currentChatType === 'message') {
        return window.sendMessage();
    } else if (currentChatType === 'comment') {
        return window.sendComment();
    } else {
        console.error('[LEGACY] Unknown currentChatType:', currentChatType);
        alert('Lá»—i: KhÃ´ng xÃ¡c Ä‘á»‹nh Ä‘Æ°á»£c loáº¡i modal (message/comment)');
    }
};

/**
 * Get image dimensions from blob/file
 * @param {Blob|File} blob
 * @returns {Promise<{width: number, height: number}>}
 */
function getImageDimensions(blob) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(blob);

        img.onload = function () {
            URL.revokeObjectURL(url);
            resolve({
                width: img.naturalWidth,
                height: img.naturalHeight
            });
        };

        img.onerror = function () {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
        };

        img.src = url;
    });
}

// =====================================================
// MESSAGE MODAL - Send message functions
// =====================================================

/**
 * Send message via Facebook Graph API with POST_PURCHASE_UPDATE message tag
 * Used to bypass 24h policy when normal Pancake API fails
 * @param {object} params - Message parameters
 * @param {string} params.pageId - Facebook Page ID
 * @param {string} params.psid - Facebook PSID of recipient
 * @param {string} params.message - Message text to send
 * @param {Array<string>} params.imageUrls - Optional array of image URLs to send
 * @returns {Promise<{success: boolean, error?: string, messageId?: string}>}
 */
async function sendMessageViaFacebookTag(params) {
    const { pageId, psid, message, imageUrls } = params;

    console.log('[FB-TAG-SEND] ========================================');
    console.log('[FB-TAG-SEND] Attempting to send message via Facebook Graph API with POST_PURCHASE_UPDATE tag');
    console.log('[FB-TAG-SEND] Page ID:', pageId, 'PSID:', psid);

    try {
        // Get Facebook Page Token from TPOS CRMTeam data (expanded in order)
        // This token is different from Pancake's page_access_token
        let facebookPageToken = null;
        let tokenSourcePageId = null;

        // Source 1: Try from window.currentCRMTeam (set when chat modal opens)
        // IMPORTANT: Check if this CRMTeam matches the requested pageId
        if (window.currentCRMTeam && window.currentCRMTeam.Facebook_PageToken) {
            const crmPageId = window.currentCRMTeam.ChannelId || window.currentCRMTeam.Facebook_AccountId || window.currentCRMTeam.Id;
            tokenSourcePageId = crmPageId;

            // Check if pageId matches CRMTeam's page
            if (String(crmPageId) === String(pageId) ||
                String(window.currentCRMTeam.Facebook_AccountId) === String(pageId)) {
                facebookPageToken = window.currentCRMTeam.Facebook_PageToken;
                console.log('[FB-TAG-SEND] âœ… Got matching Facebook Page Token from window.currentCRMTeam');
            } else {
                console.warn(`[FB-TAG-SEND] âš ï¸ currentCRMTeam page (${crmPageId}) does not match requested page (${pageId})`);
            }
        }

        // Source 2: Try to get from current order's CRMTeam (if already loaded)
        if (!facebookPageToken && window.currentOrder && window.currentOrder.CRMTeam && window.currentOrder.CRMTeam.Facebook_PageToken) {
            const crmPageId = window.currentOrder.CRMTeam.ChannelId || window.currentOrder.CRMTeam.Facebook_AccountId;
            tokenSourcePageId = crmPageId;

            if (String(crmPageId) === String(pageId) ||
                String(window.currentOrder.CRMTeam.Facebook_AccountId) === String(pageId)) {
                facebookPageToken = window.currentOrder.CRMTeam.Facebook_PageToken;
                console.log('[FB-TAG-SEND] âœ… Got matching Facebook Page Token from currentOrder.CRMTeam');
            } else {
                console.warn(`[FB-TAG-SEND] âš ï¸ currentOrder.CRMTeam page (${crmPageId}) does not match requested page (${pageId})`);
            }
        }

        // Source 3: Try from cachedChannelsData
        if (!facebookPageToken && window.cachedChannelsData) {
            const channel = window.cachedChannelsData.find(ch =>
                String(ch.ChannelId) === String(pageId) ||
                String(ch.Facebook_AccountId) === String(pageId)
            );
            if (channel && channel.Facebook_PageToken) {
                facebookPageToken = channel.Facebook_PageToken;
                console.log('[FB-TAG-SEND] âœ… Got Facebook Page Token from cached channels');
            }
        }

        // Source 4: Fetch CRMTeam directly by pageId from TPOS (NEW!)
        if (!facebookPageToken) {
            console.log('[FB-TAG-SEND] Token not found for page, fetching CRMTeam from TPOS...');
            try {
                const headers = await window.tokenManager?.getAuthHeader() || {};
                // Try to find CRMTeam by ChannelId (pageId)
                const crmUrl = `${window.API_CONFIG.WORKER_URL}/api/odata/CRMTeam?$filter=ChannelId eq '${pageId}' or Facebook_AccountId eq '${pageId}'&$top=1`;
                const response = await fetch(crmUrl, {
                    method: 'GET',
                    headers: { ...headers, 'Accept': 'application/json' }
                });

                if (response.ok) {
                    const data = await response.json();
                    const teams = data.value || data;
                    if (teams && teams.length > 0 && teams[0].Facebook_PageToken) {
                        facebookPageToken = teams[0].Facebook_PageToken;
                        console.log('[FB-TAG-SEND] âœ… Got Facebook Page Token from CRMTeam API for page:', pageId);
                    }
                }
            } catch (fetchError) {
                console.warn('[FB-TAG-SEND] âš ï¸ Could not fetch CRMTeam from TPOS:', fetchError.message);
            }
        }

        // Source 5: Fallback - use currentCRMTeam token anyway (may cause error but better than nothing)
        if (!facebookPageToken && window.currentCRMTeam && window.currentCRMTeam.Facebook_PageToken) {
            facebookPageToken = window.currentCRMTeam.Facebook_PageToken;
            console.warn('[FB-TAG-SEND] âš ï¸ Using currentCRMTeam token as fallback - may cause page mismatch error!');
            console.warn(`[FB-TAG-SEND] âš ï¸ Token is for page: ${tokenSourcePageId}, but sending to page: ${pageId}`);
        }

        if (!facebookPageToken) {
            console.error('[FB-TAG-SEND] âŒ No Facebook Page Token found for page:', pageId);
            return {
                success: false,
                error: 'KhÃ´ng tÃ¬m tháº¥y Facebook Page Token. Token nÃ y khÃ¡c vá»›i Pancake token vÃ  cáº§n Ä‘Æ°á»£c thiáº¿t láº­p trong TPOS.'
            };
        }

        // Call Facebook Send API via our worker proxy
        const facebookSendUrl = window.API_CONFIG.buildUrl.facebookSend();
        console.log('[FB-TAG-SEND] Calling:', facebookSendUrl);

        const requestBody = {
            pageId: pageId,
            psid: psid,
            message: message,
            pageToken: facebookPageToken,
            useTag: true, // Use POST_PURCHASE_UPDATE tag
            imageUrls: imageUrls || [] // Include image URLs if provided
        };

        const response = await fetch(facebookSendUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        const result = await response.json();
        console.log('[FB-TAG-SEND] Response:', result);
        console.log('[FB-TAG-SEND] ========================================');

        if (result.success) {
            console.log('[FB-TAG-SEND] âœ… Message sent successfully via Facebook Graph API!');
            console.log('[FB-TAG-SEND] Message ID:', result.message_id);
            console.log('[FB-TAG-SEND] Used tag:', result.used_tag);
            return {
                success: true,
                messageId: result.message_id,
                recipientId: result.recipient_id,
                usedTag: result.used_tag
            };
        } else {
            console.error('[FB-TAG-SEND] âŒ Facebook API error:', result.error);
            return {
                success: false,
                error: result.error || 'Facebook API error',
                errorCode: result.error_code,
                errorSubcode: result.error_subcode
            };
        }

    } catch (error) {
        console.error('[FB-TAG-SEND] âŒ Error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// Global flag to track if 24h policy fallback UI should be shown
window.current24hPolicyStatus = {
    isExpired: false,
    hoursSinceLastMessage: null,
    canUseFacebookTag: false
};

/**
 * Show 24h policy fallback prompt with option to send via Facebook tag
 */
window.show24hFallbackPrompt = function (messageText, pageId, psid) {
    const modalContent = `
        <div style="padding: 20px; max-width: 400px;">
            <h3 style="margin: 0 0 16px; color: #ef4444; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-clock"></i>
                ÄÃ£ quÃ¡ 24 giá»
            </h3>
            <p style="color: #6b7280; margin: 0 0 16px; line-height: 1.5;">
                KhÃ¡ch hÃ ng chÆ°a tÆ°Æ¡ng tÃ¡c trong 24 giá» qua. Chá»n cÃ¡ch gá»­i tin nháº¯n:
            </p>
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button onclick="window.sendViaFacebookTagFromModal('${encodeURIComponent(messageText)}', '${pageId}', '${psid}')"
                    style="padding: 12px 16px; background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <i class="fab fa-facebook"></i>
                    Gá»­i vá»›i Message Tag (POST_PURCHASE_UPDATE)
                </button>
                <p style="font-size: 12px; color: #9ca3af; margin: 0; padding: 0 8px;">
                    âš ï¸ Chá»‰ dÃ¹ng cho thÃ´ng bÃ¡o liÃªn quan Ä‘Æ¡n hÃ ng (xÃ¡c nháº­n, váº­n chuyá»ƒn, yÃªu cáº§u hÃ nh Ä‘á»™ng)
                </p>
                <button onclick="window.switchToCommentMode()"
                    style="padding: 12px 16px; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <i class="fas fa-comment"></i>
                    Chuyá»ƒn sang reply Comment
                </button>
                <button onclick="window.close24hFallbackModal()"
                    style="padding: 10px 16px; background: transparent; color: #6b7280; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer;">
                    Há»§y
                </button>
            </div>
        </div>
    `;

    // Create modal
    let modal = document.getElementById('fb24hFallbackModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'fb24hFallbackModal';
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10001; display: flex; align-items: center; justify-content: center;';
        document.body.appendChild(modal);
    }

    modal.innerHTML = `<div style="background: white; border-radius: 12px; box-shadow: 0 20px 50px rgba(0,0,0,0.2);">${modalContent}</div>`;
    modal.style.display = 'flex';
};

window.close24hFallbackModal = function () {
    const modal = document.getElementById('fb24hFallbackModal');
    if (modal) modal.style.display = 'none';
};

window.sendViaFacebookTagFromModal = async function (encodedMessage, pageId, psid, imageUrls = []) {
    window.close24hFallbackModal();

    const message = decodeURIComponent(encodedMessage);

    if (window.notificationManager) {
        window.notificationManager.show('ğŸ”„ Äang gá»­i qua Facebook Graph API...', 'info');
    }

    const result = await sendMessageViaFacebookTag({ pageId, psid, message, imageUrls });

    if (result.success) {
        if (window.notificationManager) {
            window.notificationManager.show('âœ… ÄÃ£ gá»­i tin nháº¯n thÃ nh cÃ´ng qua Facebook!', 'success', 5000);
        }

        // Add optimistic UI update
        const now = new Date().toISOString();
        const tempMessage = {
            Id: `fb_${Date.now()}`,
            id: `fb_${Date.now()}`,
            Message: message + '\n\n[Gá»­i qua Facebook Message Tag]',
            CreatedTime: now,
            IsOwner: true,
            is_temp: true
        };
        window.allChatMessages.push(tempMessage);
        renderChatMessages(window.allChatMessages, true);

        // Refresh messages after a delay
        setTimeout(async () => {
            try {
                if (window.currentChatPSID && window.currentChatChannelId) {
                    const response = await window.chatDataManager.fetchMessages(
                        window.currentChatChannelId,
                        window.currentChatPSID
                    );
                    if (response.messages && response.messages.length > 0) {
                        window.allChatMessages = response.messages;
                        renderChatMessages(window.allChatMessages, false);
                    }
                }
            } catch (e) {
                console.error('[FB-TAG-SEND] Error refreshing messages:', e);
            }
        }, 1000);
    } else {
        if (window.notificationManager) {
            window.notificationManager.show('âŒ Lá»—i gá»­i qua Facebook: ' + result.error, 'error', 8000);
        } else {
            alert('âŒ Lá»—i gá»­i qua Facebook: ' + result.error);
        }
    }
};

window.switchToCommentMode = function () {
    window.close24hFallbackModal();
    if (window.notificationManager) {
        window.notificationManager.show('ğŸ’¡ Vui lÃ²ng má»Ÿ láº¡i modal Comment Ä‘á»ƒ reply', 'info', 5000);
    }
};

/**
 * Send message (MESSAGE modal only)
 * Called by queue processor
 * Supports both reply_inbox and private_replies actions
 */
async function sendMessageInternal(messageData) {
    const {
        message,
        uploadedImagesData,
        order,
        conversationId,
        channelId,
        repliedMessageId,
        customerId,
        messageReplyType = 'reply_inbox', // Default to reply_inbox
        postId,
        commentId,
        psid
    } = messageData;

    try {
        // Get page_access_token for Official API (pages.fm)
        const pageAccessToken = await window.pancakeTokenManager?.getOrGeneratePageAccessToken(channelId);
        if (!pageAccessToken) {
            throw new Error('KhÃ´ng tÃ¬m tháº¥y page_access_token. Vui lÃ²ng vÃ o Pancake Settings â†’ Tools Ä‘á»ƒ táº¡o token.');
        }

        showChatSendingIndicator('Äang gá»­i tin nháº¯n...');

        // Step 1: Process multiple images
        let imagesDataArray = [];
        if (uploadedImagesData && uploadedImagesData.length > 0) {
            console.log('[MESSAGE] Processing', uploadedImagesData.length, 'images');
            showChatSendingIndicator(`Äang xá»­ lÃ½ ${uploadedImagesData.length} áº£nh...`);

            for (let i = 0; i < uploadedImagesData.length; i++) {
                const imageData = uploadedImagesData[i];

                try {
                    // Check if image was already uploaded successfully (check content_id instead of content_url)
                    if ((imageData.content_id || imageData.id) && !imageData.uploadFailed) {
                        console.log(`[MESSAGE] Image ${i + 1}: Using pre-uploaded ID:`, imageData.content_id || imageData.id);
                        imagesDataArray.push(imageData);
                    } else if (imageData.blob) {
                        // Retry upload
                        console.log(`[MESSAGE] Image ${i + 1}: Retrying upload...`);
                        showChatSendingIndicator(`Äang táº£i áº£nh ${i + 1}/${uploadedImagesData.length}...`);

                        const result = await window.uploadImageWithCache(
                            imageData.blob,
                            imageData.productId || null,
                            imageData.productName || null,
                            channelId,
                            imageData.productCode || null
                        );

                        if (!result.success) {
                            throw new Error(`áº¢nh ${i + 1} upload failed: ${result.error || 'Unknown error'}`);
                        }

                        console.log(`[MESSAGE] Image ${i + 1}: Uploaded:`, result.data.content_url);
                        imagesDataArray.push(result.data);
                    }
                } catch (uploadError) {
                    console.error(`[MESSAGE] Image ${i + 1} processing failed:`, uploadError);
                    throw new Error(`Táº£i áº£nh ${i + 1} tháº¥t báº¡i: ${uploadError.message}`);
                }
            }

            console.log('[MESSAGE] All images processed:', imagesDataArray.length);
        }

        // Step 2: Build JSON payload based on reply type
        // Ref: https://developer.pancake.biz/#/paths/pages-page_id--conversations--conversation_id--messages/post
        let payload;
        let actualConversationId = conversationId;

        if (messageReplyType === 'private_replies') {
            // ========== PRIVATE REPLIES (Reply to comment via private message) ==========
            // Validate required data for private_replies
            if (!postId || !commentId || !psid) {
                throw new Error('Thiáº¿u thÃ´ng tin comment Ä‘á»ƒ gá»­i tin nháº¯n riÃªng. Vui lÃ²ng thá»­ láº¡i.');
            }

            // IMPORTANT: For private_replies, conversationId MUST equal message_id (comment_id)!
            // This matches the real Pancake API format (same as sendCommentInternal)
            actualConversationId = commentId;

            payload = {
                action: 'private_replies',
                post_id: postId,
                message_id: commentId,
                from_id: psid,
                message: message
            };

            console.log('[MESSAGE] Building PRIVATE_REPLIES payload:', {
                postId,
                commentId,
                psid,
                conversationId: actualConversationId
            });
        } else {
            // ========== REPLY INBOX (Standard Messenger reply) ==========
            payload = {
                action: 'reply_inbox',
                message: message
            };

            // Add replied_message_id if replying to a message
            if (repliedMessageId) {
                payload.replied_message_id = repliedMessageId;
                console.log('[MESSAGE] Adding replied_message_id:', repliedMessageId);
            }

            console.log('[MESSAGE] Building REPLY_INBOX payload');
        }

        // Add image data - Pancake API dÃ¹ng content_ids (array)
        if (imagesDataArray.length > 0) {
            console.log('[MESSAGE] Adding', imagesDataArray.length, 'images to payload');

            // Pancake API format: content_ids lÃ  array of content IDs tá»« upload API
            // Ref: https://developer.pancake.biz/#/ - Send Message API
            // âš ï¸ IMPORTANT: CHá»ˆ gá»­i content_ids, KHÃ”NG gá»­i content_urls
            // Facebook Messenger KHÃ”NG há»— trá»£ external URLs tá»« content.pancake.vn
            // Pancake sáº½ tá»± Ä‘á»™ng convert content_ids â†’ Facebook attachments
            payload.content_ids = imagesDataArray
                .map(img => img.content_id || img.id)
                .filter(id => id); // Lá»c bá» null/undefined

            // attachment_type báº¯t buá»™c khi cÃ³ áº£nh: PHOTO, VIDEO, DOCUMENT, AUDIO_ATTACHMENT_ID
            payload.attachment_type = 'PHOTO';

            console.log('[MESSAGE] content_ids:', payload.content_ids);
            console.log('[MESSAGE] attachment_type:', payload.attachment_type);
        }

        // Step 3: Send message via Official API (pages.fm)
        const replyUrl = window.API_CONFIG.buildUrl.pancakeOfficial(
            `pages/${channelId}/conversations/${actualConversationId}/messages`,
            pageAccessToken
        ) + (customerId ? `&customer_id=${customerId}` : '');

        console.log('[MESSAGE] Sending message...');
        console.log('[MESSAGE] URL:', replyUrl);
        console.log('[MESSAGE] Payload:', JSON.stringify(payload));

        // Try API first, then fallback to extension if available
        let apiSuccess = false;
        let apiError = null;

        try {
            const replyResponse = await API_CONFIG.smartFetch(replyUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(payload)
            }, 1, true); // maxRetries=1, skipFallback=true: chá»‰ gá»i 1 láº§n, khÃ´ng retry

            if (!replyResponse.ok) {
                const errorText = await replyResponse.text();
                console.error('[MESSAGE] Send failed:', errorText);
                throw new Error(`Gá»­i tin nháº¯n tháº¥t báº¡i: ${replyResponse.status} ${replyResponse.statusText}`);
            }

            const replyData = await replyResponse.json();
            console.log('[MESSAGE] Response:', replyData);

            if (!replyData.success) {
                console.error('[MESSAGE] API Error:', replyData);

                // Check for Facebook 24-hour policy error
                const is24HourError = (replyData.e_code === 10 && replyData.e_subcode === 2018278) ||
                    (replyData.message && replyData.message.includes('khoáº£ng thá»i gian cho phÃ©p'));

                if (is24HourError) {
                    console.warn('[MESSAGE] âš ï¸ 24-hour policy violation detected');
                    const error24h = new Error('24H_POLICY_ERROR');
                    error24h.is24HourError = true;
                    error24h.originalMessage = replyData.message;
                    throw error24h;
                }

                // Check for user unavailable error (551)
                const isUserUnavailable = (replyData.e_code === 551) ||
                    (replyData.message && replyData.message.includes('khÃ´ng cÃ³ máº·t'));

                if (isUserUnavailable) {
                    console.warn('[MESSAGE] âš ï¸ User unavailable (551) error detected');
                    const error551 = new Error('USER_UNAVAILABLE');
                    error551.isUserUnavailable = true;
                    error551.originalMessage = replyData.message;
                    throw error551;
                }

                const errorMessage = replyData.error || replyData.message || replyData.reason || 'Unknown error';
                throw new Error('Gá»­i tin nháº¯n tháº¥t báº¡i: ' + errorMessage);
            }

            apiSuccess = true;

            // Auto-mark as read after successful message send
            console.log('[MARK-READ] Message sent successfully');
            autoMarkAsRead(0);
        } catch (err) {
            apiError = err;
            console.warn('[MESSAGE] âš ï¸ API failed:', err.message);

            // NOTE: PANCAKE-UNLOCK Ä‘Ã£ Ä‘Æ°á»£c bá» - Ä‘i tháº³ng Ä‘áº¿n FB-TAG-SEND cho 24H errors
            // vÃ  Private Reply cho 551 errors

            // ========== Fallback: Private Reply (for error 551 only) ==========
            // If still not successful and this is a 551 error, try Private Reply via Facebook Graph API
            if (!apiSuccess && err.isUserUnavailable) {
                console.log('[MESSAGE] ğŸ”„ User unavailable (#551), checking for Private Reply context...');

                const facebookPostId = order.Facebook_PostId || window.purchaseFacebookPostId;
                const facebookCommentId = order.Facebook_CommentId || window.purchaseCommentId;
                const facebookASUserId = order.Facebook_ASUserId || window.purchaseFacebookASUserId || psid;

                // Get REAL Facebook Page Token (not Pancake JWT!)
                const realFacebookPageToken = window.currentCRMTeam?.Facebook_PageToken;

                if (facebookPostId && facebookCommentId && facebookASUserId && realFacebookPageToken) {
                    console.log('[MESSAGE] âœ… Found comment context, attempting Private Reply fallback...');
                    showChatSendingIndicator('KhÃ¡ch chÆ°a nháº¯n tin, Ä‘ang thá»­ Private Reply...');

                    try {
                        // Extract Comment ID (first one if multiple)
                        const commentIds = facebookCommentId.toString().split(',').map(id => id.trim());
                        const targetCommentId = commentIds[0];

                        // Build Private Reply payload for Facebook Graph API
                        const privateReplyUrl = window.API_CONFIG.buildUrl.facebookSend();

                        const privatePayload = {
                            pageId: channelId, // Required by worker proxy
                            recipient: {
                                comment_id: targetCommentId
                            },
                            message: {
                                text: message
                            },
                            pageToken: realFacebookPageToken // REAL Facebook Page Token (EAAEppgm... format)
                        };

                        console.log('[MESSAGE] Sending Private Reply (Graph API) payload:', JSON.stringify(privatePayload));

                        const prResponse = await API_CONFIG.smartFetch(privateReplyUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify(privatePayload)
                        }, 1, true);

                        if (prResponse.ok) {
                            const prData = await prResponse.json();
                            if (prData.success !== false) {
                                console.log('[MESSAGE] âœ… Private Reply fallback succeeded!');
                                apiSuccess = true;
                                apiError = null;

                                if (window.notificationManager) {
                                    window.notificationManager.show('âœ… ÄÃ£ gá»­i tin nháº¯n (Private Reply) thÃ nh cÃ´ng!', 'success');
                                }

                                // Auto-mark as read
                                autoMarkAsRead(0);
                            } else {
                                console.warn('[MESSAGE] âŒ Private Reply API error:', prData);
                            }
                        } else {
                            const errorData = await prResponse.json().catch(() => ({}));
                            console.warn('[MESSAGE] âŒ Private Reply HTTP error:', prResponse.status, errorData);
                        }
                    } catch (prError) {
                        console.error('[MESSAGE] âŒ Private Reply fallback failed:', prError);
                    }
                } else {
                    console.warn('[MESSAGE] âš ï¸ Cannot try Private Reply: Missing context', {
                        hasPostId: !!facebookPostId,
                        hasCommentId: !!facebookCommentId,
                        hasASUserId: !!facebookASUserId,
                        hasPageToken: !!realFacebookPageToken
                    });
                }
            }
        }

        // If API failed, throw error
        if (!apiSuccess && apiError) {
            throw apiError;
        }

        // Step 4: Optimistic UI update
        const now = new Date().toISOString();
        skipWebhookUpdate = true;

        const tempMessage = {
            Id: `temp_${Date.now()}`,
            id: `temp_${Date.now()}`,
            Message: message,
            CreatedTime: now,
            IsOwner: true,
            is_temp: true
        };

        // Add image attachments
        if (imagesDataArray && imagesDataArray.length > 0) {
            tempMessage.Attachments = imagesDataArray.map(img => ({
                Type: 'image',
                Payload: { Url: img.content_url }
            }));
        }

        window.allChatMessages.push(tempMessage);
        renderChatMessages(window.allChatMessages, true);

        console.log('[MESSAGE] Added optimistic message to UI');

        // Step 5: Refresh messages from API
        setTimeout(async () => {
            try {
                if (window.currentChatPSID) {
                    const response = await window.chatDataManager.fetchMessages(channelId, window.currentChatPSID);
                    if (response.messages && response.messages.length > 0) {
                        window.allChatMessages = response.messages;
                        renderChatMessages(window.allChatMessages, false);
                        console.log('[MESSAGE] Replaced temp messages with real data');
                    }
                }
            } finally {
                skipWebhookUpdate = false;
            }
        }, 300);

        // Success notification
        if (window.notificationManager) {
            window.notificationManager.show('âœ… ÄÃ£ gá»­i tin nháº¯n thÃ nh cÃ´ng!', 'success');
        }

        console.log('[MESSAGE] âœ… Sent successfully');

    } catch (error) {
        console.error('[MESSAGE] âŒ Error:', error);

        // Special handling for 24-hour policy error or user unavailable (551) error
        if (error.is24HourError || error.isUserUnavailable) {
            const errorType = error.is24HourError ? '24H' : '551';
            console.log(`[MESSAGE] ğŸ“ Showing Facebook Tag fallback for ${errorType} error`);

            // Get the original message text from the messageData
            const originalMessage = messageData.message || '';
            const pageId = messageData.channelId || window.currentChatChannelId;

            // IMPORTANT: Get the real Facebook PSID from conversation data
            // window.currentChatPSID may be Pancake internal ID, not Facebook PSID
            // Facebook Graph API requires the real PSID (from_psid or customers[0].fb_id)
            let psid = null;

            // Try to use the saved real Facebook PSID first
            if (window.currentRealFacebookPSID) {
                psid = window.currentRealFacebookPSID;
                console.log('[MESSAGE] âœ… Using saved real Facebook PSID:', psid);
            }
            // Fallback: Try to get from current conversation data (cached)
            else if (window.currentConversationId && window.pancakeDataManager) {
                const convId = window.currentConversationId;
                // Search in inboxMapByPSID values
                for (const [key, conv] of window.pancakeDataManager.inboxMapByPSID) {
                    if (conv.id === convId) {
                        psid = conv.from_psid || (conv.customers && conv.customers[0]?.fb_id);
                        if (psid) {
                            console.log('[MESSAGE] âœ… Got real PSID from cached conversation:', psid);
                            break;
                        }
                    }
                }
            }

            // Last fallback to currentChatPSID if no real PSID found
            if (!psid) {
                psid = window.currentChatPSID;
                console.log('[MESSAGE] âš ï¸ Using currentChatPSID as last fallback:', psid);
            }

            // Auto-send via Facebook Tag (POST_PURCHASE_UPDATE) for 24h error or 551 error
            if ((error.is24HourError || error.isUserUnavailable) && originalMessage && pageId && psid) {
                const errorType = error.is24HourError ? '24h error' : '551 (user unavailable)';
                console.log(`[MESSAGE] ğŸ”„ Auto-sending via Facebook Tag for ${errorType}`);

                // Extract image URLs from uploadedImagesData
                const imageUrls = [];
                if (messageData.uploadedImagesData && messageData.uploadedImagesData.length > 0) {
                    for (const imgData of messageData.uploadedImagesData) {
                        // Try content_url first (from cache)
                        if (imgData.content_url) {
                            imageUrls.push(imgData.content_url);
                        }
                        // Otherwise build URL from content_id
                        else if (imgData.content_id || imgData.id) {
                            const contentId = imgData.content_id || imgData.id;
                            // Pancake content URL format
                            imageUrls.push(`https://content.pancake.vn/2.1-25/contents/${contentId}`);
                        }
                    }
                    console.log('[MESSAGE] Extracted image URLs for Facebook Tag:', imageUrls);
                }

                // Auto-send without showing modal
                window.sendViaFacebookTagFromModal(encodeURIComponent(originalMessage), pageId, psid, imageUrls);
            } else {
                // For missing data, just show notification
                let message = error.is24HourError
                    ? 'âš ï¸ KhÃ´ng thá»ƒ gá»­i Inbox (Ä‘Ã£ quÃ¡ 24h). Thá»­ gá»­i qua Facebook Message Tag hoáº·c dÃ¹ng COMMENT!'
                    : 'âš ï¸ KhÃ´ng thá»ƒ gá»­i Inbox (ngÆ°á»i dÃ¹ng khÃ´ng cÃ³ máº·t). Äang thá»­ gá»­i qua Facebook...';

                if (window.notificationManager) {
                    window.notificationManager.show(message, 'warning', 8000);
                } else {
                    alert(message);
                }
            }
            // Don't throw error for these cases - just notify user
            return;
        }

        if (window.notificationManager) {
            window.notificationManager.show('âŒ Lá»—i khi gá»­i tin nháº¯n: ' + error.message, 'error');
        } else {
            alert('âŒ Lá»—i khi gá»­i tin nháº¯n: ' + error.message);
        }
        throw error;
    }
}

// =====================================================
// COMMENT MODAL - Send comment functions
// =====================================================

/**
 * Send comment reply (COMMENT modal only)
 * Called by queue processor
 */
async function sendCommentInternal(commentData) {
    const { message, uploadedImagesData, order, conversationId, channelId, parentCommentId, postId, customerId } = commentData;

    try {
        // Get page_access_token for Official API (pages.fm)
        const pageAccessToken = await window.pancakeTokenManager?.getOrGeneratePageAccessToken(channelId);
        if (!pageAccessToken) {
            throw new Error('KhÃ´ng tÃ¬m tháº¥y page_access_token. Vui lÃ²ng vÃ o Pancake Settings â†’ Tools Ä‘á»ƒ táº¡o token.');
        }

        showChatSendingIndicator('Äang gá»­i bÃ¬nh luáº­n...');

        // Step 1: Process single image (comments only support 1 image)
        let imageData = null;
        if (uploadedImagesData && uploadedImagesData.length > 0) {
            const firstImage = uploadedImagesData[0];
            console.log('[COMMENT] Processing image');
            showChatSendingIndicator('Äang xá»­ lÃ½ áº£nh...');

            try {
                // Check content_id instead of content_url (API returns id, not url)
                if ((firstImage.content_id || firstImage.id) && !firstImage.uploadFailed) {
                    console.log('[COMMENT] Using pre-uploaded image ID:', firstImage.content_id || firstImage.id);
                    imageData = firstImage;
                } else if (firstImage.blob) {
                    console.log('[COMMENT] Uploading image...');
                    const result = await window.uploadImageWithCache(
                        firstImage.blob,
                        firstImage.productId || null,
                        firstImage.productName || null,
                        channelId,
                        firstImage.productCode || null
                    );

                    if (!result.success) {
                        throw new Error(`Upload failed: ${result.error || 'Unknown error'}`);
                    }

                    console.log('[COMMENT] Image uploaded:', result.data.content_url);
                    imageData = result.data;
                }
            } catch (uploadError) {
                console.error('[COMMENT] Image processing failed:', uploadError);
                throw new Error(`Táº£i áº£nh tháº¥t báº¡i: ${uploadError.message}`);
            }
        }

        // Step 2: Build conversationId and validate order data
        const facebookName = order.Facebook_UserName;
        const facebookASUserId = order.Facebook_ASUserId;
        const facebookCommentId = order.Facebook_CommentId;
        const facebookPostId = order.Facebook_PostId;

        if (!facebookName || !facebookASUserId || !facebookCommentId || !facebookPostId) {
            throw new Error('Thiáº¿u thÃ´ng tin: Facebook_UserName, Facebook_ASUserId, Facebook_CommentId, hoáº·c Facebook_PostId');
        }

        // Use channelId from dropdown selection, or extract from order if not available
        const pageId = channelId || facebookPostId.split('_')[0];
        console.log('[COMMENT] Using pageId from selection:', pageId, '(channelId param:', channelId, ')');

        // For message_id: use parentCommentId if replying to specific comment, otherwise use order's comment ID
        let messageId;
        if (parentCommentId) {
            // Replying to a specific comment - use parentCommentId
            messageId = parentCommentId;
            console.log('[COMMENT] Using parentCommentId as messageId:', messageId);
        } else {
            // Replying to root comment or no specific parent - use order's comment ID
            const commentIds = facebookCommentId.split(',').map(id => id.trim());
            messageId = commentIds[0];
            console.log('[COMMENT] Using order comment ID as messageId:', messageId);
        }

        // IMPORTANT: For private_replies, conversationId MUST equal message_id!
        // This matches the real Pancake API format (e.g., both are "1573633073980967_1544674883102468")
        const finalConversationId = messageId;

        console.log('[COMMENT] Message ID:', messageId);
        console.log('[COMMENT] ConversationId (same as messageId):', finalConversationId);
        console.log('[COMMENT] Param conversationId:', conversationId);

        // Step 3: Fetch inbox_preview to get thread_id_preview and thread_key_preview
        let threadId = null;
        let threadKey = null;
        const fromId = facebookASUserId;

        if (customerId && window.pancakeDataManager) {
            try {
                console.log('[COMMENT] Fetching inbox_preview for thread IDs...');
                showChatSendingIndicator('Äang láº¥y thÃ´ng tin thread...');
                const inboxPreview = await window.pancakeDataManager.fetchInboxPreview(pageId, customerId);
                if (inboxPreview.success) {
                    threadId = inboxPreview.threadId || null;
                    threadKey = inboxPreview.threadKey || null;
                    console.log('[COMMENT] âœ… Got thread IDs from inbox_preview:', { threadId, threadKey });
                } else {
                    console.warn('[COMMENT] âš ï¸ inbox_preview returned unsuccessfully, using null thread IDs');
                }
            } catch (inboxError) {
                console.warn('[COMMENT] âš ï¸ Could not fetch inbox_preview, using null thread IDs:', inboxError.message);
            }
        } else {
            console.warn('[COMMENT] âš ï¸ Missing customerId or pancakeDataManager, using null thread IDs');
        }

        console.log('[COMMENT] Using data:', {
            pageId,
            conversationId: finalConversationId,
            fromId,
            threadId: threadId || 'null',
            threadKey: threadKey || 'null'
        });

        // Step 4: Send private_replies via Official API (pages.fm)
        // Ref: https://developer.pancake.biz/#/paths/pages-page_id--conversations--conversation_id--messages/post
        // private_replies: gá»­i tin nháº¯n riÃªng tá»« comment (chá»‰ Facebook/Instagram)
        showChatSendingIndicator('Äang gá»­i tin nháº¯n riÃªng...');

        const apiUrl = window.API_CONFIG.buildUrl.pancakeOfficial(
            `pages/${pageId}/conversations/${finalConversationId}/messages`,
            pageAccessToken
        ) + (customerId ? `&customer_id=${customerId}` : '');

        // Prepare private_replies payload (JSON) - theo API chÃ­nh thá»©c
        // Required fields: action, post_id, message_id, from_id, message
        const privateRepliesPayload = {
            action: 'private_replies',
            post_id: facebookPostId,
            message_id: messageId,
            from_id: fromId,
            message: message
        };

        // Add image náº¿u cÃ³ - dÃ¹ng content_ids (array) theo API chÃ­nh thá»©c
        if (imageData) {
            const contentId = imageData.content_id || imageData.id;
            if (contentId) {
                privateRepliesPayload.content_ids = [contentId];
                privateRepliesPayload.attachment_type = 'PHOTO';
            }
        }

        console.log('[COMMENT] Sending private_replies...');
        console.log('[COMMENT] Payload:', JSON.stringify(privateRepliesPayload));

        // Send single request (khÃ´ng cáº§n gá»­i 2 API song song nhÆ° trÆ°á»›c)
        let privateRepliesSuccess = false;

        try {
            const response = await API_CONFIG.smartFetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(privateRepliesPayload)
            }, 1, true); // maxRetries=1, skipFallback=true: chá»‰ gá»i 1 láº§n, khÃ´ng retry

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`private_replies failed: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            if (data.success === false) {
                throw new Error(`private_replies API error: ${data.error || data.message || 'Unknown'}`);
            }

            console.log('[COMMENT] âœ… private_replies succeeded:', data);
            privateRepliesSuccess = true;
        } catch (err) {
            console.warn('[COMMENT] âŒ private_replies failed:', err.message);
        }

        // Check result
        if (!privateRepliesSuccess) {
            throw new Error('Gá»­i tin nháº¯n riÃªng tháº¥t báº¡i (private_replies)');
        }

        console.log('[COMMENT] âœ… private_replies succeeded!');

        // Step 6: Optimistic UI update
        const now = new Date().toISOString();
        skipWebhookUpdate = true;

        const tempComment = {
            Id: `temp_${Date.now()}`,
            Message: message,
            From: {
                Name: 'Me',
                Id: channelId
            },
            CreatedTime: now,
            is_temp: true,
            ParentId: parentCommentId
        };

        window.allChatComments.push(tempComment);
        renderComments(window.allChatComments, true);

        console.log('[COMMENT] Added optimistic comment to UI');

        // Step 6: Refresh comments from API
        setTimeout(async () => {
            try {
                if (window.currentChatPSID) {
                    const response = await window.chatDataManager.fetchComments(channelId, window.currentChatPSID);
                    if (response.comments && response.comments.length > 0) {
                        window.allChatComments = window.allChatComments.filter(c => !c.is_temp);

                        response.comments.forEach(newComment => {
                            const exists = window.allChatComments.some(c => c.Id === newComment.Id);
                            if (!exists) {
                                window.allChatComments.push(newComment);
                            }
                        });

                        renderComments(window.allChatComments, false);
                        console.log('[COMMENT] Replaced temp comments with real data');
                    }
                }
            } finally {
                skipWebhookUpdate = false;
            }
        }, 300);

        // Success notification
        if (window.notificationManager) {
            window.notificationManager.show('âœ… ÄÃ£ gá»­i tin nháº¯n riÃªng thÃ nh cÃ´ng!', 'success');
        }

        console.log('[COMMENT] âœ… Sent successfully!');

    } catch (error) {
        console.error('[COMMENT] âŒ Error:', error);
        if (window.notificationManager) {
            window.notificationManager.show('âŒ Lá»—i khi gá»­i bÃ¬nh luáº­n: ' + error.message, 'error');
        } else {
            alert('âŒ Lá»—i khi gá»­i bÃ¬nh luáº­n: ' + error.message);
        }
        throw error;
    }
}

/**
 * Handle click on "Tráº£ lá»i" button in comment list
 * @param {string} commentId - ID of the comment being replied to
 * @param {string} postId - Post ID of the comment
 */
function handleReplyToComment(commentId, postId) {
    console.log(`[CHAT] Replying to comment: ${commentId}, post: ${postId}`);

    // Set current parent comment ID
    // Look up the comment in allChatComments to get the full object
    // Support both uppercase (Id) and lowercase (id) field names from Pancake API
    const comment = window.allChatComments.find(c => (c.Id || c.id) === commentId);

    if (comment) {
        // Use helper to get the correct ID (FacebookId, OriginalId, etc.)
        currentParentCommentId = getFacebookCommentId(comment);
        console.log(`[CHAT] Selected parent comment ID: ${currentParentCommentId} (from ${comment.Id})`);
    } else {
        // Fallback if comment not found in local list (shouldn't happen often)
        currentParentCommentId = commentId;
        console.warn(`[CHAT] Could not find comment object for ${commentId}, using raw ID`);
    }

    // Set current post ID (if available)
    if (postId && postId !== 'undefined' && postId !== 'null') {
        currentPostId = postId;
    } else {
        currentPostId = null;
    }

    // Show reply preview
    const previewContainer = document.getElementById('chatReplyPreviewContainer');
    const previewText = document.getElementById('chatReplyPreviewText');

    if (previewContainer && previewText && comment) {
        // Extract comment text (handle both text and HTML)
        let commentText = comment.Message || comment.message || comment.text || '';

        // If HTML, extract text content
        if (commentText.includes('<')) {
            const div = document.createElement('div');
            div.innerHTML = commentText;
            commentText = div.textContent || div.innerText || '';
        }

        // Get sender name and Facebook ID
        const senderName = comment.FromName || comment.from?.name || 'KhÃ¡ch hÃ ng';
        const fbId = comment.From?.id || comment.from?.id || comment.FromId || null;

        // Get timestamp (use CreatedTime or updated_at)
        const timestamp = comment.CreatedTime || comment.updated_at || comment.created_at;
        let timeStr = '';
        if (timestamp) {
            const date = new Date(timestamp);
            // Format: DD/MM/YYYY HH:mm
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            timeStr = `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        // Verify fb_id matches current conversation's customer (if available)
        if (fbId && window.currentChatPSID && fbId !== window.currentChatPSID) {
            console.warn('[REPLY] âš ï¸ Facebook ID mismatch!', {
                commentFbId: fbId,
                conversationPSID: window.currentChatPSID
            });
        }

        // Show preview with sender name and truncated message
        const maxLength = 100;
        const truncatedText = commentText.length > maxLength
            ? commentText.substring(0, maxLength) + '...'
            : commentText;

        // Display with timestamp
        previewText.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start; gap: 8px;">
                <div style="flex: 1; min-width: 0;">
                    <strong>${senderName}:</strong> ${truncatedText}
                </div>
                ${timeStr ? `<div style="color: #6b7280; font-size: 12px; white-space: nowrap; flex-shrink: 0;">${timeStr}</div>` : ''}
            </div>
        `;
        previewContainer.style.display = 'block';

        console.log('[REPLY] Showing preview for comment:', senderName, 'fb_id:', fbId, truncatedText, 'at', timeStr);
    }

    // Focus input and enable it for replying
    const input = document.getElementById('chatReplyInput');
    const sendBtn = document.getElementById('chatSendBtn');

    if (input) {
        // Enable input and send button
        input.disabled = false;
        input.style.cursor = 'text';
        input.style.background = '#f9fafb';
        input.focus();
        input.placeholder = `Nháº­p ná»™i dung tráº£ lá»i...`;

        // Enable send button
        if (sendBtn) {
            sendBtn.disabled = false;
            sendBtn.style.opacity = '1';
            sendBtn.style.cursor = 'pointer';
        }

        // Add visual feedback (optional)
        input.style.borderColor = '#3b82f6';
        setTimeout(() => {
            input.style.borderColor = '#d1d5db';
        }, 1000);
    }
}

function renderChatMessages(messages, scrollToBottom = false) {
    const modalBody = document.getElementById('chatModalBody');

    if (!messages || messages.length === 0) {
        modalBody.innerHTML = `
            <div class="chat-empty">
                <i class="fas fa-comments"></i>
                <p>ChÆ°a cÃ³ tin nháº¯n</p>
            </div>`;
        return;
    }

    // Format time helper - use global formatTimeVN
    const formatTime = window.formatTimeVN;

    // Sort messages by timestamp - oldest first (newest at bottom like Messenger/Zalo)
    const sortedMessages = messages.slice().sort((a, b) => {
        const timeA = new Date(a.inserted_at || a.CreatedTime || 0).getTime();
        const timeB = new Date(b.inserted_at || b.CreatedTime || 0).getTime();
        return timeA - timeB; // Ascending: oldest first, newest last (at bottom)
    });

    // Initialize map to store messages by ID for reply functionality
    if (!window.chatMessagesById) {
        window.chatMessagesById = {};
    }

    const messagesHTML = sortedMessages.map(msg => {
        // Store message in map for reply button lookup
        const msgId = msg.id || msg.Id || null;
        if (msgId) {
            window.chatMessagesById[msgId] = msg;
        }
        // Determine isOwner by comparing from.id with page_id (Pancake API format)
        const pageId = window.currentChatChannelId || msg.page_id || null;
        const fromId = msg.from?.id || msg.FromId || null;
        const isOwner = msg.IsOwner !== undefined ? msg.IsOwner : (fromId === pageId);
        const alignClass = isOwner ? 'chat-message-right' : 'chat-message-left';
        const bgClass = isOwner ? 'chat-bubble-owner' : 'chat-bubble-customer';

        // Get avatar URL - prioritize direct URL from Pancake API
        const cachedToken = window.pancakeTokenManager?.token || null;
        // Check for direct avatar URL from Pancake (avatar, picture, profile_picture fields)
        const directAvatar = msg.from?.avatar || msg.from?.picture || msg.from?.profile_picture || msg.avatar || null;
        const avatarUrl = window.pancakeDataManager?.getAvatarUrl(fromId, pageId, cachedToken, directAvatar) ||
            'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle cx="20" cy="20" r="20" fill="%23e5e7eb"/><circle cx="20" cy="15" r="7" fill="%239ca3af"/><ellipse cx="20" cy="32" rx="11" ry="8" fill="%239ca3af"/></svg>';
        const senderName = msg.from?.name || msg.FromName || '';

        // Debug: log ALL messages with reactions data to identify format
        const hasReactionData = msg.reactions || msg.reaction_summary;
        if (hasReactionData) {
            console.log('[CHAT REACTIONS DEBUG] Message with reactions:', {
                messageId: msg.id || msg.Id,
                senderName: senderName,
                reactions: msg.reactions,
                reaction_summary: msg.reaction_summary,
                allReactionFields: Object.keys(msg).filter(key => key.toLowerCase().includes('react'))
            });
        } else {
            // Log first message even without reactions to see full structure
            if (sortedMessages.indexOf(msg) === 0) {
                console.log('[CHAT REACTIONS DEBUG] First message (no reactions):', {
                    allFields: Object.keys(msg),
                    fullMessage: msg
                });
            }
        }
        // Admin name for page messages (Pancake API returns from.admin_name for staff-sent messages)
        const adminName = msg.from?.admin_name || null;

        // Get message text - prioritize original_message (plain text from Pancake API)
        let messageText = msg.original_message || msg.message || msg.Message || '';

        // If message is HTML (from Pancake's "message" field), strip HTML tags
        if (messageText && messageText.includes('<div>')) {
            messageText = messageText.replace(/<[^>]*>/g, '').trim();
        }

        let content = '';
        if (messageText) {
            // Escape HTML to prevent XSS but preserve emoji and special characters
            // Only escape < and > to prevent HTML injection
            let escapedMessage = messageText
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\r/g, '');

            // Convert URLs to clickable links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            escapedMessage = escapedMessage.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: underline;">$1</a>');

            content = `<p class="chat-message-text" style="word-wrap: break-word; white-space: pre-wrap;">${escapedMessage}</p>`;
        }

        // Handle attachments (images and audio)
        if (msg.Attachments && msg.Attachments.length > 0) {
            msg.Attachments.forEach(att => {
                if (att.Type === 'image' && att.Payload && att.Payload.Url) {
                    content += `<img src="${att.Payload.Url}" class="chat-message-image" loading="lazy" />`;
                } else if (att.Type === 'audio' && att.Payload && att.Payload.Url) {
                    content += `
                        <div class="chat-audio-message">
                            <i class="fas fa-microphone" style="color: #3b82f6; margin-right: 8px;"></i>
                            <audio controls style="max-width: 100%; height: 32px;">
                                <source src="${att.Payload.Url}" type="audio/mp4">
                                TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t audio
                            </audio>
                        </div>`;
                }
            });
        }

        // Handle Pancake API format attachments (lowercase 'attachments')
        if (msg.attachments && msg.attachments.length > 0) {
            // Collect all images first for grid layout
            const images = [];

            msg.attachments.forEach(att => {
                // Collect images
                if (att.type === 'photo' && att.url) {
                    images.push(att.url);
                } else if (att.mime_type && att.mime_type.startsWith('image/') && att.file_url) {
                    images.push(att.file_url);
                }
            });

            // Render images in grid if multiple
            if (images.length > 0) {
                const gridClass = images.length === 1 ? 'chat-image-grid-single' :
                    images.length === 2 ? 'chat-image-grid-two' :
                        images.length === 3 ? 'chat-image-grid-three' :
                            'chat-image-grid-multi';

                content += `<div class="chat-image-grid ${gridClass}">`;
                images.forEach((imageUrl, idx) => {
                    const escapedUrl = imageUrl.replace(/'/g, "\\'");
                    content += `<img src="${imageUrl}"
                        class="chat-grid-image"
                        loading="lazy"
                        onclick="showImageZoom('${escapedUrl}', 'áº¢nh ${idx + 1}/${images.length}')"
                        title="Click Ä‘á»ƒ phÃ³ng to" />`;
                });
                content += `</div>`;
            }

            // Now process other attachments
            msg.attachments.forEach(att => {
                // Skip images (already rendered)
                if ((att.type === 'photo' && att.url) ||
                    (att.mime_type && att.mime_type.startsWith('image/') && att.file_url)) {
                    return;
                }

                // Replied Message (Quoted message)
                if (att.type === 'replied_message') {
                    // Debug: Log replied_message structure to find the correct ID field
                    console.log('[REPLIED_MESSAGE] Full attachment object:', JSON.stringify(att, null, 2));

                    const quotedText = att.message || '';
                    const quotedFrom = att.from?.name || att.from?.admin_name || 'Unknown';
                    const quotedHasAttachment = att.attachments && att.attachments.length > 0;
                    const quotedMessageId = att.id || att.message_id || att.mid || '';

                    console.log('[REPLIED_MESSAGE] Extracted ID:', quotedMessageId, 'from fields:', {
                        'att.id': att.id,
                        'att.message_id': att.message_id,
                        'att.mid': att.mid
                    });

                    // Build attachment preview content
                    let attachmentPreview = '';
                    if (quotedHasAttachment) {
                        att.attachments.forEach(qAtt => {
                            // Image attachment
                            if ((qAtt.type === 'photo' && qAtt.url) ||
                                (qAtt.mime_type && qAtt.mime_type.startsWith('image/') && qAtt.file_url)) {
                                const imgUrl = qAtt.url || qAtt.file_url;
                                attachmentPreview += `
                                    <div style="margin-top: 4px;">
                                        <img src="${imgUrl}" style="max-width: 80px; max-height: 60px; border-radius: 4px; object-fit: cover;" loading="lazy" />
                                    </div>`;
                            }
                            // Audio attachment
                            else if (qAtt.mime_type === 'audio/mp4' && qAtt.file_url) {
                                attachmentPreview += `
                                    <div style="margin-top: 4px; display: flex; align-items: center; color: #6b7280; font-size: 11px;">
                                        <i class="fas fa-microphone" style="margin-right: 4px;"></i>
                                        <span>Tin nháº¯n thoáº¡i</span>
                                    </div>`;
                            }
                            // Video attachment
                            else if ((qAtt.type === 'video_inline' || qAtt.type === 'video_direct_response' || qAtt.type === 'video') && qAtt.url) {
                                attachmentPreview += `
                                    <div style="margin-top: 4px; display: flex; align-items: center; color: #6b7280; font-size: 11px;">
                                        <i class="fas fa-video" style="margin-right: 4px;"></i>
                                        <span>Video</span>
                                    </div>`;
                            }
                            // Sticker attachment
                            else if (qAtt.type === 'sticker' && (qAtt.url || qAtt.file_url)) {
                                const stickerUrl = qAtt.url || qAtt.file_url;
                                attachmentPreview += `
                                    <div style="margin-top: 4px;">
                                        <img src="${stickerUrl}" style="max-width: 50px; max-height: 50px;" loading="lazy" />
                                    </div>`;
                            }
                            // File attachment
                            else if (qAtt.type === 'file' || (qAtt.mime_type && qAtt.file_url)) {
                                const fileName = qAtt.name || 'Tá»‡p Ä‘Ã­nh kÃ¨m';
                                attachmentPreview += `
                                    <div style="margin-top: 4px; display: flex; align-items: center; color: #6b7280; font-size: 11px;">
                                        <i class="fas fa-file" style="margin-right: 4px;"></i>
                                        <span>${fileName}</span>
                                    </div>`;
                            }
                            // Generic attachment fallback
                            else if (!attachmentPreview) {
                                attachmentPreview += `
                                    <div style="margin-top: 4px; display: flex; align-items: center; color: #6b7280; font-size: 11px;">
                                        <i class="fas fa-paperclip" style="margin-right: 4px;"></i>
                                        <span>Tá»‡p Ä‘Ã­nh kÃ¨m</span>
                                    </div>`;
                            }
                        });
                    }

                    // Display text content (if any)
                    const textContent = quotedText ? `<div style="font-size: 12px; color: #374151;">${quotedText}</div>` : '';
                    const displayContent = textContent || attachmentPreview || '<div style="font-size: 12px; color: #9ca3af;">[KhÃ´ng cÃ³ ná»™i dung]</div>';

                    // Add click handler if we have a message ID
                    const clickHandler = quotedMessageId ? `onclick="window.scrollToMessage('${quotedMessageId}')"` : '';
                    const cursorStyle = quotedMessageId ? 'cursor: pointer;' : '';

                    content = `
                        <div class="quoted-message" ${clickHandler} style="background: #f3f4f6; border-left: 3px solid #3b82f6; padding: 8px 10px; margin-bottom: 8px; border-radius: 4px; ${cursorStyle} transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                            <div style="font-size: 11px; color: #6b7280; margin-bottom: 2px;">
                                <i class="fas fa-reply" style="margin-right: 4px;"></i>${quotedFrom}
                            </div>
                            ${displayContent}
                            ${textContent && attachmentPreview ? attachmentPreview : ''}
                        </div>
                    ` + content;
                    return;
                }

                // Debug: Log attachment structure to identify sticker format
                if (att.type === 'sticker' || att.sticker_id || att.type === 'animated_image_share') {
                    console.log('[DEBUG STICKER] Attachment object:', JSON.stringify(att, null, 2));
                }

                // Audio: mime_type = "audio/mp4", file_url
                if (att.mime_type === 'audio/mp4' && att.file_url) {
                    content += `
                        <div class="chat-audio-message" style="display: flex; align-items: center; background: #f3f4f6; padding: 10px 14px; border-radius: 20px; margin-top: 8px;">
                            <i class="fas fa-microphone" style="color: #3b82f6; margin-right: 10px; font-size: 16px;"></i>
                            <audio controls style="height: 36px; flex: 1;">
                                <source src="${att.file_url}" type="audio/mp4">
                                TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t audio
                            </audio>
                        </div>`;
                }
                // Link attachment with comment (private reply preview from Pancake)
                else if (att.type === 'link' && att.comment) {
                    const commentFrom = att.comment.from || '';
                    const commentContent = att.comment.content || '';
                    const postName = att.name || '';
                    const postUrl = att.url || '#';
                    // Show post thumbnail if available
                    const thumbnail = att.post_attachments?.[0]?.url || '';
                    content += `
                        <div class="chat-link-attachment" style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; margin-top: 8px; overflow: hidden;">
                            ${thumbnail ? `<img src="${thumbnail}" style="width: 100%; max-height: 120px; object-fit: cover; border-bottom: 1px solid #e2e8f0;" loading="lazy" />` : ''}
                            <div style="padding: 10px 12px;">
                                <p style="font-size: 12px; color: #64748b; margin: 0 0 4px 0;"><i class="fas fa-comment" style="margin-right: 6px;"></i>BÃ¬nh luáº­n tá»« ${commentFrom}</p>
                                <p style="font-size: 13px; color: #1e293b; margin: 0 0 6px 0; font-weight: 500;">"${commentContent}"</p>
                                <a href="${postUrl}" target="_blank" style="font-size: 11px; color: #3b82f6; text-decoration: none; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    <i class="fas fa-external-link-alt" style="margin-right: 4px;"></i>${postName || 'Xem bÃ i viáº¿t'}
                                </a>
                            </div>
                        </div>`;
                }
                // Video attachment
                else if ((att.type === 'video_inline' || att.type === 'video_direct_response' || att.type === 'video') && att.url) {
                    content += `
                        <div class="chat-video-attachment" style="margin-top: 8px;">
                            <img src="${att.url}" style="max-width: 100%; border-radius: 8px; cursor: pointer;" onclick="window.open('${att.url}', '_blank')" loading="lazy" />
                        </div>`;
                }
                // Sticker attachment from Messenger (type = 'sticker')
                else if (att.type === 'sticker' && (att.url || att.file_url)) {
                    const stickerUrl = att.url || att.file_url;
                    content += `
                        <div class="chat-sticker-message" style="margin-top: 8px;">
                            <img src="${stickerUrl}"
                                 alt="Sticker"
                                 style="max-width: 150px; max-height: 150px;"
                                 loading="lazy"
                                 onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color:#9ca3af;\\'>ğŸ§¸ Sticker</span>';" />
                        </div>`;
                }
                // Sticker with sticker_id (alternative Pancake format)
                else if (att.sticker_id && (att.url || att.file_url)) {
                    const stickerUrl = att.url || att.file_url;
                    content += `
                        <div class="chat-sticker-message" style="margin-top: 8px;">
                            <img src="${stickerUrl}"
                                 alt="Sticker"
                                 style="max-width: 150px; max-height: 150px;"
                                 loading="lazy"
                                 onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color:#9ca3af;\\'>ğŸ§¸ Sticker</span>';" />
                        </div>`;
                }
                // Animated sticker (GIF format)
                else if (att.type === 'animated_image_share' && (att.url || att.file_url)) {
                    const gifUrl = att.url || att.file_url;
                    content += `
                        <div class="chat-sticker-message" style="margin-top: 8px;">
                            <img src="${gifUrl}"
                                 alt="GIF Sticker"
                                 style="max-width: 200px; max-height: 200px; border-radius: 8px;"
                                 loading="lazy" />
                        </div>`;
                }
            });
        }

        // Handle reactions display
        let reactionsHTML = '';

        // Collect reactions from attachments (Pancake API format)
        const reactionAttachments = [];
        if (msg.attachments && msg.attachments.length > 0) {
            msg.attachments.forEach(att => {
                if (att.type === 'reaction' && att.emoji) {
                    reactionAttachments.push(att.emoji);
                }
            });
        }

        // Collect reactions from msg.reactions or msg.reaction_summary
        const reactions = msg.reactions || msg.reaction_summary;
        const reactionsArray = [];

        if (reactions && Object.keys(reactions).length > 0) {
            const reactionIcons = {
                'LIKE': 'ğŸ‘',
                'LOVE': 'â¤ï¸',
                'HAHA': 'ğŸ˜†',
                'WOW': 'ğŸ˜®',
                'SAD': 'ğŸ˜¢',
                'ANGRY': 'ğŸ˜ ',
                'CARE': 'ğŸ¤—'
            };

            Object.entries(reactions)
                .filter(([type, count]) => count > 0)
                .forEach(([type, count]) => {
                    const emoji = reactionIcons[type] || 'ğŸ‘';
                    reactionsArray.push(`<span style="display: inline-flex; align-items: center; background: #fef3c7; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-right: 4px;">
                        ${emoji} ${count > 1 ? count : ''}
                    </span>`);
                });
        }

        // Add reactions from attachments
        if (reactionAttachments.length > 0) {
            reactionAttachments.forEach(emoji => {
                reactionsArray.push(`<span style="display: inline-flex; align-items: center; background: #fef3c7; padding: 2px 8px; border-radius: 12px; font-size: 14px; margin-right: 4px;">
                    ${emoji}
                </span>`);
            });
        }

        // Build final reactions HTML
        if (reactionsArray.length > 0) {
            reactionsHTML = `<div style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px;">${reactionsArray.join('')}</div>`;
        }

        // Reply button for customer messages
        const messageId = msg.id || msg.Id || null;
        const replyButton = !isOwner && messageId ? `
            <span class="message-reply-btn"
                  onclick="window.setReplyMessageById('${messageId}')"
                  style="cursor: pointer; color: #3b82f6; margin-left: 8px; font-weight: 500;">
                Tráº£ lá»i
            </span>
        ` : '';

        // Avatar HTML - only show for customer messages (not owner)
        const avatarHTML = !isOwner ? `
            <img src="${avatarUrl}"
                 alt="${senderName}"
                 title="Click Ä‘á»ƒ phÃ³ng to - ${senderName}"
                 class="avatar-loading chat-avatar-clickable"
                 style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-right: 12px; border: 2px solid #e5e7eb; background: #f3f4f6; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;"
                 onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'"
                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'"
                 onclick="openAvatarZoom('${avatarUrl}', '${senderName.replace(/'/g, "\\'")}'); event.stopPropagation();"
                 onload="this.classList.remove('avatar-loading')"
                 onerror="this.classList.remove('avatar-loading'); this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><circle cx=%2224%22 cy=%2224%22 r=%2224%22 fill=%22%23e5e7eb%22/><circle cx=%2224%22 cy=%2218%22 r=%228%22 fill=%22%239ca3af%22/><ellipse cx=%2224%22 cy=%2238%22 rx=%2213%22 ry=%2210%22 fill=%22%239ca3af%22/></svg>'"
            />
        ` : '';

        return `
            <div class="chat-message ${alignClass}" style="display: flex; align-items: flex-start;">
                ${!isOwner ? avatarHTML : ''}
                <div style="flex: 1; ${isOwner ? 'display: flex; justify-content: flex-end;' : ''}">
                    <div class="chat-bubble ${bgClass}">
                        ${!isOwner && senderName ? `<p style="font-size: 11px; font-weight: 600; color: #6b7280; margin: 0 0 4px 0;">${senderName}</p>` : ''}
                        ${isOwner && adminName ? `<p style="font-size: 10px; font-weight: 500; color: #9ca3af; margin: 0 0 4px 0; text-align: right;"><i class="fas fa-user-tie" style="margin-right: 4px; font-size: 9px;"></i>${adminName}</p>` : ''}
                        ${content}
                        ${reactionsHTML}
                        <p class="chat-message-time">
                            ${formatTime(msg.inserted_at || msg.CreatedTime)}
                            ${replyButton}
                        </p>
                    </div>
                </div>
            </div>`;
    }).join('');

    // Add loading indicator at top based on pagination state
    let loadingIndicator = '';
    if (currentChatCursor) {
        // Still have more messages to load
        loadingIndicator = `
            <div id="chatLoadMoreIndicator" style="
                text-align: center;
                padding: 16px 12px;
                color: #6b7280;
                font-size: 13px;
                background: linear-gradient(to bottom, #f9fafb 0%, transparent 100%);
                border-bottom: 1px solid #e5e7eb;
                margin-bottom: 8px;
            ">
                <i class="fas fa-arrow-up" style="margin-right: 6px; color: #3b82f6;"></i>
                <span style="font-weight: 500;">Cuá»™n lÃªn Ä‘á»ƒ táº£i thÃªm tin nháº¯n</span>
            </div>`;
    } else if (window.allChatMessages.length > 0 && !currentChatCursor) {
        // No more messages (reached the beginning)
        loadingIndicator = `
            <div style="
                text-align: center;
                padding: 16px 12px;
                color: #9ca3af;
                font-size: 12px;
                background: #f9fafb;
                border-bottom: 1px solid #e5e7eb;
                margin-bottom: 8px;
            ">
                <i class="fas fa-check-circle" style="margin-right: 6px; color: #10b981;"></i>
                ÄÃ£ táº£i háº¿t tin nháº¯n cÅ©
            </div>`;
    }

    // Check if user is at bottom before render (within 100px threshold)
    // CHANGED: Check scrollToBottom parameter OR current position
    const wasAtBottom = scrollToBottom || (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100);
    const previousScrollHeight = modalBody.scrollHeight;
    const previousScrollTop = modalBody.scrollTop;

    modalBody.innerHTML = `<div class="chat-messages-container">${loadingIndicator}${messagesHTML}</div>`;

    // Only auto-scroll if explicitly requested OR user was already at bottom
    if (wasAtBottom) {
        // Use requestAnimationFrame to ensure DOM has updated before scrolling
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                modalBody.scrollTop = modalBody.scrollHeight;
                // Hide new message indicator when scrolled to bottom
                const indicator = document.getElementById('chatNewMessageIndicator');
                if (indicator) indicator.style.display = 'none';
            });
        });
    } else {
        // Preserve scroll position (adjust for new content added at top)
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                const newScrollHeight = modalBody.scrollHeight;
                const heightDiff = newScrollHeight - previousScrollHeight;
                modalBody.scrollTop = previousScrollTop + heightDiff;

                // Show new message indicator if there's new content at bottom
                if (heightDiff > 0) {
                    showNewMessageIndicator();
                }
            });
        });
    }
}

function renderComments(comments, scrollToBottom = false) {
    const modalBody = document.getElementById('chatModalBody');

    if (!comments || comments.length === 0) {
        modalBody.innerHTML = `
            <div class="chat-empty">
                <i class="fas fa-comments"></i>
                <p>ChÆ°a cÃ³ bÃ¬nh luáº­n</p>
            </div>`;
        return;
    }

    // Format time helper - use global formatTimeVN
    const formatTime = window.formatTimeVN;

    // Sort comments by timestamp - oldest first (newest at bottom like Messenger/Zalo)
    const sortedComments = comments.slice().sort((a, b) => {
        const timeA = new Date(a.CreatedTime || a.updated_at || a.created_at || 0).getTime();
        const timeB = new Date(b.CreatedTime || b.updated_at || b.created_at || 0).getTime();
        return timeA - timeB; // Ascending: oldest first, newest last (at bottom)
    });

    // Helper function to check if comment is the purchase comment
    const isPurchaseComment = (comment) => {
        if (!window.purchaseCommentId) return false;

        // Get comment ID (handle different formats)
        const commentId = comment.FacebookId || comment.OriginalId || comment.Id || comment.id;

        // Facebook_CommentId format: "postId_commentId" (e.g., "1672237127083024_2168976250601862")
        // Extract just the comment ID part for comparison
        const purchaseIdParts = window.purchaseCommentId.split('_');
        const purchaseCommentOnlyId = purchaseIdParts.length > 1 ? purchaseIdParts[purchaseIdParts.length - 1] : window.purchaseCommentId;

        // Check if this comment matches the purchase comment
        if (commentId === window.purchaseCommentId) return true;
        if (commentId === purchaseCommentOnlyId) return true;

        // Also check if commentId contains the purchase comment ID
        if (commentId && commentId.includes(purchaseCommentOnlyId)) return true;

        // Check full format match (postId_commentId)
        // Support both uppercase (PostId) and lowercase (post_id) field names from Pancake API
        const fullCommentId = `${comment.PostId || comment.post_id || ''}_${commentId}`;
        if (fullCommentId === window.purchaseCommentId) return true;

        return false;
    };

    const commentsHTML = sortedComments.map(comment => {
        // Handle both old format (IsOwner) and Pancake API format (is_owner)
        const isOwner = comment.IsOwner || comment.is_owner || false;
        const alignClass = isOwner ? 'chat-message-right' : 'chat-message-left';
        const bgClass = isOwner ? 'chat-bubble-owner' : 'chat-bubble-customer';

        // Get avatar URL for comments (same logic as messages)
        const cachedToken = window.pancakeTokenManager?.token || null;
        const pageId = window.currentChatChannelId || comment.page_id || null;
        const fromId = comment.from?.id || comment.FromId || null;
        const directAvatar = comment.from?.avatar || comment.from?.picture || comment.from?.profile_picture || comment.avatar || null;
        const avatarUrl = window.pancakeDataManager?.getAvatarUrl(fromId, pageId, cachedToken, directAvatar) ||
            'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle cx="20" cy="20" r="20" fill="%23e5e7eb"/><circle cx="20" cy="15" r="7" fill="%239ca3af"/><ellipse cx="20" cy="32" rx="11" ry="8" fill="%239ca3af"/></svg>';
        const senderName = comment.from?.name || comment.FromName || '';

        // Check if this is the purchase comment (comment where user made the order)
        const isPurchase = isPurchaseComment(comment);
        const purchaseHighlightClass = isPurchase ? 'purchase-comment-highlight' : '';
        const purchaseBadge = isPurchase ? '<span class="purchase-badge"><i class="fas fa-shopping-cart"></i> BÃ¬nh luáº­n Ä‘áº·t hÃ ng</span>' : '';

        let content = '';
        // Handle both old format (Message) and Pancake API format (message)
        const messageText = comment.Message || comment.message || '';
        if (messageText) {
            content = `<p class="chat-message-text">${messageText}</p>`;
        }

        // Handle attachments (images and audio) for comments
        if (comment.Attachments && comment.Attachments.length > 0) {
            comment.Attachments.forEach(att => {
                if (att.Type === 'image' && att.Payload && att.Payload.Url) {
                    content += `<img src="${att.Payload.Url}" class="chat-message-image" loading="lazy" />`;
                } else if (att.Type === 'audio' && att.Payload && att.Payload.Url) {
                    content += `
                        <div class="chat-audio-message">
                            <i class="fas fa-microphone" style="color: #3b82f6; margin-right: 8px;"></i>
                            <audio controls style="max-width: 100%; height: 32px;">
                                <source src="${att.Payload.Url}" type="audio/mp4">
                                TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t audio
                            </audio>
                        </div>`;
                }
            });
        }

        // Handle Pancake API format attachments for comments
        if (comment.attachments && comment.attachments.length > 0) {
            comment.attachments.forEach(att => {
                if (att.mime_type === 'audio/mp4' && att.file_url) {
                    content += `
                        <div class="chat-audio-message">
                            <i class="fas fa-microphone" style="color: #3b82f6; margin-right: 8px;"></i>
                            <audio controls style="max-width: 100%; height: 32px;">
                                <source src="${att.file_url}" type="audio/mp4">
                                TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t audio
                            </audio>
                        </div>`;
                } else if (att.mime_type && att.mime_type.startsWith('image/') && att.file_url) {
                    content += `<img src="${att.file_url}" class="chat-message-image" loading="lazy" />`;
                }
            });
        }

        // Status badge for unread comments
        const statusBadge = comment.Status === 30
            ? '<span style="background: #f59e0b; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">Má»›i</span>'
            : '';

        // Render nested replies if any
        let repliesHTML = '';
        if (comment.Messages && comment.Messages.length > 0) {
            repliesHTML = comment.Messages.map(reply => {
                // Handle both old format (IsOwner) and Pancake API format (is_owner)
                const replyIsOwner = reply.IsOwner || reply.is_owner || false;
                const replyAlignClass = replyIsOwner ? 'chat-message-right' : 'chat-message-left';
                const replyBgClass = replyIsOwner ? 'chat-bubble-owner' : 'chat-bubble-customer';

                // Get avatar URL for reply
                const replyFromId = reply.from?.id || reply.FromId || null;
                const replyDirectAvatar = reply.from?.avatar || reply.from?.picture || reply.from?.profile_picture || reply.avatar || null;
                const replyAvatarUrl = window.pancakeDataManager?.getAvatarUrl(replyFromId, pageId, cachedToken, replyDirectAvatar) ||
                    'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle cx="20" cy="20" r="20" fill="%23e5e7eb"/><circle cx="20" cy="15" r="7" fill="%239ca3af"/><ellipse cx="20" cy="32" rx="11" ry="8" fill="%239ca3af"/></svg>';
                const replySenderName = reply.from?.name || reply.FromName || '';

                let replyContent = '';
                // Handle both old format (Message) and Pancake API format (message)
                const replyMessageText = reply.Message || reply.message || '';
                if (replyMessageText) {
                    replyContent = `<p class="chat-message-text">${replyMessageText}</p>`;
                }

                // Handle attachments in replies
                if (reply.Attachments && reply.Attachments.length > 0) {
                    reply.Attachments.forEach(att => {
                        if (att.Type === 'image' && att.Payload && att.Payload.Url) {
                            replyContent += `<img src="${att.Payload.Url}" class="chat-message-image" loading="lazy" />`;
                        } else if (att.Type === 'audio' && att.Payload && att.Payload.Url) {
                            replyContent += `
                                <div class="chat-audio-message">
                                    <i class="fas fa-microphone" style="color: #3b82f6; margin-right: 8px;"></i>
                                    <audio controls style="max-width: 100%; height: 32px;">
                                        <source src="${att.Payload.Url}" type="audio/mp4">
                                        TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t audio
                                    </audio>
                                </div>`;
                        }
                    });
                }

                // Handle Pancake API format in replies
                if (reply.attachments && reply.attachments.length > 0) {
                    reply.attachments.forEach(att => {
                        if (att.mime_type === 'audio/mp4' && att.file_url) {
                            replyContent += `
                                <div class="chat-audio-message">
                                    <i class="fas fa-microphone" style="color: #3b82f6; margin-right: 8px;"></i>
                                    <audio controls style="max-width: 100%; height: 32px;">
                                        <source src="${att.file_url}" type="audio/mp4">
                                        TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t audio
                                    </audio>
                                </div>`;
                        } else if (att.mime_type && att.mime_type.startsWith('image/') && att.file_url) {
                            replyContent += `<img src="${att.file_url}" class="chat-message-image" loading="lazy" />`;
                        }
                    });
                }

                // Handle both old format (CreatedTime) and Pancake API format (inserted_at/created_at/updated_at)
                const replyTimestamp = reply.inserted_at || reply.CreatedTime || reply.created_at || reply.updated_at || new Date();

                // Avatar HTML for reply
                const replyAvatarHTML = !replyIsOwner ? `
                    <img src="${replyAvatarUrl}"
                         alt="${replySenderName}"
                         style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-right: 8px; border: 2px solid #e5e7eb; background: #f3f4f6;"
                         onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 32 32%22><circle cx=%2216%22 cy=%2216%22 r=%2216%22 fill=%22%23e5e7eb%22/><circle cx=%2216%22 cy=%2212%22 r=%225%22 fill=%22%239ca3af%22/><ellipse cx=%2216%22 cy=%2224%22 rx=%228%22 ry=%226%22 fill=%22%239ca3af%22/></svg>'"
                    />
                ` : '';

                return `
                    <div class="chat-message ${replyAlignClass}" style="margin-left: 24px; margin-top: 8px; display: flex; align-items: flex-start;">
                        ${!replyIsOwner ? replyAvatarHTML : ''}
                        <div style="flex: 1; ${replyIsOwner ? 'display: flex; justify-content: flex-end;' : ''}">
                            <div class="chat-bubble ${replyBgClass}" style="font-size: 13px;">
                                ${!replyIsOwner && replySenderName ? `<p style="font-size: 10px; font-weight: 600; color: #6b7280; margin: 0 0 4px 0;">${replySenderName}</p>` : ''}
                                ${replyContent}
                                <p class="chat-message-time">${formatTime(replyTimestamp)}</p>
                            </div>
                        </div>
                    </div>`;
            }).join('');
        }

        // Handle both old format (CreatedTime) and Pancake API format (inserted_at/created_at/updated_at)
        const timestamp = comment.inserted_at || comment.CreatedTime || comment.created_at || comment.updated_at || new Date();

        // Avatar HTML - only show for customer comments (not owner)
        const avatarHTML = !isOwner ? `
            <img src="${avatarUrl}"
                 alt="${senderName}"
                 title="Click Ä‘á»ƒ phÃ³ng to - ${senderName}"
                 class="avatar-loading chat-avatar-clickable"
                 style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-right: 12px; border: 2px solid #e5e7eb; background: #f3f4f6; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;"
                 onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'"
                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'"
                 onclick="openAvatarZoom('${avatarUrl}', '${senderName.replace(/'/g, "\\'")}'); event.stopPropagation();"
                 onload="this.classList.remove('avatar-loading')"
                 onerror="this.classList.remove('avatar-loading'); this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><circle cx=%2224%22 cy=%2224%22 r=%2224%22 fill=%22%23e5e7eb%22/><circle cx=%2224%22 cy=%2218%22 r=%228%22 fill=%22%239ca3af%22/><ellipse cx=%2224%22 cy=%2238%22 rx=%2213%22 ry=%2210%22 fill=%22%239ca3af%22/></svg>'"
            />
        ` : '';

        return `
            <div class="chat-message ${alignClass} ${purchaseHighlightClass}" data-comment-id="${comment.Id || comment.id || ''}" style="display: flex; align-items: flex-start;">
                ${!isOwner ? avatarHTML : ''}
                <div style="flex: 1; ${isOwner ? 'display: flex; justify-content: flex-end;' : ''}">
                    ${purchaseBadge}
                    <div class="chat-bubble ${bgClass}">
                        ${!isOwner && senderName ? `<p style="font-size: 11px; font-weight: 600; color: #6b7280; margin: 0 0 4px 0;">${senderName}</p>` : ''}
                        ${content}
                        <p class="chat-message-time">
                            ${formatTime(timestamp)} ${statusBadge}
                            ${!isOwner ? `<span class="reply-btn" onclick="handleReplyToComment('${comment.Id || comment.id}', '${comment.PostId || comment.post_id || ''}')" style="cursor: pointer; color: #3b82f6; margin-left: 8px; font-weight: 500;">Tráº£ lá»i</span>` : ''}
                        </p>
                    </div>
                </div>
            </div>
            ${repliesHTML}`;
    }).join('');

    // Add loading indicator at top based on pagination state
    let loadingIndicator = '';
    if (currentChatCursor) {
        // Still have more comments to load
        loadingIndicator = `
            <div id="chatLoadMoreIndicator" style="
                text-align: center;
                padding: 16px 12px;
                color: #6b7280;
                font-size: 13px;
                background: linear-gradient(to bottom, #f9fafb 0%, transparent 100%);
                border-bottom: 1px solid #e5e7eb;
                margin-bottom: 8px;
            ">
                <i class="fas fa-arrow-up" style="margin-right: 6px; color: #3b82f6;"></i>
                <span style="font-weight: 500;">Cuá»™n lÃªn Ä‘á»ƒ táº£i thÃªm bÃ¬nh luáº­n</span>
            </div>`;
    } else if (window.allChatComments.length > 0 && !currentChatCursor) {
        // No more comments (reached the beginning)
        loadingIndicator = `
            <div style="
                text-align: center;
                padding: 16px 12px;
                color: #9ca3af;
                font-size: 12px;
                background: #f9fafb;
                border-bottom: 1px solid #e5e7eb;
                margin-bottom: 8px;
            ">
                <i class="fas fa-check-circle" style="margin-right: 6px; color: #10b981;"></i>
                ÄÃ£ táº£i háº¿t bÃ¬nh luáº­n cÅ©
            </div>`;
    }

    // Add post/video context at the top if available
    let postContext = '';
    if (comments[0] && comments[0].Object) {
        const obj = comments[0].Object;
        postContext = `
            <div style="
                background: #f9fafb;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 16px;
            ">
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">
                    <i class="fas fa-video"></i> ${obj.ObjectType === 1 ? 'Video' : 'BÃ i viáº¿t'} Live
                </div>
                <div style="font-size: 13px; font-weight: 500; color: #1f2937;">
                    ${obj.Description || obj.Title || 'KhÃ´ng cÃ³ mÃ´ táº£'}
                </div>
            </div>`;
    }

    // Check if user is at bottom before render (within 100px threshold)
    // CHANGED: Check scrollToBottom parameter OR current position
    const wasAtBottom = scrollToBottom || (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100);
    const previousScrollHeight = modalBody.scrollHeight;
    const previousScrollTop = modalBody.scrollTop;

    modalBody.innerHTML = `<div class="chat-messages-container">${loadingIndicator}${postContext}${commentsHTML}</div>`;

    // Check if there's a purchase comment to scroll to (only on initial load)
    const purchaseCommentElement = modalBody.querySelector('.purchase-comment-highlight');

    // Only auto-scroll if explicitly requested OR user was already at bottom
    if (wasAtBottom) {
        // Use requestAnimationFrame to ensure DOM has updated before scrolling
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                // Priority: scroll to purchase comment if exists, otherwise scroll to bottom
                if (purchaseCommentElement && scrollToBottom) {
                    // Scroll to purchase comment with smooth behavior
                    purchaseCommentElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    console.log('[CHAT] Scrolled to purchase comment');
                } else {
                    modalBody.scrollTop = modalBody.scrollHeight;
                }
                // Hide new message indicator when scrolled to bottom
                const indicator = document.getElementById('chatNewMessageIndicator');
                if (indicator) indicator.style.display = 'none';
            });
        });
    } else {
        // Preserve scroll position (adjust for new content added at top)
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                const newScrollHeight = modalBody.scrollHeight;
                const heightDiff = newScrollHeight - previousScrollHeight;
                modalBody.scrollTop = previousScrollTop + heightDiff;

                // Show new message indicator if there's new content at bottom
                if (heightDiff > 0) {
                    showNewMessageIndicator();
                }
            });
        });
    }
}

// =====================================================
// NEW MESSAGE INDICATOR
// =====================================================

/**
 * Show visual indicator for new messages (without flash animation)
 */
function showNewMessageIndicator() {
    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) return;

    // Check if indicator already exists
    let indicator = document.getElementById('chatNewMessageIndicator');

    if (!indicator) {
        // Create indicator element
        indicator = document.createElement('div');
        indicator.id = 'chatNewMessageIndicator';
        indicator.innerHTML = `
            <div style="
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                padding: 10px 20px;
                background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                color: white;
                border-radius: 24px;
                font-size: 13px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(59, 130, 246, 0.5)';"
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.4)';">
                <i class="fas fa-arrow-down" style="font-size: 12px;"></i>
                <span>Tin nháº¯n má»›i</span>
            </div>
        `;

        // Position indicator at bottom center
        indicator.style.cssText = `
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: none;
        `;

        // Scroll to bottom when clicked
        indicator.onclick = () => {
            modalBody.scrollTo({
                top: modalBody.scrollHeight,
                behavior: 'smooth'
            });
            indicator.style.display = 'none';
        };

        // Append to modal body's parent to position it correctly
        const chatModal = document.getElementById('chatModal');
        const modalContent = chatModal?.querySelector('.modal-body');
        if (modalContent) {
            modalContent.style.position = 'relative';
            modalContent.appendChild(indicator);
        }
    }

    // Show indicator with smooth appearance (no flash)
    indicator.style.display = 'block';
}

/**
 * Setup scroll listener to auto-hide indicator when user scrolls to bottom
 */
function setupNewMessageIndicatorListener() {
    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) return;

    modalBody.addEventListener('scroll', () => {
        const isAtBottom = (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100);
        const indicator = document.getElementById('chatNewMessageIndicator');

        if (indicator && isAtBottom) {
            indicator.style.display = 'none';
        }
    });
}

// =====================================================
// REALTIME MESSAGES - FACEBOOK API INTEGRATION
// =====================================================

/**
 * Global variables for realtime messages
 */
window.realtimeMessagesInterval = null;
window.realtimeMessagesHandler = null;
window.lastMessageTimestamp = null;
const REALTIME_POLL_INTERVAL = 10000; // 10 seconds polling interval

/**
 * Setup realtime messages when chat modal opens
 * Uses both WebSocket events and polling as backup
 */
function setupRealtimeMessages() {
    console.log('[REALTIME-MSG] Setting up realtime messages...');

    // Cleanup any existing listeners first
    cleanupRealtimeMessages();

    // 1. Listen for WebSocket events from RealtimeManager
    window.realtimeMessagesHandler = handleRealtimeConversationEvent;
    window.addEventListener('realtimeConversationUpdate', window.realtimeMessagesHandler);
    console.log('[REALTIME-MSG] WebSocket event listener added');

    // 2. Start polling as backup (only if WebSocket is not connected)
    // Polling is disabled by default since we have WebSocket realtime
    // startRealtimePolling();
}

/**
 * Handle realtime conversation update from WebSocket
 * Trá»±c tiáº¿p láº¥y tin nháº¯n tá»« WebSocket payload, khÃ´ng cáº§n gá»i API
 * @param {CustomEvent} event - Event with conversation data
 */
async function handleRealtimeConversationEvent(event) {
    const conversation = event.detail;
    if (!conversation) return;

    // Check if this update is for the current conversation
    const currentConvId = window.currentConversationId;
    const currentPSID = window.currentChatPSID;
    const currentChannelId = window.currentChatChannelId;

    // Match by conversation ID or by page_id + customer PSID
    const isMatchingConv = (conversation.id === currentConvId) ||
        (conversation.page_id === currentChannelId &&
            (conversation.from?.id === currentPSID || conversation.from_psid === currentPSID));

    if (!isMatchingConv) {
        // Log quietly - this is expected for updates to other conversations
        return;
    }

    console.log('[REALTIME-MSG] âš¡ Received realtime update for current conversation:', conversation.id);

    // Try to get the new message directly from WebSocket payload
    const lastMessage = conversation.last_message || conversation.message;

    if (lastMessage && lastMessage.id) {
        // Check if this message already exists
        const existingIds = new Set(window.allChatMessages.map(m => m.id || m.Id));

        if (!existingIds.has(lastMessage.id)) {
            console.log('[REALTIME-MSG] âš¡ Adding message directly from WebSocket:', lastMessage.id);

            // Add the new message directly (instant realtime!)
            window.allChatMessages.push(lastMessage);

            // Update timestamp
            window.lastMessageTimestamp = lastMessage.inserted_at || lastMessage.created_time;

            // Check if user is at bottom before updating
            const modalBody = document.getElementById('chatModalBody');
            const wasAtBottom = modalBody &&
                (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100);

            // Re-render messages
            renderChatMessages(window.allChatMessages, wasAtBottom);

            // Show indicator if not at bottom
            if (!wasAtBottom) {
                showNewMessageIndicator();
            }

            // Play notification sound
            playNewMessageSound();

            return; // Done - no need to call API
        } else {
            console.log('[REALTIME-MSG] Message already exists:', lastMessage.id);
            return;
        }
    }

    // Fallback: If last_message not in payload, check snippet
    // This means we only got a notification, need to fetch the full message
    if (conversation.snippet) {
        console.log('[REALTIME-MSG] WebSocket has snippet but not full message, fetching via API...');
        await fetchAndUpdateMessages();
    }
}

/**
 * Start polling for new messages
 */
function startRealtimePolling() {
    // Clear any existing interval
    if (window.realtimeMessagesInterval) {
        clearInterval(window.realtimeMessagesInterval);
    }

    // Store initial timestamp
    if (window.allChatMessages && window.allChatMessages.length > 0) {
        const latestMsg = window.allChatMessages.reduce((latest, msg) => {
            const msgTime = new Date(msg.inserted_at || msg.CreatedTime || 0).getTime();
            const latestTime = new Date(latest.inserted_at || latest.CreatedTime || 0).getTime();
            return msgTime > latestTime ? msg : latest;
        });
        window.lastMessageTimestamp = latestMsg.inserted_at || latestMsg.CreatedTime;
    }

    console.log('[REALTIME-MSG] Starting polling every', REALTIME_POLL_INTERVAL / 1000, 'seconds');

    // Start polling
    window.realtimeMessagesInterval = setInterval(async () => {
        // Only poll if chat modal is open
        const chatModal = document.getElementById('chatModal');
        if (!chatModal || !chatModal.classList.contains('show')) {
            console.log('[REALTIME-MSG] Chat modal closed, stopping poll');
            cleanupRealtimeMessages();
            return;
        }

        // Only poll for message type (not comments)
        if (currentChatType !== 'message') {
            return;
        }

        await fetchAndUpdateMessages();
    }, REALTIME_POLL_INTERVAL);
}

/**
 * Fetch latest messages using Facebook Graph API via Pancake
 * Only fetches new messages since last update
 */
async function fetchAndUpdateMessages() {
    if (!window.currentChatChannelId || !window.currentChatPSID) {
        return;
    }

    // Prevent concurrent fetches
    if (window.isFetchingRealtimeMessages) {
        console.log('[REALTIME-MSG] Already fetching, skipping...');
        return;
    }

    window.isFetchingRealtimeMessages = true;

    try {
        console.log('[REALTIME-MSG] Fetching latest messages...');

        // Try Facebook Graph API first if we have page token
        let newMessages = [];
        const facebookPageToken = await getFacebookPageToken();

        if (facebookPageToken && window.currentConversationId) {
            // Use Facebook Graph API directly
            newMessages = await fetchMessagesFromFacebookAPI(facebookPageToken);
        } else {
            // Fallback to Pancake API
            const response = await window.chatDataManager.fetchMessages(
                window.currentChatChannelId,
                window.currentChatPSID,
                window.currentConversationId,
                window.currentCustomerUUID
            );
            newMessages = response.messages || [];
        }

        if (newMessages.length === 0) {
            console.log('[REALTIME-MSG] No messages returned');
            window.isFetchingRealtimeMessages = false;
            return;
        }

        // Find truly new messages by comparing IDs
        const existingIds = new Set(window.allChatMessages.map(m => m.id || m.Id));
        const trulyNewMessages = newMessages.filter(msg => {
            const msgId = msg.id || msg.Id;
            return msgId && !existingIds.has(msgId);
        });

        if (trulyNewMessages.length > 0) {
            console.log('[REALTIME-MSG] Found', trulyNewMessages.length, 'new messages');

            // Add new messages to the array
            window.allChatMessages = [...window.allChatMessages, ...trulyNewMessages];

            // Update timestamp
            const latestMsg = trulyNewMessages.reduce((latest, msg) => {
                const msgTime = new Date(msg.inserted_at || msg.CreatedTime || 0).getTime();
                const latestTime = new Date(latest.inserted_at || latest.CreatedTime || 0).getTime();
                return msgTime > latestTime ? msg : latest;
            });
            window.lastMessageTimestamp = latestMsg.inserted_at || latestMsg.CreatedTime;

            // Check if user is at bottom before updating
            const modalBody = document.getElementById('chatModalBody');
            const wasAtBottom = modalBody &&
                (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100);

            // Re-render messages
            renderChatMessages(window.allChatMessages, wasAtBottom);

            // Show indicator if not at bottom
            if (!wasAtBottom) {
                showNewMessageIndicator();
            }

            // Play notification sound if available
            playNewMessageSound();
        } else {
            console.log('[REALTIME-MSG] No new messages to display');
        }

    } catch (error) {
        console.error('[REALTIME-MSG] Error fetching messages:', error);
    } finally {
        window.isFetchingRealtimeMessages = false;
    }
}

/**
 * Get Facebook Page Token from various sources
 * @returns {string|null} Facebook Page Token
 */
async function getFacebookPageToken() {
    // Try CRMTeam first
    if (window.currentCRMTeam && window.currentCRMTeam.Facebook_PageToken) {
        return window.currentCRMTeam.Facebook_PageToken;
    }

    // Try current order
    if (window.currentOrder && window.currentOrder.CRMTeam && window.currentOrder.CRMTeam.Facebook_PageToken) {
        return window.currentOrder.CRMTeam.Facebook_PageToken;
    }

    // Try pancake token manager
    if (window.pancakeTokenManager && window.currentChatChannelId) {
        const pageAccessToken = await window.pancakeTokenManager.getOrGeneratePageAccessToken(window.currentChatChannelId);
        return pageAccessToken;
    }

    return null;
}

/**
 * Fetch messages directly from Facebook Graph API
 * Uses the conversation endpoint with page access token
 * @param {string} pageToken - Facebook Page Token
 * @returns {Array} Messages array
 */
async function fetchMessagesFromFacebookAPI(pageToken) {
    try {
        // Build the Facebook Graph API URL
        // GET /{conversation-id}/messages?access_token={page_token}
        const conversationId = window.currentConversationId;

        if (!conversationId) {
            console.warn('[REALTIME-MSG] No conversation ID for Facebook API call');
            return [];
        }

        // Use Pancake Official API which proxies to Facebook
        // This respects the same format and avoids CORS issues
        const pageAccessToken = await window.pancakeTokenManager?.getOrGeneratePageAccessToken(window.currentChatChannelId);

        if (!pageAccessToken) {
            console.warn('[REALTIME-MSG] No page access token for Facebook API');
            return [];
        }

        // Build URL using existing API config
        let extraParams = '';
        if (window.currentCustomerUUID) {
            extraParams = `&customer_id=${window.currentCustomerUUID}`;
        }

        const url = window.API_CONFIG.buildUrl.pancakeOfficial(
            `pages/${window.currentChatChannelId}/conversations/${conversationId}/messages`,
            pageAccessToken
        ) + extraParams;

        console.log('[REALTIME-MSG] Calling Facebook API via Pancake:', url.substring(0, 100) + '...');

        const response = await API_CONFIG.smartFetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }, 2, true); // 2 retries, skip fallback

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log('[REALTIME-MSG] Facebook API returned', data.messages?.length || 0, 'messages');

        return data.messages || [];

    } catch (error) {
        console.error('[REALTIME-MSG] Error calling Facebook API:', error);
        return [];
    }
}

/**
 * Play notification sound for new messages
 */
function playNewMessageSound() {
    try {
        // Create a simple beep sound using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = 800; // Frequency in Hz
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Low volume
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
    } catch (e) {
        // Silently fail if audio not supported
    }
}

/**
 * Cleanup realtime messages listeners and intervals
 */
function cleanupRealtimeMessages() {
    console.log('[REALTIME-MSG] Cleaning up realtime messages...');

    // Remove WebSocket event listener
    if (window.realtimeMessagesHandler) {
        window.removeEventListener('realtimeConversationUpdate', window.realtimeMessagesHandler);
        window.realtimeMessagesHandler = null;
    }

    // Clear polling interval
    if (window.realtimeMessagesInterval) {
        clearInterval(window.realtimeMessagesInterval);
        window.realtimeMessagesInterval = null;
    }

    // Reset state
    window.lastMessageTimestamp = null;
    window.isFetchingRealtimeMessages = false;
}

// Expose for external use
window.setupRealtimeMessages = setupRealtimeMessages;
window.cleanupRealtimeMessages = cleanupRealtimeMessages;
window.fetchAndUpdateMessages = fetchAndUpdateMessages;

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                       SECTION 13: INFINITE SCROLL                           â•‘
// â•‘                            search: #SCROLL                                  â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// SCROLL TO MESSAGE FUNCTION
// =====================================================

/**
 * Scroll to a specific message in the chat modal and highlight it
 * @param {string} messageId - The ID of the message to scroll to
 */
window.scrollToMessage = function (messageId) {
    if (!messageId) return;

    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) return;

    // Find message element by data-message-id attribute
    const messageElement = modalBody.querySelector(`[data-message-id="${messageId}"]`);

    if (messageElement) {
        // Scroll to message
        messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Add highlight animation
        messageElement.classList.add('message-highlight');

        // Remove highlight after animation
        setTimeout(() => {
            messageElement.classList.remove('message-highlight');
        }, 2000);
    } else {
        console.log('[SCROLL] Message not found:', messageId);
        // Message might not be loaded yet - show notification
        showToast && showToast('Tin nháº¯n khÃ´ng tÃ¬m tháº¥y trong cuá»™c há»™i thoáº¡i hiá»‡n táº¡i', 'warning');
    }
};

// =====================================================
// INFINITE SCROLL FOR MESSAGES & COMMENTS #SCROLL
// =====================================================

function setupChatInfiniteScroll() {
    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) return;

    // Remove existing listener to avoid duplicates
    modalBody.removeEventListener('scroll', handleChatScroll);

    // Add scroll listener
    modalBody.addEventListener('scroll', handleChatScroll);
}

async function handleChatScroll(event) {
    const modalBody = event.target;

    // Check if scrolled to top (or near top)
    const isNearTop = modalBody.scrollTop < 100;

    // Only load more if:
    // 1. Near the top of the scroll
    // 2. Not already loading
    // Note: For MESSAGE, we use count-based pagination (no cursor needed)
    //       For COMMENT, we still use cursor-based pagination
    if (isNearTop && !isLoadingMoreMessages) {
        if (currentChatType === 'message') {
            await loadMoreMessages();
        } else if (currentChatType === 'comment' && currentChatCursor) {
            await loadMoreComments();
        }
    }
}

async function loadMoreMessages() {
    if (!window.currentChatChannelId || !window.currentChatPSID) {
        return;
    }

    // Stop if already loading
    if (isLoadingMoreMessages) {
        console.log('[CHAT] Already loading messages, skipping...');
        return;
    }

    isLoadingMoreMessages = true;

    try {
        const modalBody = document.getElementById('chatModalBody');
        const loadMoreIndicator = document.getElementById('chatLoadMoreIndicator');

        // Show loading state with better visual feedback
        if (loadMoreIndicator) {
            loadMoreIndicator.innerHTML = `
                <i class="fas fa-spinner fa-spin" style="margin-right: 8px; color: #3b82f6;"></i>
                <span style="font-weight: 500; color: #3b82f6;">Äang táº£i thÃªm tin nháº¯n...</span>
            `;
            loadMoreIndicator.style.background = 'linear-gradient(to bottom, #eff6ff 0%, transparent 100%)';
        }

        // Use count-based pagination (current_count parameter)
        const currentCount = window.allChatMessages.length;
        console.log(`[CHAT] Loading more messages with current_count: ${currentCount}`);

        // Fetch more messages using count-based pagination
        const response = await window.chatDataManager.fetchMessages(
            window.currentChatChannelId,
            window.currentChatPSID,
            currentCount,  // Pass number for count-based pagination
            window.currentCustomerUUID  // Pass customerId
        );

        // Get scroll height before updating
        const scrollHeightBefore = modalBody.scrollHeight;
        const scrollTopBefore = modalBody.scrollTop;

        // Append older messages to the beginning of the array
        const newMessages = response.messages || [];
        if (newMessages.length > 0) {
            window.allChatMessages = [...window.allChatMessages, ...newMessages];
            console.log(`[CHAT] âœ… Loaded ${newMessages.length} more messages. Total: ${window.allChatMessages.length}`);
        } else {
            console.log(`[CHAT] ğŸ No new messages loaded. Reached the beginning of conversation.`);
        }

        // Re-render with all messages, don't scroll to bottom
        renderChatMessages(window.allChatMessages, false);

        // Restore scroll position (adjust for new content height)
        setTimeout(() => {
            const scrollHeightAfter = modalBody.scrollHeight;
            const heightDifference = scrollHeightAfter - scrollHeightBefore;
            modalBody.scrollTop = scrollTopBefore + heightDifference;
        }, 50);

    } catch (error) {
        console.error('[CHAT] Error loading more messages:', error);
    } finally {
        isLoadingMoreMessages = false;
    }
}

async function loadMoreComments() {
    if (!window.currentChatChannelId || !window.currentChatPSID || !currentChatCursor) {
        return;
    }

    isLoadingMoreMessages = true;

    try {
        const modalBody = document.getElementById('chatModalBody');
        const loadMoreIndicator = document.getElementById('chatLoadMoreIndicator');

        // Show loading state with better visual feedback
        if (loadMoreIndicator) {
            loadMoreIndicator.innerHTML = `
                <i class="fas fa-spinner fa-spin" style="margin-right: 8px; color: #3b82f6;"></i>
                <span style="font-weight: 500; color: #3b82f6;">Äang táº£i thÃªm bÃ¬nh luáº­n...</span>
            `;
            loadMoreIndicator.style.background = 'linear-gradient(to bottom, #eff6ff 0%, transparent 100%)';
        }

        console.log(`[CHAT] Loading more comments with cursor: ${currentChatCursor}`);

        // Fetch more comments using the cursor
        const response = await window.chatDataManager.fetchComments(
            window.currentChatChannelId,
            window.currentChatPSID,
            currentChatCursor
        );

        // Get scroll height before updating
        const scrollHeightBefore = modalBody.scrollHeight;
        const scrollTopBefore = modalBody.scrollTop;

        // Append older comments to the beginning of the array
        const newComments = response.comments || [];
        if (newComments.length > 0) {
            window.allChatComments = [...window.allChatComments, ...newComments];
            console.log(`[CHAT] âœ… Loaded ${newComments.length} more comments. Total: ${window.allChatComments.length}`);
        } else {
            console.log(`[CHAT] âš ï¸ No new comments loaded. Reached end or empty batch.`);
        }

        // Update cursor for next page (null = no more comments)
        currentChatCursor = response.after;
        if (currentChatCursor) {
            console.log(`[CHAT] ğŸ“„ Next cursor available: ${currentChatCursor.substring(0, 20)}...`);
        } else {
            console.log(`[CHAT] ğŸ No more comments. Reached the beginning.`);
        }

        // Re-render with all comments, don't scroll to bottom
        renderComments(window.allChatComments, false);

        // Restore scroll position (adjust for new content height)
        setTimeout(() => {
            const scrollHeightAfter = modalBody.scrollHeight;
            const heightDifference = scrollHeightAfter - scrollHeightBefore;
            modalBody.scrollTop = scrollTopBefore + heightDifference;
        }, 50);

    } catch (error) {
        console.error('[CHAT] Error loading more comments:', error);
    } finally {
        isLoadingMoreMessages = false;
    }
}

window.markChatAsRead = async function () {
    if (!window.currentChatChannelId || !window.currentChatPSID) return;

    try {
        const markReadBtn = document.getElementById('chatMarkReadBtn');
        if (markReadBtn) {
            markReadBtn.disabled = true;
            markReadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Äang xá»­ lÃ½...';
        }

        await window.chatDataManager.markAsSeen(window.currentChatChannelId, window.currentChatPSID);

        // Hide button
        if (markReadBtn) {
            markReadBtn.style.display = 'none';
            markReadBtn.disabled = false;
            markReadBtn.innerHTML = '<i class="fas fa-check"></i> ÄÃ¡nh dáº¥u Ä‘Ã£ Ä‘á»c';
        }

        // Re-render table to update UI
        renderTable();

        if (window.notificationManager) {
            window.notificationManager.success('ÄÃ£ Ä‘Ã¡nh dáº¥u tin nháº¯n lÃ  Ä‘Ã£ Ä‘á»c', 2000);
        }
    } catch (error) {
        console.error('[CHAT] Error marking as read:', error);
        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i khi Ä‘Ã¡nh dáº¥u Ä‘Ã£ Ä‘á»c: ' + error.message, 3000);
        }
    }
}

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                   SECTION 14: NOTE ENCODING/DECODING                        â•‘
// â•‘                            search: #ENCODE                                  â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// PRODUCT ENCODING/DECODING UTILITIES (for Note verification) #ENCODE
// =====================================================
const ENCODE_KEY = 'live';
const BASE_TIME = 1704067200000; // 2024-01-01 00:00:00 UTC

/**
 * Base64URL decode
 * @param {string} str - Base64URL encoded string
 * @returns {string} Decoded string
 */
function base64UrlDecode(str) {
    const padding = '='.repeat((4 - str.length % 4) % 4);
    const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;
    const binary = atob(base64);
    return new TextDecoder().decode(
        Uint8Array.from(binary, c => c.charCodeAt(0))
    );
}

/**
 * Generate short checksum (6 characters)
 * @param {string} str - String to checksum
 * @returns {string} Checksum in base36 (6 chars)
 */
function shortChecksum(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36).substring(0, 6);
}

/**
 * XOR decryption with key
 * @param {string} encoded - Base64 encoded encrypted text
 * @param {string} key - Decryption key
 * @returns {string} Decrypted text
 */
function xorDecrypt(encoded, key) {
    // Decode from base64
    const encrypted = Uint8Array.from(atob(encoded), c => c.charCodeAt(0));
    const keyBytes = new TextEncoder().encode(key);
    const decrypted = new Uint8Array(encrypted.length);

    for (let i = 0; i < encrypted.length; i++) {
        decrypted[i] = encrypted[i] ^ keyBytes[i % keyBytes.length];
    }

    return new TextDecoder().decode(decrypted);
}

/**
 * Decode product line - supports both old and new formats
 * NEW FORMAT: Base64URL, comma separator, orderId, checksum
 * OLD FORMAT: Base64, pipe separator, no orderId
 * @param {string} encoded - Encoded string
 * @param {number} expectedOrderId - Expected order ID (for verification in new format)
 * @returns {object|null} { orderId?, productCode, quantity, price, timestamp } or null if invalid
 */
function decodeProductLine(encoded, expectedOrderId = null) {
    try {
        // Detect format by checking for Base64URL characters
        const isNewFormat = encoded.includes('-') || encoded.includes('_') || (!encoded.includes('+') && !encoded.includes('/') && !encoded.includes('='));

        if (isNewFormat) {
            // ===== NEW FORMAT: Base64URL + orderId + checksum =====
            try {
                // Base64URL decode
                const decrypted = base64UrlDecode(encoded);

                // XOR decrypt
                const fullData = xorDecrypt(decrypted, ENCODE_KEY);

                // Parse
                const parts = fullData.split(',');
                if (parts.length !== 6) {
                    // Not new format, fallback to old format
                    throw new Error('Not new format');
                }

                const [orderId, productCode, quantity, price, relativeTime, checksum] = parts;

                // Verify checksum
                const data = `${orderId},${productCode},${quantity},${price},${relativeTime}`;
                if (checksum !== shortChecksum(data)) {
                    console.debug('[DECODE] Checksum mismatch - data may be corrupted');
                    return null;
                }

                // Verify order ID if provided
                if (expectedOrderId !== null && orderId !== expectedOrderId.toString()) {
                    console.debug(`[DECODE] OrderId mismatch: encoded=${orderId}, expected=${expectedOrderId}`);
                    return null;
                }

                // Convert relative timestamp back to absolute
                const timestamp = parseInt(relativeTime) * 1000 + BASE_TIME;

                return {
                    orderId: parseInt(orderId),
                    productCode,
                    quantity: parseInt(quantity),
                    price: parseFloat(price),
                    timestamp
                };
            } catch (newFormatError) {
                // Fallback to old format
                console.debug('[DECODE] New format decode failed, trying old format...');
            }
        }

        // ===== OLD FORMAT: Base64 + pipe separator =====
        const decoded = xorDecrypt(encoded, ENCODE_KEY);
        const parts = decoded.split('|');

        // Support both old format (3 parts) and old format with timestamp (4 parts)
        if (parts.length !== 3 && parts.length !== 4) return null;

        const result = {
            productCode: parts[0],
            quantity: parseInt(parts[1]),
            price: parseFloat(parts[2])
        };

        // Add timestamp if present
        if (parts.length === 4) {
            result.timestamp = parseInt(parts[3]);
        }

        return result;
    } catch (error) {
        console.debug('[DECODE] Decode error:', error);
        return null;
    }
}

// =====================================================
// NOTE EDITED DETECTION VIA FIREBASE SNAPSHOT
// =====================================================

/**
 * Load all note snapshots from Firebase
 * @returns {Promise<Object>} - Map of orderId -> snapshot data
 */
async function loadNoteSnapshots() {
    if (!database) {
        console.warn('[NOTE-TRACKER] Firebase not initialized');
        return {};
    }

    try {
        console.log('[NOTE-TRACKER] Loading note snapshots from Firebase...');
        const snapshot = await database.ref('order_notes_snapshot').once('value');
        const data = snapshot.val() || {};

        // Clean up expired snapshots (older than 30 days)
        const now = Date.now();
        const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
        const cleanedData = {};
        let expiredCount = 0;

        Object.keys(data).forEach(orderId => {
            const snapshot = data[orderId];
            if (snapshot.timestamp && snapshot.timestamp > thirtyDaysAgo) {
                cleanedData[orderId] = snapshot;
            } else {
                expiredCount++;
                // Delete expired snapshot
                database.ref(`order_notes_snapshot/${orderId}`).remove();
            }
        });

        console.log(`[NOTE-TRACKER] Loaded ${Object.keys(cleanedData).length} snapshots, cleaned ${expiredCount} expired`);
        return cleanedData;
    } catch (error) {
        console.error('[NOTE-TRACKER] Error loading snapshots:', error);
        return {};
    }
}

/**
 * Check if note contains VALID encoded products (belongs to this order)
 * Verifies orderId to prevent cross-order copy attacks
 * @param {string} note - Order note
 * @param {number} expectedOrderId - Order ID to verify against
 * @returns {boolean} - True if has valid encoded products belonging to this order
 */
function hasValidEncodedProducts(note, expectedOrderId) {
    if (!note || !note.trim()) return false;

    const lines = note.split('\n');
    let foundValid = false;

    for (const line of lines) {
        const trimmed = line.trim();

        // Quick pattern check (NEW format: Base64URL - compact, no padding)
        const isNewFormat = /^[A-Za-z0-9_-]{40,65}$/.test(trimmed);

        // Quick pattern check (OLD format: Base64 with padding)
        const isOldFormat = /^[A-Za-z0-9+/]{50,80}={0,2}$/.test(trimmed);

        if (!isNewFormat && !isOldFormat) {
            continue; // Not an encoded line
        }

        try {
            // ===== NEW FORMAT: Has orderId â†’ Verify! =====
            if (isNewFormat) {
                // Decode with expectedOrderId to verify
                const decoded = decodeProductLine(trimmed, expectedOrderId);

                if (decoded && decoded.orderId === expectedOrderId) {
                    // âœ… Valid encoded product for THIS order
                    foundValid = true;
                    console.log(`[NOTE-TRACKER] âœ… Valid encoded line for order #${expectedOrderId}`);
                } else {
                    // âš ï¸ Encoded line from ANOTHER order (copy attack) or decode failed
                    // Try decode without verification to see original orderId
                    const decodedNoCheck = decodeProductLine(trimmed, null);
                    if (decodedNoCheck && decodedNoCheck.orderId) {
                        console.warn(
                            `[NOTE-TRACKER] âš ï¸ Order #${expectedOrderId} contains COPIED encoded line from Order #${decodedNoCheck.orderId} - REJECTED`
                        );
                    } else {
                        console.warn(
                            `[NOTE-TRACKER] âš ï¸ Order #${expectedOrderId} has invalid encoded line (checksum fail or corrupted)`
                        );
                    }
                }
            }

            // ===== OLD FORMAT: No orderId â†’ Accept for backward compatibility =====
            else if (isOldFormat) {
                const decoded = decodeProductLine(trimmed);
                if (decoded && decoded.productCode) {
                    // Old format doesn't have orderId to verify
                    // Accept as valid (backward compatibility)
                    foundValid = true;
                    console.log(`[NOTE-TRACKER] â„¹ï¸ Found old format encoded line (no orderId verification available)`);
                }
            }

        } catch (e) {
            // Decode failed, not a valid encoded line
            console.debug(`[NOTE-TRACKER] Failed to decode line: ${trimmed.substring(0, 20)}...`);
            continue;
        }
    }

    return foundValid;
}

/**
 * Compare current notes with snapshots and detect edits
 * @param {Array} orders - Array of order objects
 * @param {Object} snapshots - Map of orderId -> snapshot
 * @returns {Promise<void>}
 */
async function compareAndUpdateNoteStatus(orders, snapshots) {
    if (!orders || orders.length === 0) return;

    console.log('[NOTE-TRACKER] Comparing notes with snapshots...');

    let editedCount = 0;
    let newSnapshotsToSave = {};

    orders.forEach(order => {
        const orderId = order.Id;
        const currentNote = (order.Note || '').trim();
        const snapshot = snapshots[orderId];

        if (snapshot) {
            // Compare with existing snapshot
            const savedNote = (snapshot.note || '').trim();

            if (currentNote !== savedNote) {
                // Note has been edited!
                order.noteEdited = true;
                editedCount++;
                console.log(`[NOTE-TRACKER] âœï¸ Edited: STT ${order.SessionIndex}, "${savedNote}" â†’ "${currentNote}"`);
            } else {
                order.noteEdited = false;
            }
        } else {
            // No snapshot exists - only save if note has valid encoded products
            order.noteEdited = false;

            // âœ… NEW: Verify orderId in encoded products to prevent cross-order copy
            if (hasValidEncodedProducts(currentNote, orderId)) {
                // Has valid encoded products belonging to THIS order â†’ Save snapshot
                console.log(`[NOTE-TRACKER] ğŸ“¸ Saving snapshot for order #${orderId} (has valid encoded products)`);

                newSnapshotsToSave[orderId] = {
                    note: currentNote,
                    code: order.Code,
                    stt: order.SessionIndex,
                    timestamp: Date.now()
                };
            } else {
                // No valid encoded products â†’ Skip saving snapshot
                if (currentNote) {
                    console.log(`[NOTE-TRACKER] â­ï¸ Skipping order #${orderId} (no valid encoded products)`);
                }
            }
        }
    });

    // Save new snapshots in batch
    if (Object.keys(newSnapshotsToSave).length > 0) {
        await saveNoteSnapshots(newSnapshotsToSave);
    }

    console.log(`[NOTE-TRACKER] âœ… Found ${editedCount} edited notes out of ${orders.length} orders`);
}

/**
 * Save note snapshots to Firebase
 * @param {Object} snapshots - Map of orderId -> snapshot data
 * @returns {Promise<void>}
 */
async function saveNoteSnapshots(snapshots) {
    if (!database) {
        console.warn('[NOTE-TRACKER] Firebase not initialized');
        return;
    }

    try {
        const updates = {};
        Object.keys(snapshots).forEach(orderId => {
            updates[`order_notes_snapshot/${orderId}`] = snapshots[orderId];
        });

        await database.ref().update(updates);
        console.log(`[NOTE-TRACKER] Saved ${Object.keys(snapshots).length} new snapshots to Firebase`);
    } catch (error) {
        console.error('[NOTE-TRACKER] Error saving snapshots:', error);
    }
}

/**
 * Main function to detect edited notes using Firebase snapshots
 * Call this after loading orders
 */
async function detectEditedNotes() {
    if (!allData || allData.length === 0) {
        console.log('[NOTE-TRACKER] No data to check');
        return;
    }

    console.log('[NOTE-TRACKER] Starting note edit detection for', allData.length, 'orders...');

    // Load snapshots from Firebase (1 call for all orders)
    const snapshots = await loadNoteSnapshots();

    // Compare and update note status
    await compareAndUpdateNoteStatus(allData, snapshots);

    console.log('[NOTE-TRACKER] Note edit detection completed');
}

/**
 * Helper to extract the correct Facebook Comment ID from a comment object
 * Prioritizes FacebookId, OriginalId, then checks if Id is not a Mongo ID
 */
function getFacebookCommentId(comment) {
    if (!comment) return null;

    // 1. Explicit fields
    if (comment.PlatformId) return comment.PlatformId;
    if (comment.FacebookId) return comment.FacebookId;
    if (comment.OriginalId) return comment.OriginalId;
    if (comment.SocialId) return comment.SocialId;

    // 2. Check if Id is NOT a Mongo ID (24 hex chars)
    // Facebook IDs are usually numeric or have underscores
    // Support both uppercase (Id) and lowercase (id) field names from Pancake API
    const commentId = comment.Id || comment.id;
    const isMongoId = /^[0-9a-fA-F]{24}$/.test(commentId);
    if (commentId && !isMongoId) {
        return commentId;
    }

    // 3. Fallback to Id if nothing else found (might fail if it's internal)
    return commentId;
}

/**
 * Helper to extract just the post ID from a Facebook post identifier
 * Facebook_PostId format: "pageId_postId" (e.g., "117267091364524_1382798016618291")
 * Returns: just the postId part (e.g., "1382798016618291")
 */
function extractPostId(facebookPostId) {
    if (!facebookPostId) return null;

    // If it contains underscore, it's in format pageId_postId
    if (facebookPostId.includes('_')) {
        const parts = facebookPostId.split('_');
        // Return the second part (postId)
        return parts.length >= 2 ? parts[1] : facebookPostId;
    }

    // Otherwise return as-is (already just the postId)
    return facebookPostId;
}
// =====================================================
// REALTIME UI UPDATES
// =====================================================
window.addEventListener('realtimeConversationUpdate', function (event) {
    const conversation = event.detail;
    if (!conversation) return;

    // console.log('[TAB1] Handling realtime update:', conversation);

    let psid = conversation.from_psid || (conversation.customers && conversation.customers[0]?.fb_id);
    let pageId = conversation.page_id;

    // Fallback: Extract from conversation.id (format: pageId_psid)
    if ((!psid || !pageId) && conversation.id && conversation.id.includes('_')) {
        const parts = conversation.id.split('_');
        if (parts.length === 2) {
            if (!pageId) pageId = parts[0];
            if (!psid) psid = parts[1];
        }
    }

    if (!psid) return;

    // 1. UPDATE DATA MANAGERS (Crucial for filters to work)
    if (window.pancakeDataManager) {
        const convType = conversation.type || 'INBOX';
        if (convType === 'INBOX') {
            if (psid) window.pancakeDataManager.inboxMapByPSID.set(psid, conversation);
            if (conversation.from && conversation.from.id) window.pancakeDataManager.inboxMapByFBID.set(conversation.from.id, conversation);
        } else if (convType === 'COMMENT') {
            if (psid) window.pancakeDataManager.commentMapByPSID.set(psid, conversation);
            if (conversation.from && conversation.from.id) window.pancakeDataManager.commentMapByFBID.set(conversation.from.id, conversation);
        }
    }

    // NEW: Check if chat modal is open for THIS conversation
    const chatModal = document.getElementById('chatModal');
    const isChatModalOpen = chatModal && chatModal.style.display !== 'none';

    if (isChatModalOpen && window.currentChatPSID) {
        const conversationPsid = conversation.from_psid || conversation.customers?.[0]?.fb_id;
        const conversationId = conversation.id;

        // IMPORTANT: Only update if this is THE conversation currently open in modal
        const isCurrentConversation =
            conversationPsid === window.currentChatPSID ||
            conversationId === window.currentChatConversationId;

        if (isCurrentConversation) {
            console.log('[REALTIME] Update for OPEN chat modal - fetching new messages for PSID:', conversationPsid);

            // Prevent fetch if we're currently sending (skipWebhookUpdate flag)
            if (!window.skipWebhookUpdate) {
                // Async fetch new messages without blocking table update
                fetchAndAppendNewMessages(conversation).catch(err => {
                    console.error('[REALTIME] Error fetching new messages:', err);
                });
            } else {
                console.log('[REALTIME] Skipping fetch - currently sending message');
            }
        } else {
            console.log('[REALTIME] Update for DIFFERENT conversation - only updating table');
        }
    }

    // 2. CHECK FILTER
    // If filtering by read/unread, we MUST re-run search to show/hide rows
    const currentFilter = document.getElementById('conversationFilter') ? document.getElementById('conversationFilter').value : 'all';
    if (currentFilter === 'unread' || currentFilter === 'read') {
        console.log(`[TAB1] Realtime update with filter '${currentFilter}' - Triggering re-search`);
        performTableSearch();
        return; // Stop here, let search handle the rendering
    }

    const message = conversation.snippet || '';
    const unreadCount = conversation.unread_count || 0;
    const isUnread = unreadCount > 0 || !conversation.seen;
    const type = conversation.type || 'INBOX'; // INBOX or COMMENT

    // Find matching orders in displayedData
    // Match both PSID and PageID (via Facebook_PostId which starts with PageID)
    const matchingOrders = displayedData.filter(o => {
        const matchesPsid = o.Facebook_ASUserId === psid;
        // If we have a pageId, check if Facebook_PostId starts with it
        const matchesPage = pageId ? (o.Facebook_PostId && o.Facebook_PostId.startsWith(pageId)) : true;
        return matchesPsid && matchesPage;
    });

    if (matchingOrders.length === 0) return;

    console.log(`[TAB1] Updating ${matchingOrders.length} rows for PSID ${psid} on Page ${pageId}`);

    matchingOrders.forEach(order => {
        // Find row
        const checkbox = document.querySelector(`input[value="${order.Id}"]`);
        if (!checkbox) return;
        const row = checkbox.closest('tr');
        if (!row) return;

        // Determine column based on type
        const colType = type === 'INBOX' ? 'messages' : 'comments';
        const cell = row.querySelector(`td[data-column="${colType}"]`);

        if (cell) {
            // Construct HTML directly
            const fontWeight = isUnread ? '700' : '400';
            const color = isUnread ? '#111827' : '#6b7280';
            const unreadBadge = isUnread ? `<span class="unread-badge"></span>` : '';
            const unreadText = unreadCount > 0 ? `<span style="font-size: 11px; color: #ef4444; font-weight: 600;">${unreadCount} tin má»›i</span>` : '';

            // Truncate message
            let displayMessage = message;
            if (displayMessage.length > 30) displayMessage = displayMessage.substring(0, 30) + '...';

            // Update innerHTML
            cell.innerHTML = `
                <div style="display: flex; align-items: center; gap: 6px;">
                    ${unreadBadge}
                    <div style="display: flex; flex-direction: column;">
                        <span style="font-size: 13px; font-weight: ${fontWeight}; color: ${color};">
                            ${displayMessage}
                        </span>
                        ${unreadText}
                    </div>
                </div>
            `;

            // Add click event and styling
            // Use separate modals: openChatModal for messages, openCommentModal for comments
            const clickHandler = type === 'INBOX'
                ? `openChatModal('${order.Id}', '${pageId}', '${psid}')`
                : `openCommentModal('${order.Id}', '${pageId}', '${psid}')`;

            const tooltipText = type === 'INBOX'
                ? 'Click Ä‘á»ƒ xem toÃ n bá»™ tin nháº¯n'
                : 'Click Ä‘á»ƒ xem bÃ¬nh luáº­n';

            cell.setAttribute('onclick', clickHandler);
            cell.style.cursor = 'pointer';
            cell.title = tooltipText;

            // Highlight
            row.classList.add('product-row-highlight');
            setTimeout(() => row.classList.remove('product-row-highlight'), 2000);
        }
    });

    // ğŸ”„ UPDATE ALL DATA & RE-FILTER IF NEEDED
    // Even if the order is not currently displayed (filtered out), we need to update its state in allData
    // and check if it should now be displayed based on current filters.

    // 1. Update PancakeDataManager Cache (Crucial for performTableSearch)
    if (window.pancakeDataManager) {
        // We need to manually update the cache because performTableSearch uses getMessageUnreadInfoForOrder
        // which reads from this cache.
        // The conversation object from the event has the structure we need.

        // We need to find where to put it. 
        // PancakeDataManager stores conversations in inboxMapByPSID and inboxMapByFBID
        // We can try to call a method to update it, or manually set it if exposed.
        // Looking at PancakeDataManager, it doesn't seem to have a public 'updateConversation' method 
        // that takes a raw payload easily without fetching.
        // However, we can try to update the map if we can access it, but it's better to rely on 
        // what we have.

        // Actually, let's just update the order's internal state if possible, OR
        // since performTableSearch calls window.pancakeDataManager.getMessageUnreadInfoForOrder(order),
        // and that function looks up in inboxMapByPSID.

        // Let's try to update the map directly if possible, or add a helper in PancakeDataManager.
        // Since we can't easily modify PancakeDataManager right now without switching files,
        // let's assume for now we can't easily update the private maps if they are not exposed.

        // WAIT: window.pancakeDataManager.inboxMapByPSID is likely accessible.
        if (window.pancakeDataManager.inboxMapByPSID) {
            window.pancakeDataManager.inboxMapByPSID.set(String(psid), conversation);
        }
    }

    // 2. Check if we need to refresh the table (if order was hidden but now matches filter)
    const conversationFilter = document.getElementById('conversationFilter')?.value || 'all';

    // Only care if we are filtering by 'unread'
    if (conversationFilter === 'unread') {
        // Check if any matching order is NOT in displayedData
        // We need to find orders in allData that match this PSID/PageID
        const allMatchingOrders = allData.filter(o => {
            const matchesPsid = o.Facebook_ASUserId === psid;
            const matchesPage = pageId ? (o.Facebook_PostId && o.Facebook_PostId.startsWith(pageId)) : true;
            return matchesPsid && matchesPage;
        });

        const hiddenOrders = allMatchingOrders.filter(o => !displayedData.includes(o));

        if (hiddenOrders.length > 0) {
            console.log(`[TAB1] Found ${hiddenOrders.length} hidden orders matching realtime update. Refreshing table...`);

            // We need to ensure the filter logic sees them as "unread".
            // Since we updated the PancakeDataManager cache above, performTableSearch should now
            // correctly identify them as unread.

            performTableSearch();

            // After refresh, highlight them
            setTimeout(() => {
                hiddenOrders.forEach(order => {
                    const checkbox = document.querySelector(`input[value="${order.Id}"]`);
                    if (checkbox) {
                        const row = checkbox.closest('tr');
                        if (row) {
                            row.classList.add('product-row-highlight');
                            setTimeout(() => row.classList.remove('product-row-highlight'), 2000);
                        }
                    }
                });
            }, 100);
        }
    }
});

// =====================================================
// INCREMENTAL MESSAGE UPDATE HELPERS
// =====================================================

/**
 * Fetch only NEW messages and append to chat (WebSocket triggered)
 */
async function fetchAndAppendNewMessages(conversation) {
    try {
        const channelId = window.currentChatChannelId;
        const psid = window.currentChatPSID;
        const chatType = window.currentChatType || 'message';

        if (!channelId || !psid) {
            console.log('[REALTIME] Missing channelId or psid, cannot fetch');
            return;
        }

        // Get last message/comment ID from current list
        let lastId = null;
        if (chatType === 'message' && window.allChatMessages && window.allChatMessages.length > 0) {
            const lastMsg = window.allChatMessages[window.allChatMessages.length - 1];
            lastId = lastMsg.id || lastMsg.Id;
        } else if (chatType === 'comment' && window.allChatComments && window.allChatComments.length > 0) {
            const lastComment = window.allChatComments[window.allChatComments.length - 1];
            lastId = lastComment.id || lastComment.Id;
        }

        console.log('[REALTIME] Fetching messages after ID:', lastId);

        let newItems = [];

        if (chatType === 'message') {
            // Fetch ALL messages (API doesn't support 'after' parameter yet)
            const response = await window.chatDataManager.fetchMessages(channelId, psid, null);

            if (response && response.messages) {
                // Filter to only get messages we don't have yet
                const existingIds = new Set(window.allChatMessages.map(m => m.id || m.Id));
                newItems = response.messages.filter(msg => {
                    const msgId = msg.id || msg.Id;
                    return !existingIds.has(msgId);
                });
            }
        } else {
            // Fetch ALL comments
            const response = await window.chatDataManager.fetchComments(channelId, psid, null);

            if (response && response.comments) {
                // Filter to only get comments we don't have yet
                const existingIds = new Set(window.allChatComments.map(c => c.id || c.Id));
                newItems = response.comments.filter(comment => {
                    const commentId = comment.id || comment.Id;
                    return !existingIds.has(commentId);
                });
            }
        }

        if (newItems.length > 0) {
            console.log('[REALTIME] Got', newItems.length, 'new items');

            // Check if user is at bottom before updating
            const modalBody = document.getElementById('chatModalBody');
            const wasAtBottom = modalBody &&
                (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100);

            // Add to global array
            if (chatType === 'message') {
                window.allChatMessages.push(...newItems);
                // Re-render all messages with full formatting (avatar, name, quoted messages, etc.)
                renderChatMessages(window.allChatMessages, wasAtBottom);
            } else {
                window.allChatComments.push(...newItems);
                // Re-render all comments with full formatting
                renderChatMessages(window.allChatComments, wasAtBottom);
            }
        } else {
            console.log('[REALTIME] No new items found');
        }

    } catch (error) {
        console.error('[REALTIME] Error fetching new messages:', error);
    }
}

/**
 * Create DOM element for a single message (without re-rendering all)
 */
function createMessageElement(msg, chatType = 'message') {
    const div = document.createElement('div');
    const isOwner = msg.IsOwner || msg.is_owner;

    div.className = `chat-message ${isOwner ? 'chat-message-right' : 'chat-message-left'}`;
    div.dataset.messageId = msg.id || msg.Id;

    const bgClass = isOwner ? 'chat-bubble-owner' : 'chat-bubble-customer';

    let content = '';

    // Message text
    if (msg.Message || msg.message) {
        const messageText = msg.Message || msg.message;
        content += `<p class="chat-message-text">${messageText}</p>`;
    }

    // Attachments (capital A - messages)
    if (msg.Attachments && msg.Attachments.length > 0) {
        msg.Attachments.forEach(att => {
            if (att.Type === 'image' && att.Payload && att.Payload.Url) {
                content += `<img src="${att.Payload.Url}" class="chat-message-image" loading="lazy">`;
            } else if (att.Type === 'audio' && att.Payload && att.Payload.Url) {
                content += `<div class="chat-audio-message">
                    <audio controls><source src="${att.Payload.Url}" type="audio/mp4"></audio>
                </div>`;
            }
        });
    }

    // attachments (lowercase a - comments)
    if (msg.attachments && msg.attachments.length > 0) {
        msg.attachments.forEach(att => {
            if (att.mime_type && att.mime_type.startsWith('image/') && att.file_url) {
                content += `<img src="${att.file_url}" class="chat-message-image" loading="lazy">`;
            } else if (att.mime_type === 'audio/mp4' && att.file_url) {
                content += `<div class="chat-audio-message">
                    <audio controls><source src="${att.file_url}" type="audio/mp4"></audio>
                </div>`;
            }
        });
    }

    // Format time - use global formatTimeVN
    const formatTime = window.formatTimeVN;

    const timeStr = formatTime(msg.CreatedTime || msg.created_at);

    div.innerHTML = `
        <div class="chat-bubble ${bgClass}">
            ${content}
            <p class="chat-message-time">${timeStr}</p>
        </div>
    `;

    return div;
}

/**
 * Append new messages to chat (incremental update)
 */
function appendNewMessages(messages, chatType = 'message') {
    const modalBody = document.getElementById('chatModalBody');
    if (!modalBody) {
        console.warn('[APPEND] No modal body found');
        return;
    }

    const container = modalBody.querySelector('.chat-messages-container');
    if (!container) {
        console.warn('[APPEND] No messages container found');
        return;
    }

    // Check if user is at bottom (before adding new messages)
    const wasAtBottom = modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 100;

    // Create document fragment for batch append (better performance)
    const fragment = document.createDocumentFragment();

    messages.forEach(msg => {
        const msgEl = createMessageElement(msg, chatType);
        fragment.appendChild(msgEl);
    });

    // Append all at once
    container.appendChild(fragment);

    // Smart scroll - only auto-scroll if user was already at bottom
    if (wasAtBottom) {
        requestAnimationFrame(() => {
            modalBody.scrollTop = modalBody.scrollHeight;

            // Hide new message indicator
            const indicator = document.getElementById('chatNewMessageIndicator');
            if (indicator) indicator.style.display = 'none';
        });
    } else {
        // Show "new messages" indicator if user scrolled up
        showNewMessageIndicator();
    }

    console.log('[APPEND] Added', messages.length, 'new messages to DOM');
}

// =====================================================
// QUICK ADD PRODUCT LOGIC
// =====================================================
let quickAddSelectedProducts = [];
let quickAddSearchTimeout = null;

function openQuickAddProductModal() {
    // Update UI - Global List
    document.getElementById('targetOrdersCount').textContent = "Danh sÃ¡ch chung";

    // Reset state
    quickAddSelectedProducts = [];
    renderQuickAddSelectedProducts();
    document.getElementById('quickProductSearch').value = '';
    document.getElementById('quickProductSuggestions').style.display = 'none';

    // Show modal
    document.getElementById('quickAddProductModal').style.display = 'block';
    document.getElementById('quickAddProductModal').classList.add('show');
    document.getElementById('quickAddProductBackdrop').style.display = 'block';

    // Focus search
    setTimeout(() => {
        document.getElementById('quickProductSearch').focus();
    }, 100);

    // Initialize search manager if needed
    if (window.enhancedProductSearchManager && !window.enhancedProductSearchManager.isLoaded) {
        window.enhancedProductSearchManager.fetchExcelProducts();
    }
}

function closeQuickAddProductModal() {
    document.getElementById('quickAddProductModal').style.display = 'none';
    document.getElementById('quickAddProductModal').classList.remove('show');
    document.getElementById('quickAddProductBackdrop').style.display = 'none';
}

// Search Input Handler
const quickProductSearchEl = document.getElementById('quickProductSearch');
if (quickProductSearchEl) {
    quickProductSearchEl.addEventListener('input', function (e) {
        const query = e.target.value;

        if (quickAddSearchTimeout) clearTimeout(quickAddSearchTimeout);

        if (!query || query.trim().length < 2) {
            const suggestionsEl = document.getElementById('quickProductSuggestions');
            if (suggestionsEl) suggestionsEl.style.display = 'none';
            return;
        }

        quickAddSearchTimeout = setTimeout(() => {
            if (window.enhancedProductSearchManager) {
                const results = window.enhancedProductSearchManager.search(query, 10);
                renderQuickAddSuggestions(results);
            }
        }, 300);
    });
}

// Hide suggestions on click outside
document.addEventListener('click', function (e) {
    const suggestions = document.getElementById('quickProductSuggestions');
    const searchInput = document.getElementById('quickProductSearch');

    if (suggestions && searchInput && e.target !== searchInput && !suggestions.contains(e.target)) {
        suggestions.style.display = 'none';
    }
});

function renderQuickAddSuggestions(products) {
    const suggestionsEl = document.getElementById('quickProductSuggestions');

    if (products.length === 0) {
        suggestionsEl.innerHTML = `
            <div style="padding: 16px; text-align: center; color: #9ca3af;">
                <i class="fas fa-search" style="font-size: 20px; opacity: 0.5; margin-bottom: 8px;"></i>
                <p style="margin: 0; font-size: 13px;">KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m</p>
            </div>
        `;
        suggestionsEl.style.display = 'block';
        return;
    }

    suggestionsEl.innerHTML = products.map(product => {
        const imageUrl = product.ImageUrl || (product.Thumbnails && product.Thumbnails[0]);
        return `
            <div class="suggestion-item" onclick="addQuickProduct(${product.Id})" style="
                display: flex; align-items: center; gap: 12px; padding: 10px 14px; cursor: pointer; transition: background 0.2s; border-bottom: 1px solid #f3f4f6;
            " onmouseover="this.style.background='#f9fafb'" onmouseout="this.style.background='white'">
                <div style="width: 40px; height: 40px; border-radius: 8px; background: #f3f4f6; display: flex; align-items: center; justify-content: center; flex-shrink: 0; overflow: hidden;">
                    ${imageUrl
                ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                           <i class="fas fa-box" style="color: #9ca3af; display: none;"></i>`
                : `<i class="fas fa-box" style="color: #9ca3af;"></i>`
            }
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-size: 14px; font-weight: 500; color: #1f2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${product.Name}</div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 2px;">
                        ${product.Code ? `<span style="font-size: 11px; color: #6b7280; background: #f3f4f6; padding: 2px 6px; border-radius: 4px;">${product.Code}</span>` : ''}
                        <span style="font-size: 12px; font-weight: 600; color: #8b5cf6;">${(product.Price || 0).toLocaleString('vi-VN')}Ä‘</span>
                    </div>
                </div>
                <i class="fas fa-plus-circle" style="color: #8b5cf6; font-size: 18px;"></i>
            </div>
        `;
    }).join('');

    suggestionsEl.style.display = 'block';
}

async function addQuickProduct(productId) {
    // Check if already added
    const existing = quickAddSelectedProducts.find(p => p.Id === productId);
    if (existing) {
        existing.Quantity += 1;
        renderQuickAddSelectedProducts();
        document.getElementById('quickProductSuggestions').style.display = 'none';
        document.getElementById('quickProductSearch').value = '';
        return;
    }

    // Get product details
    let product = null;
    if (window.enhancedProductSearchManager) {
        // Try to get from Excel cache first
        product = window.enhancedProductSearchManager.getFromExcel(productId);

        // If not full details, try to fetch
        if (product && !product.HasFullDetails) {
            try {
                const fullProduct = await window.enhancedProductSearchManager.getFullProductDetails(productId);
                product = { ...product, ...fullProduct };
            } catch (e) {
                console.warn("Could not fetch full details", e);
            }
        }
    }

    if (!product) return;

    quickAddSelectedProducts.push({
        Id: product.Id,
        Name: product.Name,
        Code: product.Code || product.DefaultCode || '',
        Price: product.Price || 0,
        ImageUrl: product.ImageUrl,
        Quantity: 1
    });

    renderQuickAddSelectedProducts();
    document.getElementById('quickProductSuggestions').style.display = 'none';
    document.getElementById('quickProductSearch').value = '';
    document.getElementById('quickProductSearch').focus();
}

function removeQuickProduct(index) {
    quickAddSelectedProducts.splice(index, 1);
    renderQuickAddSelectedProducts();
}

function updateQuickProductQuantity(index, change) {
    const product = quickAddSelectedProducts[index];
    const newQty = product.Quantity + change;

    if (newQty <= 0) {
        removeQuickProduct(index);
    } else {
        product.Quantity = newQty;
        renderQuickAddSelectedProducts();
    }
}

function clearSelectedProducts() {
    quickAddSelectedProducts = [];
    renderQuickAddSelectedProducts();
}

function renderQuickAddSelectedProducts() {
    const container = document.getElementById('selectedProductsList');
    const countEl = document.getElementById('selectedProductsCount');
    const clearBtn = document.getElementById('clearAllProductsBtn');

    countEl.textContent = quickAddSelectedProducts.length;
    clearBtn.style.display = quickAddSelectedProducts.length > 0 ? 'block' : 'none';

    if (quickAddSelectedProducts.length === 0) {
        container.innerHTML = `
            <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 40px 0; color: #9ca3af;">
                <i class="fas fa-basket-shopping" style="font-size: 48px; margin-bottom: 16px; opacity: 0.3;"></i>
                <p style="margin: 0; font-weight: 500;">ChÆ°a cÃ³ sáº£n pháº©m nÃ o</p>
                <p style="margin: 4px 0 0 0; font-size: 13px;">TÃ¬m kiáº¿m vÃ  chá»n sáº£n pháº©m Ä‘á»ƒ thÃªm</p>
            </div>
        `;
        return;
    }

    container.innerHTML = quickAddSelectedProducts.map((product, index) => {
        const imageUrl = product.ImageUrl;
        const total = (product.Price * product.Quantity).toLocaleString('vi-VN');

        return `
            <div class="selected-product-item" style="
                display: flex; align-items: center; gap: 12px; padding: 12px; border-bottom: 1px solid #f3f4f6; background: white;
            ">
                <div style="width: 48px; height: 48px; border-radius: 8px; background: #f3f4f6; display: flex; align-items: center; justify-content: center; flex-shrink: 0; overflow: hidden;">
                    ${imageUrl
                ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                           <i class="fas fa-box" style="color: #9ca3af; display: none;"></i>`
                : `<i class="fas fa-box" style="color: #9ca3af;"></i>`
            }
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-size: 14px; font-weight: 500; color: #1f2937; margin-bottom: 4px;">${product.Name}</div>
                    <div style="font-size: 12px; color: #6b7280;">${product.Code || 'No Code'}</div>
                </div>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="display: flex; align-items: center; border: 1px solid #e5e7eb; border-radius: 6px;">
                        <button onclick="updateQuickProductQuantity(${index}, -1)" style="padding: 4px 8px; background: none; border: none; cursor: pointer; color: #6b7280;">-</button>
                        <span style="font-size: 13px; font-weight: 600; min-width: 24px; text-align: center;">${product.Quantity}</span>
                        <button onclick="updateQuickProductQuantity(${index}, 1)" style="padding: 4px 8px; background: none; border: none; cursor: pointer; color: #6b7280;">+</button>
                    </div>
                    <div style="font-size: 13px; font-weight: 600; color: #374151; min-width: 80px; text-align: right;">
                        ${total}Ä‘
                    </div>
                    <button onclick="removeQuickProduct(${index})" style="padding: 6px; background: none; border: none; cursor: pointer; color: #ef4444; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

async function saveSelectedProductsToOrders() {
    if (quickAddSelectedProducts.length === 0) {
        if (window.notificationManager) {
            window.notificationManager.warning("Vui lÃ²ng chá»n Ã­t nháº¥t má»™t sáº£n pháº©m!");
        } else {
            alert("Vui lÃ²ng chá»n Ã­t nháº¥t má»™t sáº£n pháº©m!");
        }
        return;
    }

    showLoading(true);

    try {
        // Initialize Firebase if needed
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();
        const ref = db.ref(`chat_products/shared`);

        // Get existing products first to merge quantities
        const snapshot = await ref.once('value');
        const existingProducts = snapshot.val() || {};

        // Merge new products
        quickAddSelectedProducts.forEach(newProduct => {
            if (existingProducts[newProduct.Id]) {
                // Update quantity
                existingProducts[newProduct.Id].Quantity = (existingProducts[newProduct.Id].Quantity || 0) + newProduct.Quantity;
            } else {
                // Add new
                existingProducts[newProduct.Id] = {
                    Id: newProduct.Id,
                    Name: newProduct.Name,
                    Code: newProduct.Code,
                    Price: newProduct.Price,
                    Quantity: newProduct.Quantity,
                    ImageUrl: newProduct.ImageUrl || '',
                    AddedAt: firebase.database.ServerValue.TIMESTAMP
                };
            }
        });

        // Save back to Firebase
        await ref.set(existingProducts);

        showLoading(false);
        closeQuickAddProductModal();

        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ thÃªm sáº£n pháº©m vÃ o danh sÃ¡ch chung!`);
        } else {
            alert(`âœ… ÄÃ£ thÃªm sáº£n pháº©m vÃ o danh sÃ¡ch chung!`);
        }

    } catch (error) {
        console.error("Error saving products:", error);
        showLoading(false);
        if (window.notificationManager) {
            window.notificationManager.error("Lá»—i khi lÆ°u sáº£n pháº©m: " + error.message);
        } else {
            alert("âŒ Lá»—i khi lÆ°u sáº£n pháº©m: " + error.message);
        }
    }
}
// =====================================================
// CHAT SHOPPING CART LOGIC
// =====================================================

/* LEGACY CODE REMOVED
function renderChatProductsPanel() {
    const listContainer = document.getElementById("chatProductList");
    const countBadge = document.getElementById("chatProductCountBadge");
    const totalEl = document.getElementById("chatOrderTotal");
 
    if (!listContainer) return;
 
    // Update Count & Total
    const totalQty = currentChatOrderDetails.reduce((sum, p) => sum + (p.Quantity || 0), 0);
    const totalAmount = currentChatOrderDetails.reduce((sum, p) => sum + ((p.Quantity || 0) * (p.Price || 0)), 0);
 
    if (countBadge) countBadge.textContent = `${totalQty} sáº£n pháº©m`;
    if (totalEl) totalEl.textContent = `${totalAmount.toLocaleString("vi-VN")}Ä‘`;
 
    // Empty State
    if (currentChatOrderDetails.length === 0) {
        listContainer.innerHTML = `
            <div class="chat-empty-cart" style="text-align: center; padding: 40px 20px; color: #94a3b8;">
                <i class="fas fa-box-open" style="font-size: 40px; margin-bottom: 12px; opacity: 0.5;"></i>
                <p style="font-size: 14px; margin: 0;">ChÆ°a cÃ³ sáº£n pháº©m nÃ o</p>
                <p style="font-size: 12px; margin-top: 4px;">TÃ¬m kiáº¿m Ä‘á»ƒ thÃªm sáº£n pháº©m vÃ o Ä‘Æ¡n</p>
            </div>`;
        return;
    }
 
    // Render List
    listContainer.innerHTML = currentChatOrderDetails.map((p, index) => `
        <div class="chat-product-card" style="
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            gap: 12px;
            transition: all 0.2s;
        ">
            <!-- Image -->
            <div style="
                width: 48px;
                height: 48px;
                border-radius: 6px;
                background: #f1f5f9;
                overflow: hidden;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            ">
                ${p.ImageUrl
            ? `<img src="${p.ImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">`
            : `<i class="fas fa-image" style="color: #cbd5e1;"></i>`}
            </div>
 
            <!-- Content -->
            <div style="flex: 1; min-width: 0;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px;">
                    <div style="font-size: 13px; font-weight: 600; color: #1e293b; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">
                        ${p.ProductName || p.Name || 'Sáº£n pháº©m'}
                    </div>
                    <button onclick="removeChatProduct(${index})" style="
                        background: none;
                        border: none;
                        color: #ef4444;
                        cursor: pointer;
                        padding: 4px;
                        margin-top: -4px;
                        margin-right: -4px;
                        opacity: 0.6;
                        transition: opacity 0.2s;
                    " onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div style="font-size: 11px; color: #64748b; margin-bottom: 8px;">
                    MÃ£: ${p.ProductCode || p.Code || 'N/A'}
                </div>
 
                <!-- Controls -->
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="font-size: 13px; font-weight: 700; color: #3b82f6;">
                        ${(p.Price || 0).toLocaleString("vi-VN")}Ä‘
                    </div>
                    
                    <div style="display: flex; align-items: center; border: 1px solid #e2e8f0; border-radius: 6px; overflow: hidden;">
                        <button onclick="updateChatProductQuantity(${index}, -1)" style="
                            width: 24px;
                            height: 24px;
                            border: none;
                            background: #f8fafc;
                            color: #64748b;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 10px;
                        "><i class="fas fa-minus"></i></button>
                        <input type="number" value="${p.Quantity || 1}" onchange="updateChatProductQuantity(${index}, 0, this.value)" style="
                            width: 32px;
                            height: 24px;
                            border: none;
                            border-left: 1px solid #e2e8f0;
                            border-right: 1px solid #e2e8f0;
                            text-align: center;
                            font-size: 12px;
                            font-weight: 600;
                            color: #1e293b;
                            -moz-appearance: textfield;
                        ">
                        <button onclick="updateChatProductQuantity(${index}, 1)" style="
                            width: 24px;
                            height: 24px;
                            border: none;
                            background: #f8fafc;
                            color: #64748b;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 10px;
                        "><i class="fas fa-plus"></i></button>
                    </div>
                </div>
            </div>
        </div>
    `).join("");
}
*/

// =====================================================
// RENDER CHAT PRODUCTS TABLE - Hiá»ƒn thá»‹ sáº£n pháº©m Ä‘Æ¡n hÃ ng trong modal tin nháº¯n
// =====================================================
function renderChatProductsTable() {
    const listContainer = document.getElementById("chatProductsTableContainer");
    const countBadge = document.getElementById("productCount");
    const totalEl = document.getElementById("chatProductTotal");

    if (!listContainer) {
        console.error('[CHAT] Product list container not found');
        return;
    }

    // Get products from window.currentChatOrderData if available (includes held products)
    // Otherwise fallback to currentChatOrderDetails
    const productsToRender = (window.currentChatOrderData && window.currentChatOrderData.Details)
        ? window.currentChatOrderData.Details
        : currentChatOrderDetails;

    // Separate normal and held products
    const normalProducts = productsToRender.filter(p => !p.IsHeld);
    const heldProducts = productsToRender.filter(p => p.IsHeld);

    // Update Count & Total (all products)
    const totalQty = productsToRender.reduce((sum, p) => sum + (p.Quantity || 0), 0);
    const totalAmount = productsToRender.reduce((sum, p) => sum + ((p.Quantity || 0) * (p.Price || 0)), 0);

    if (countBadge) countBadge.textContent = totalQty;
    if (totalEl) totalEl.textContent = `${totalAmount.toLocaleString("vi-VN")}Ä‘`;

    // Empty State
    if (productsToRender.length === 0) {
        listContainer.innerHTML = `
            <div class="chat-empty-products" style="text-align: center; padding: 40px 20px; color: #94a3b8;">
                <i class="fas fa-box-open" style="font-size: 40px; margin-bottom: 12px; opacity: 0.5;"></i>
                <p style="font-size: 14px; margin: 0;">ChÆ°a cÃ³ sáº£n pháº©m nÃ o</p>
                <p style="font-size: 12px; margin-top: 4px;">TÃ¬m kiáº¿m Ä‘á»ƒ thÃªm sáº£n pháº©m vÃ o Ä‘Æ¡n</p>
            </div>`;
        return;
    }

    // Render sections
    let htmlContent = '';

    // Render Held Products Section (if any)
    if (heldProducts.length > 0) {
        htmlContent += `
            <div style="margin-bottom: 16px;">
                <div style="
                    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
                    padding: 8px 12px;
                    border-radius: 6px;
                    margin-bottom: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                ">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-hand-paper" style="color: #d97706;"></i>
                        <span style="font-size: 12px; font-weight: 600; color: #92400e;">
                            Sáº£n pháº©m giá»¯ (${heldProducts.length})
                        </span>
                    </div>
                    <button onclick="window.saveHeldProducts()" style="
                        background: #10b981;
                        color: white;
                        border: none;
                        padding: 4px 12px;
                        border-radius: 4px;
                        font-size: 11px;
                        font-weight: 600;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 4px;
                    " title="LÆ°u sáº£n pháº©m giá»¯ - sáº½ khÃ´ng bá»‹ máº¥t khi refresh trang">
                        <i class="fas fa-save"></i> LÆ°u giá»¯
                    </button>
                </div>
                ${heldProducts.map((p, index) => renderProductCard(p, index, true)).join('')}
            </div>
        `;
    }

    // Render Normal Products Section
    if (normalProducts.length > 0) {
        if (heldProducts.length > 0) {
            htmlContent += `
                <div style="
                    background: #f1f5f9;
                    padding: 8px 12px;
                    border-radius: 6px;
                    margin-bottom: 8px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                ">
                    <i class="fas fa-box" style="color: #3b82f6;"></i>
                    <span style="font-size: 12px; font-weight: 600; color: #1e293b;">
                        Sáº£n pháº©m chÃ­nh (${normalProducts.length})
                    </span>
                </div>
            `;
        }
        htmlContent += normalProducts.map((p, index) => renderProductCard(p, index, false)).join('');
    }

    listContainer.innerHTML = htmlContent;

    console.log('[CHAT] Rendered', normalProducts.length, 'normal +', heldProducts.length, 'held products');
}

/**
 * Render a single product card
 */
function renderProductCard(p, index, isHeld) {
    const borderColor = isHeld ? '#fbbf24' : '#e2e8f0';
    const bgColor = isHeld ? '#fffbeb' : 'white';
    const heldBadge = isHeld ? `<span style="font-size: 10px; background: #fbbf24; color: #78350f; padding: 2px 6px; border-radius: 4px; margin-left: 6px;">Giá»¯</span>` : '';
    const escapedProductName = (p.ProductName || p.Name || '').replace(/'/g, "\\'");
    const escapedProductCode = (p.ProductCode || p.Code || '').replace(/'/g, "\\'");

    return `
        <div class="chat-product-card" style="
            background: ${bgColor};
            border: 2px solid ${borderColor};
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            gap: 12px;
            transition: all 0.2s;
        ">
            <!-- Image - Click to zoom, Right-click to send to chat -->
            <div style="
                width: 48px;
                height: 48px;
                border-radius: 6px;
                background: #f1f5f9;
                overflow: hidden;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: ${p.ImageUrl ? 'pointer' : 'default'};
            "
                ${p.ImageUrl ? `onclick="showImageZoom('${p.ImageUrl}', '${escapedProductName}')"` : ''}
                ${p.ImageUrl ? `oncontextmenu="sendImageToChat('${p.ImageUrl}', '${escapedProductName}', ${p.ProductId || 'null'}, '${escapedProductCode}'); return false;"` : ''}
                ${p.ImageUrl ? `title="Click: Xem áº£nh | Chuá»™t pháº£i: Gá»­i áº£nh vÃ o chat"` : ''}
            >
                ${p.ImageUrl
            ? `<img src="${p.ImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">`
            : `<i class="fas fa-image" style="color: #cbd5e1;"></i>`}
            </div>

            <!-- Content -->
            <div style="flex: 1; min-width: 0;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px;">
                    <div style="font-size: 13px; font-weight: 600; color: #1e293b; line-height: 1.4;">
                        ${p.ProductName || p.Name || 'Sáº£n pháº©m'}${heldBadge}
                    </div>
                </div>

                <div style="font-size: 11px; color: #64748b; margin-bottom: 8px;">
                    MÃ£: ${p.ProductCode || p.Code || 'N/A'}
                    ${isHeld && p.HeldBy ? `<br><span style="color: #f59e0b;">ğŸ‘¤ ${p.HeldBy}</span>` : ''}
                </div>

                <!-- Controls -->
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="font-size: 13px; font-weight: 700; color: #3b82f6;">
                            ${(p.Price || 0).toLocaleString("vi-VN")}Ä‘
                        </div>
                        <button onclick="sendProductToChat(${p.ProductId}, '${escapedProductName}')" style="
                            width: 24px;
                            height: 24px;
                            border: none;
                            background: #3b82f6;
                            color: white;
                            border-radius: 4px;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 10px;
                            transition: all 0.2s;
                        " title="Gá»­i tÃªn sáº£n pháº©m vÃ o chat"
                           onmouseover="this.style.background='#2563eb'"
                           onmouseout="this.style.background='#3b82f6'">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>

                    ${!isHeld ? `
                    <!-- Main product: only show minus button and quantity -->
                    <div style="display: flex; align-items: center; border: 1px solid #e2e8f0; border-radius: 6px; overflow: hidden;">
                        <button onclick="decreaseMainProductQuantityById(${p.ProductId})" style="
                            width: 28px;
                            height: 28px;
                            border: none;
                            background: #fee2e2;
                            color: #ef4444;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                        ">âˆ’</button>
                        <span style="
                            min-width: 36px;
                            text-align: center;
                            font-size: 13px;
                            font-weight: 600;
                            padding: 4px 8px;
                            background: #f8fafc;
                        ">${p.Quantity || 0}</span>
                    </div>
                    ` : `
                    <!-- Held product: show full quantity controls -->
                    <div style="display: flex; align-items: center; border: 1px solid #e2e8f0; border-radius: 6px; overflow: hidden;">
                        <button onclick="updateHeldProductQuantityById(${p.ProductId}, -1)" style="
                            width: 24px;
                            height: 24px;
                            border: none;
                            background: #f8fafc;
                            color: #64748b;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">âˆ’</button>
                        <input type="number" value="${p.Quantity || 0}"
                            onchange="updateHeldProductQuantityById(${p.ProductId}, 0, this.value)"
                            style="
                            width: 36px;
                            text-align: center;
                            border: none;
                            border-left: 1px solid #e2e8f0;
                            border-right: 1px solid #e2e8f0;
                            font-size: 13px;
                            font-weight: 600;
                            padding: 2px 0;
                        ">
                        <button onclick="updateHeldProductQuantityById(${p.ProductId}, 1)" style="
                            width: 24px;
                            height: 24px;
                            border: none;
                            background: #f8fafc;
                            color: #64748b;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">+</button>
                    </div>
                    `}
                </div>

                ${isHeld ? `
                <!-- Held Product Actions -->
                <div style="display: flex; gap: 6px; margin-top: 8px;">
                    <button onclick="confirmHeldProduct(${p.ProductId})" style="
                        flex: 1;
                        padding: 6px 12px;
                        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        font-size: 12px;
                        font-weight: 600;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        gap: 4px;
                        transition: all 0.2s;
                    " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)'"
                       onmouseout="this.style.transform=''; this.style.boxShadow=''">
                        <i class="fas fa-check-circle"></i>
                        XÃ¡c nháº­n
                    </button>
                    <button onclick="deleteHeldProduct(${p.ProductId})" style="
                        flex: 1;
                        padding: 6px 12px;
                        background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        font-size: 12px;
                        font-weight: 600;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        gap: 4px;
                        transition: all 0.2s;
                    " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.3)'"
                       onmouseout="this.style.transform=''; this.style.boxShadow=''">
                        <i class="fas fa-trash"></i>
                        XÃ³a
                    </button>
                </div>
                ` : ''}
            </div>
        </div>
    `;
}

// Expose to window for external usage
window.renderChatProductsTable = renderChatProductsTable;

// --- Search Logic ---
var chatSearchTimeout = null;

function initChatProductSearch() {
    const input = document.getElementById("chatInlineProductSearch");
    console.log("[CHAT-SEARCH] Initializing search. Input found:", !!input);

    if (!input) {
        console.error("[CHAT-SEARCH] Search input not found!");
        return;
    }

    // Prevent duplicate listeners using a custom flag
    if (input.dataset.searchInitialized === "true") {
        console.log("[CHAT-SEARCH] Search already initialized for this input");
        return;
    }

    input.dataset.searchInitialized = "true";

    input.addEventListener("input", (e) => {
        const query = e.target.value.trim();
        console.log("[CHAT-SEARCH] Input event:", query);

        if (chatSearchTimeout) clearTimeout(chatSearchTimeout);

        if (query.length < 2) {
            const resultsDiv = document.getElementById("chatInlineSearchResults");
            if (resultsDiv) resultsDiv.style.display = "none";
            return;
        }

        chatSearchTimeout = setTimeout(() => performChatProductSearch(query), 300);
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
        const dropdown = document.getElementById("chatInlineSearchResults");
        const searchContainer = input.closest('.chat-product-search-inline');
        if (dropdown && searchContainer && !searchContainer.contains(e.target)) {
            dropdown.style.display = "none";
        }
    });
}

async function performChatProductSearch(query) {
    console.log("[CHAT-SEARCH] Performing search for:", query);
    const resultsDiv = document.getElementById("chatInlineSearchResults");
    if (!resultsDiv) {
        console.error("[CHAT-SEARCH] Results div not found!");
        return;
    }

    // Force styles to ensure visibility
    resultsDiv.style.display = "block";
    resultsDiv.style.zIndex = "1000";
    resultsDiv.innerHTML = `<div style="padding: 12px; text-align: center; color: #64748b; font-size: 13px;"><i class="fas fa-spinner fa-spin"></i> Äang tÃ¬m kiáº¿m...</div>`;

    try {
        if (!window.productSearchManager) {
            throw new Error("ProductSearchManager not available");
        }

        if (!window.productSearchManager.isLoaded) {
            console.log("[CHAT-SEARCH] Loading products...");
            await window.productSearchManager.fetchExcelProducts();
        }

        const results = window.productSearchManager.search(query, 10);
        console.log("[CHAT-SEARCH] Results found:", results.length);
        displayChatSearchResults(results);
    } catch (error) {
        console.error("[CHAT-SEARCH] Error:", error);
        resultsDiv.innerHTML = `<div style="padding: 12px; text-align: center; color: #ef4444; font-size: 13px;">Lá»—i: ${error.message}</div>`;
    }
}

function displayChatSearchResults(results) {
    const resultsDiv = document.getElementById("chatInlineSearchResults");
    if (!resultsDiv) return;

    // Ensure visibility and styling
    resultsDiv.style.display = "block";
    resultsDiv.style.zIndex = "1000";
    resultsDiv.style.maxHeight = "400px";
    resultsDiv.style.overflowY = "auto";
    resultsDiv.style.width = "600px"; // Make it wider like the screenshot
    resultsDiv.style.left = "-16px"; // Align with container padding
    resultsDiv.style.boxShadow = "0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)";

    if (!results || results.length === 0) {
        resultsDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: #64748b; font-size: 14px;">KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m phÃ¹ há»£p</div>`;
        return;
    }

    // Check existing products (both main products and held products)
    const productsInOrder = new Map();
    const heldProductIds = new Set();

    // Check main products
    currentChatOrderDetails.forEach(d => {
        productsInOrder.set(d.ProductId, (productsInOrder.get(d.ProductId) || 0) + (d.Quantity || 0));
    });

    // Check held products from window.currentChatOrderData.Details
    if (window.currentChatOrderData && window.currentChatOrderData.Details) {
        window.currentChatOrderData.Details.forEach(d => {
            if (d.IsHeld) {
                heldProductIds.add(d.ProductId);
                productsInOrder.set(d.ProductId, (productsInOrder.get(d.ProductId) || 0) + (d.Quantity || 0));
            }
        });
    }

    resultsDiv.innerHTML = results.map(p => {
        const isInOrder = productsInOrder.has(p.Id);
        const isHeld = heldProductIds.has(p.Id);
        const currentQty = productsInOrder.get(p.Id) || 0;

        return `
        <div class="chat-search-item ${isInOrder ? 'in-order' : ''}" data-product-id="${p.Id}" onclick="window.chatProductManager?.addProductFromSearch(${p.Id})" style="
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            align-items: center;
            gap: 16px;
            background: white;
            transition: background 0.2s;
            cursor: pointer;
            position: relative; /* For badge positioning */
        " onmouseover="this.style.background='#f8fafc'" onmouseout="this.style.background='white'">
            
            ${isInOrder ? `
            <div class="chat-search-qty-badge" style="
                position: absolute;
                top: 4px;
                right: 4px;
                background: ${isHeld ? '#f59e0b' : '#10b981'};
                color: white;
                font-size: 10px;
                padding: 2px 6px;
                border-radius: 10px;
                font-weight: 600;
                z-index: 10;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            "><i class="fas ${isHeld ? 'fa-hand-paper' : 'fa-shopping-cart'}"></i> ${isHeld ? 'Giá»¯' : 'SL'}: ${currentQty}</div>
            ` : ''}

            <!-- Image -->
            <div style="
                width: 48px; 
                height: 48px; 
                border-radius: 6px; 
                background: #f1f5f9; 
                overflow: hidden; 
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                border: 1px solid #e2e8f0;
            ">
                ${(p.ImageUrl || (p.Thumbnails && p.Thumbnails[0]) || p.Parent?.ImageUrl)
                ? `<img src="${p.ImageUrl || (p.Thumbnails && p.Thumbnails[0]) || p.Parent?.ImageUrl}" style="width: 100%; height: 100%; object-fit: cover;">`
                : `<i class="fas fa-image" style="color: #cbd5e1; font-size: 20px;"></i>`}
            </div>

            <!-- Info -->
            <div style="flex: 1; min-width: 0;">
                <div style="
                    font-size: 14px; 
                    font-weight: 600; 
                    color: #1e293b; 
                    margin-bottom: 4px;
                    white-space: nowrap; 
                    overflow: hidden; 
                    text-overflow: ellipsis;
                ">${p.Name}</div>
                <div style="font-size: 12px; color: #64748b;">
                    MÃ£: <span style="font-family: monospace; color: #475569;">${p.Code || 'N/A'}</span>
                </div>
            </div>

            <!-- Price -->
            <div style="
                font-size: 14px; 
                font-weight: 700; 
                color: #10b981; 
                text-align: right;
                min-width: 80px;
            ">
                ${(p.Price || 0).toLocaleString("vi-VN")}Ä‘
            </div>

            <!-- Add Button -->
            <button style="
                width: 32px;
                height: 32px;
                border-radius: 50%;
                border: none;
                background: ${isInOrder ? '#dcfce7' : '#f1f5f9'};
                color: ${isInOrder ? '#10b981' : '#64748b'};
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s;
            " onmouseover="this.style.background='${isInOrder ? '#dcfce7' : '#e2e8f0'}'" onmouseout="this.style.background='${isInOrder ? '#dcfce7' : '#f1f5f9'}'">
                <i class="fas ${isInOrder ? 'fa-check' : 'fa-plus'}"></i>
            </button>
        </div>`;
    }).join("");
}

function updateChatProductItemUI(productId) {
    const item = document.querySelector(`.chat-search-item[data-product-id="${productId}"]`);
    if (!item) return;

    // Add animation class (assuming CSS exists or we add inline style for animation)
    item.style.transition = "background 0.3s";
    item.style.background = "#dcfce7";
    setTimeout(() => {
        item.style.background = "white";
    }, 500);

    // Update quantity badge
    const existing = currentChatOrderDetails.find(d => d.ProductId == productId);
    const qty = existing ? existing.Quantity : 0;

    let badge = item.querySelector('.chat-search-qty-badge');
    if (!badge) {
        badge = document.createElement('div');
        badge.className = 'chat-search-qty-badge';
        badge.style.cssText = `
            position: absolute;
            top: 4px;
            right: 4px;
            background: #10b981;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        `;
        item.appendChild(badge);
    }
    badge.innerHTML = `<i class="fas fa-shopping-cart"></i> SL: ${qty}`;

    // Update button
    const btn = item.querySelector('button');
    if (btn) {
        btn.style.background = '#dcfce7';
        btn.style.color = '#10b981';
        btn.innerHTML = '<i class="fas fa-check"></i>';
    }

    if (!item.classList.contains('in-order')) {
        item.classList.add('in-order');
    }
}

// =====================================================
// FIREBASE SYNC HELPER
// =====================================================
function saveChatProductsToFirebase(orderId, products) {
    if (!database || !orderId) return;
    const ref = database.ref('order_products/' + orderId);
    ref.set(products).catch(err => console.error("[CHAT-FIREBASE] Save error:", err));
}

/**
 * Add product from search to chat order
 */
async function addChatProductFromSearch(productId) {
    // Show loading state on the clicked item
    const searchItem = document.querySelector(`.chat-search-item[data-product-id="${productId}"]`);
    const originalContent = searchItem ? searchItem.innerHTML : '';
    if (searchItem) {
        searchItem.innerHTML = `<div style="text-align: center; width: 100%; color: #6366f1;"><i class="fas fa-spinner fa-spin"></i> Äang táº£i thÃ´ng tin...</div>`;
        searchItem.style.pointerEvents = 'none';
    }

    try {
        // Normalize productId to number
        const normalizedProductId = parseInt(productId);
        if (isNaN(normalizedProductId)) {
            throw new Error("Invalid product ID");
        }

        // Check if order data is available
        if (!window.currentChatOrderData) {
            throw new Error("Vui lÃ²ng má»Ÿ má»™t Ä‘Æ¡n hÃ ng trÆ°á»›c khi thÃªm sáº£n pháº©m");
        }

        // Ensure Details array exists
        if (!window.currentChatOrderData.Details) {
            window.currentChatOrderData.Details = [];
        }

        // 1. Fetch full details from TPOS (Required)
        const fullProduct = await window.productSearchManager.getFullProductDetails(normalizedProductId);
        if (!fullProduct) throw new Error("KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin sáº£n pháº©m");

        // Logic to inherit image from Product Template if missing (Variant logic)
        if ((!fullProduct.ImageUrl || fullProduct.ImageUrl === "") && (!fullProduct.Thumbnails || fullProduct.Thumbnails.length === 0)) {
            if (fullProduct.ProductTmplId) {
                try {
                    console.log(`[CHAT-ADD] Fetching product template ${fullProduct.ProductTmplId} for image fallback`);
                    const templateApiUrl = window.productSearchManager.PRODUCT_API_BASE.replace('/Product', '/ProductTemplate');
                    const url = `${templateApiUrl}(${fullProduct.ProductTmplId})?$expand=Images`;

                    const headers = await window.tokenManager.getAuthHeader();
                    const response = await fetch(url, {
                        method: "GET",
                        headers: headers,
                    });

                    if (response.ok) {
                        const templateData = await response.json();
                        if (templateData.ImageUrl) fullProduct.ImageUrl = templateData.ImageUrl;
                    }
                } catch (e) {
                    console.warn(`[CHAT-ADD] Failed to fetch product template ${fullProduct.ProductTmplId}`, e);
                }
            }
        }

        // Validate sale price (only use PriceVariant or ListPrice, never StandardPrice)
        const salePrice = fullProduct.PriceVariant || fullProduct.ListPrice;
        if (salePrice == null || salePrice < 0) {
            console.error(`[CHAT-ADD] âŒ Sáº£n pháº©m "${fullProduct.Name || fullProduct.DefaultCode}" (ID: ${fullProduct.Id}) khÃ´ng cÃ³ giÃ¡ bÃ¡n.`);
            throw new Error(`Sáº£n pháº©m "${fullProduct.Name || fullProduct.DefaultCode}" (ID: ${fullProduct.Id}) khÃ´ng cÃ³ giÃ¡ bÃ¡n.`);
        }

        // 2. Check if already exists in HELD list (merge quantity)
        const existingHeldIndex = window.currentChatOrderData?.Details?.findIndex(
            p => p.ProductId === normalizedProductId && p.IsHeld === true
        ) ?? -1;

        if (existingHeldIndex >= 0) {
            // Product already in held list - increment quantity
            window.currentChatOrderData.Details[existingHeldIndex].Quantity += 1;
            console.log('[CHAT-ADD] Merged with existing held product, new qty:',
                window.currentChatOrderData.Details[existingHeldIndex].Quantity);
        } else {
            // 3. Create new HELD product object (similar to moveDroppedToOrder)
            const heldProduct = {
                ProductId: fullProduct.Id,
                Quantity: 1,
                Price: salePrice,
                Note: null,
                UOMId: fullProduct.UOM?.Id || 1,
                Factor: 1,
                Priority: 0,
                OrderId: window.currentChatOrderData?.Id || currentChatOrderId,
                LiveCampaign_DetailId: null,
                ProductWeight: 0,

                // COMPUTED FIELDS
                ProductName: fullProduct.Name || fullProduct.NameTemplate,
                ProductNameGet: fullProduct.NameGet || `[${fullProduct.DefaultCode}] ${fullProduct.Name}`,
                ProductCode: fullProduct.DefaultCode || fullProduct.Barcode,
                UOMName: fullProduct.UOM?.Name || "CÃ¡i",
                ImageUrl: fullProduct.ImageUrl || (fullProduct.Thumbnails && fullProduct.Thumbnails[0]) || fullProduct.Parent?.ImageUrl || '',
                IsOrderPriority: null,
                QuantityRegex: null,
                IsDisabledLiveCampaignDetail: false,

                // HELD product markers
                IsHeld: true,
                IsFromSearch: true,
                StockQty: fullProduct.QtyAvailable || 0,

                // Additional fields for compatibility
                Name: fullProduct.Name,
                Code: fullProduct.DefaultCode || fullProduct.Barcode
            };

            // Add to Details array
            if (window.currentChatOrderData && window.currentChatOrderData.Details) {
                window.currentChatOrderData.Details.push(heldProduct);
            }
        }

        // 4. Sync to Firebase held_products for multi-user collaboration
        const orderId = window.currentChatOrderData?.Id;
        if (window.firebase && window.authManager && orderId) {
            const auth = window.authManager.getAuthState();

            if (auth) {
                let userId = auth.id || auth.Id || auth.username || auth.userType;
                if (!userId && auth.displayName) {
                    userId = auth.displayName.replace(/[.#$/\[\]]/g, '_');
                }

                if (userId) {
                    // Get current held quantity for this user
                    const currentHeldProduct = window.currentChatOrderData.Details.find(
                        p => p.ProductId === normalizedProductId && p.IsHeld
                    );
                    const heldQuantity = currentHeldProduct ? currentHeldProduct.Quantity : 1;

                    // Sync to Firebase
                    const ref = window.firebase.database().ref(`held_products/${orderId}/${normalizedProductId}/${userId}`);

                    await ref.set({
                        productId: normalizedProductId,
                        displayName: auth.displayName || auth.userType || 'Unknown',
                        quantity: heldQuantity,
                        isDraft: true,
                        isFromSearch: true,
                        timestamp: window.firebase.database.ServerValue.TIMESTAMP
                    });

                    console.log('[CHAT-ADD] âœ“ Synced to Firebase held_products:', {
                        orderId,
                        productId: normalizedProductId,
                        userId,
                        quantity: heldQuantity
                    });
                }
            }
        }

        // 5. Re-render UI (held products will show with Confirm/Delete buttons)
        renderChatProductsTable();

        // Show success notification
        if (window.notificationManager) {
            window.notificationManager.show(`âœ“ ÄÃ£ thÃªm "${fullProduct.Name}" vÃ o danh sÃ¡ch giá»¯`, 'info');
        }

        // Clear search input and keep focus
        const searchInput = document.getElementById("chatInlineProductSearch");
        if (searchInput) {
            searchInput.value = '';
            searchInput.focus();
        }

        // Hide search results
        const resultsDiv = document.getElementById("chatInlineSearchResults");
        if (resultsDiv) {
            resultsDiv.style.display = "none";
        }

        console.log('[CHAT-ADD] âœ“ Added product to held list:', normalizedProductId);

    } catch (error) {
        console.error("Error adding product:", error);
        if (searchItem) {
            searchItem.innerHTML = originalContent;
            searchItem.style.pointerEvents = 'auto';
        }
        if (window.notificationManager) {
            window.notificationManager.error("Lá»—i khi thÃªm sáº£n pháº©m: " + error.message);
        } else {
            alert("Lá»—i khi thÃªm sáº£n pháº©m: " + error.message);
        }
    }
}

// Lock state to prevent duplicate confirmHeldProduct calls
const confirmHeldProductLocks = new Set();

/**
 * Confirm held product - Move from held list to main product list
 * Fetches full product details from TPOS, updates order on backend, and removes from Firebase held_products
 * @param {number|string} productId - Product ID (will be normalized to number)
 */
window.confirmHeldProduct = async function (productId) {
    // Normalize productId to number for consistent comparison
    const normalizedProductId = parseInt(productId);
    if (isNaN(normalizedProductId)) {
        console.error('[HELD-CONFIRM] Invalid product ID:', productId);
        if (window.notificationManager) {
            window.notificationManager.error("ID sáº£n pháº©m khÃ´ng há»£p lá»‡");
        }
        return;
    }

    // Lock key includes orderId to allow same product in different orders
    const orderId = window.currentChatOrderData?.Id;
    const lockKey = `${orderId}_${normalizedProductId}`;

    // Check if already processing this product
    if (confirmHeldProductLocks.has(lockKey)) {
        console.warn('[HELD-CONFIRM] Already processing product:', normalizedProductId, '- skipping duplicate call');
        return;
    }

    // Acquire lock
    confirmHeldProductLocks.add(lockKey);
    console.log('[HELD-CONFIRM] Lock acquired for:', lockKey);

    try {
        // Find the held product using normalized ID
        const heldProduct = window.currentChatOrderData?.Details?.find(
            p => p.ProductId === normalizedProductId && p.IsHeld === true
        );

        if (!heldProduct) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m giá»¯");
        }

        // Show loading notification
        if (window.notificationManager) {
            window.notificationManager.show("Äang xÃ¡c nháº­n sáº£n pháº©m...", "info");
        }

        // KPI CHECK: Before confirming first product, ask user if they want to track KPI
        // Get current main products (before adding new one) for potential BASE save
        const currentMainProducts = window.currentChatOrderData.Details.filter(p => !p.IsHeld);
        const orderId = window.currentChatOrderData.Id;
        const orderSTT = window.currentChatOrderData.SessionIndex || window.currentChatOrderData.STT || window.currentChatOrderData.Stt || 0;

        if (window.kpiManager) {
            try {
                // This will check if BASE exists and prompt user if not
                await window.kpiManager.promptAndSaveKPIBase(orderId, orderSTT, currentMainProducts);
            } catch (kpiError) {
                console.warn('[HELD-CONFIRM] KPI check failed (non-blocking):', kpiError);
            }
        }

        // Fetch full product details from TPOS using normalized ID
        const fullProduct = await window.productSearchManager.getFullProductDetails(normalizedProductId);
        if (!fullProduct) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin sáº£n pháº©m tá»« TPOS");
        }

        // Fetch product template image if needed
        if ((!fullProduct.ImageUrl || fullProduct.ImageUrl === "") &&
            (!fullProduct.Thumbnails || fullProduct.Thumbnails.length === 0)) {
            if (fullProduct.ProductTmplId) {
                try {
                    const templateApiUrl = window.productSearchManager.PRODUCT_API_BASE.replace('/Product', '/ProductTemplate');
                    const url = `${templateApiUrl}(${fullProduct.ProductTmplId})?$expand=Images`;
                    const headers = await window.tokenManager.getAuthHeader();
                    const response = await fetch(url, { method: "GET", headers: headers });

                    if (response.ok) {
                        const templateData = await response.json();
                        if (templateData.ImageUrl) fullProduct.ImageUrl = templateData.ImageUrl;
                    }
                } catch (e) {
                    console.warn(`[HELD-CONFIRM] Failed to fetch product template ${fullProduct.ProductTmplId}`, e);
                }
            }
        }

        // Validate sale price
        const salePrice = fullProduct.PriceVariant || fullProduct.ListPrice;
        if (salePrice == null || salePrice < 0) {
            throw new Error(`Sáº£n pháº©m "${fullProduct.Name || fullProduct.DefaultCode}" khÃ´ng cÃ³ giÃ¡ bÃ¡n`);
        }

        // STEP 1: Remove held product from local Details array first
        window.currentChatOrderData.Details = window.currentChatOrderData.Details.filter(
            p => !(p.ProductId === normalizedProductId && p.IsHeld === true)
        );

        // STEP 2: Check if product already exists in main list (non-held) using normalized ID
        const existingIndex = window.currentChatOrderData.Details.findIndex(
            p => p.ProductId === normalizedProductId && !p.IsHeld
        );

        let newProduct = null;

        if (existingIndex >= 0) {
            // Add quantity to existing product
            window.currentChatOrderData.Details[existingIndex].Quantity += heldProduct.Quantity;
            console.log('[HELD-CONFIRM] Merged with existing product, new qty:',
                window.currentChatOrderData.Details[existingIndex].Quantity);
        } else {
            // Create new product object for main list
            newProduct = {
                ProductId: fullProduct.Id,
                Quantity: heldProduct.Quantity,
                Price: salePrice,
                Note: null,
                UOMId: fullProduct.UOM?.Id || 1,
                Factor: 1,
                Priority: 0,
                OrderId: window.currentChatOrderData.Id,
                LiveCampaign_DetailId: null,
                ProductWeight: 0,

                // Computed fields - use original names from held product if available
                ProductName: heldProduct.ProductName || fullProduct.Name || fullProduct.NameTemplate,
                ProductNameGet: heldProduct.ProductNameGet || fullProduct.NameGet || `[${fullProduct.DefaultCode}] ${fullProduct.Name}`,
                ProductCode: fullProduct.DefaultCode || fullProduct.Barcode,
                UOMName: fullProduct.UOM?.Name || "CÃ¡i",
                ImageUrl: fullProduct.ImageUrl || (fullProduct.Thumbnails && fullProduct.Thumbnails[0]) || fullProduct.Parent?.ImageUrl || '',
                IsOrderPriority: null,
                QuantityRegex: null,
                IsDisabledLiveCampaignDetail: false,

                // Additional fields
                Name: heldProduct.ProductName || heldProduct.Name || fullProduct.Name,
                Code: fullProduct.DefaultCode || fullProduct.Barcode
            };

            window.currentChatOrderData.Details.push(newProduct);
        }

        // STEP 3: Get only main products (non-held) for API update
        const mainProducts = window.currentChatOrderData.Details.filter(p => !p.IsHeld);
        const totalQuantity = mainProducts.reduce((sum, p) => sum + (p.Quantity || 0), 0);
        const totalAmount = mainProducts.reduce((sum, p) => sum + ((p.Quantity || 0) * (p.Price || 0)), 0);

        console.log('[HELD-CONFIRM] Updating order on backend:', {
            orderId: window.currentChatOrderData.Id,
            mainProductsCount: mainProducts.length,
            totalQuantity,
            totalAmount
        });

        // STEP 4: Update order on backend via API
        await updateOrderWithFullPayload(
            window.currentChatOrderData,
            mainProducts,
            totalAmount,
            totalQuantity
        );

        console.log('[HELD-CONFIRM] âœ“ Order updated on backend');

        // STEP 5: Remove from Firebase held_products
        if (typeof window.removeHeldProduct === 'function') {
            await window.removeHeldProduct(normalizedProductId);
            console.log('[HELD-CONFIRM] âœ“ Removed from Firebase held_products');
        }

        // STEP 6: Sync currentChatOrderDetails for consistency
        currentChatOrderDetails = window.currentChatOrderData.Details.filter(p => !p.IsHeld);

        // STEP 7: Re-render Orders tab
        renderChatProductsTable();
        // REMOVED: saveChatProductsToFirebase - order_products/shared khÃ´ng cÃ²n listener

        // STEP 8: Trigger Dropped tab re-render to update "NgÆ°á»i giá»¯" status
        if (typeof window.renderDroppedProductsTable === 'function') {
            await window.renderDroppedProductsTable();
        }

        // Show success notification
        if (window.notificationManager) {
            window.notificationManager.show("âœ… ÄÃ£ xÃ¡c nháº­n vÃ  thÃªm vÃ o Ä‘Æ¡n hÃ ng", "success");
        }

        console.log('[HELD-CONFIRM] âœ“ Confirmed held product:', normalizedProductId);

    } catch (error) {
        console.error('[HELD-CONFIRM] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error("âŒ Lá»—i khi xÃ¡c nháº­n: " + error.message);
        } else {
            alert("âŒ Lá»—i khi xÃ¡c nháº­n: " + error.message);
        }
    } finally {
        // Always release the lock
        const orderId = window.currentChatOrderData?.Id;
        const lockKey = `${orderId}_${normalizedProductId}`;
        confirmHeldProductLocks.delete(lockKey);
        console.log('[HELD-CONFIRM] Lock released for:', lockKey);
    }
};

/**
 * Delete held product - Remove from held list with confirmation
 * @param {number|string} productId - Product ID (will be normalized to number)
 */
window.deleteHeldProduct = async function (productId) {
    try {
        // Normalize productId to number for consistent comparison
        const normalizedProductId = parseInt(productId);
        if (isNaN(normalizedProductId)) {
            throw new Error("Invalid product ID");
        }

        // Find the held product using normalized ID
        const heldProduct = window.currentChatOrderData?.Details?.find(
            p => p.ProductId === normalizedProductId && p.IsHeld === true
        );

        if (!heldProduct) {
            if (window.notificationManager) {
                window.notificationManager.error("KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m giá»¯");
            }
            return;
        }

        // Show confirmation dialog
        const confirmed = window.CustomPopup
            ? await window.CustomPopup.confirm(
                `Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a sáº£n pháº©m "${heldProduct.ProductName || heldProduct.Name}" khá»i danh sÃ¡ch giá»¯?`,
                'XÃ¡c nháº­n xÃ³a'
            )
            : confirm(`Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a sáº£n pháº©m "${heldProduct.ProductName || heldProduct.Name}" khá»i danh sÃ¡ch giá»¯?`);

        if (!confirmed) return;

        // Remove from Firebase held_products using normalized ID
        if (typeof window.removeHeldProduct === 'function') {
            await window.removeHeldProduct(normalizedProductId);
        }

        // Trigger Dropped tab re-render to update "NgÆ°á»i giá»¯" status
        if (typeof window.renderDroppedProductsTable === 'function') {
            await window.renderDroppedProductsTable();
        }

        // Show success notification
        if (window.notificationManager) {
            window.notificationManager.show("âœ… ÄÃ£ xÃ³a sáº£n pháº©m khá»i danh sÃ¡ch giá»¯", "success");
        }

        console.log('[HELD-DELETE] âœ“ Deleted held product:', normalizedProductId);

    } catch (error) {
        console.error('[HELD-DELETE] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error("âŒ Lá»—i khi xÃ³a: " + error.message);
        } else {
            alert("âŒ Lá»—i khi xÃ³a: " + error.message);
        }
    }
};

// --- Action Logic ---

/**
 * Update held product quantity by ProductId
 * This version uses ProductId instead of array index to avoid bugs when arrays are filtered
 * @param {number} productId - Product ID to update
 * @param {number} delta - Amount to add/subtract (-1 or +1)
 * @param {string|null} specificValue - Specific value to set (from input field)
 */
window.updateHeldProductQuantityById = function (productId, delta, specificValue = null) {
    // Normalize productId
    const normalizedProductId = parseInt(productId);
    if (isNaN(normalizedProductId)) {
        console.error('[UPDATE-QTY] Invalid productId:', productId);
        return;
    }

    // Get the correct data source
    const productsArray = (window.currentChatOrderData && window.currentChatOrderData.Details)
        ? window.currentChatOrderData.Details
        : currentChatOrderDetails;

    // Find product by ProductId and IsHeld flag
    const product = productsArray.find(p => p.ProductId === normalizedProductId && p.IsHeld === true);
    if (!product) {
        console.error('[UPDATE-QTY] Held product not found:', normalizedProductId);
        return;
    }

    // Update quantity
    if (specificValue !== null) {
        const val = parseInt(specificValue);
        if (val > 0) product.Quantity = val;
    } else {
        const newQty = (product.Quantity || 0) + delta;
        if (newQty > 0) product.Quantity = newQty;
    }

    // Sync to Firebase
    if (typeof window.updateHeldProductQuantity === 'function') {
        window.updateHeldProductQuantity(product.ProductId, product.Quantity);
    }

    // Sync both arrays if needed
    if (window.currentChatOrderData && window.currentChatOrderData.Details) {
        currentChatOrderDetails = window.currentChatOrderData.Details.filter(p => !p.IsHeld);
    }

    renderChatProductsTable();
    // REMOVED: saveChatProductsToFirebase - order_products/shared khÃ´ng cÃ²n listener
};

/**
 * Decrease main product quantity by ProductId
 * Shows confirmation, updates order via API, moves 1 product to dropped
 * @param {number} productId - Product ID to decrease
 */
window.decreaseMainProductQuantityById = async function (productId) {
    // Normalize productId
    const normalizedProductId = parseInt(productId);
    if (isNaN(normalizedProductId)) {
        console.error('[DECREASE] Invalid productId:', productId);
        return;
    }

    // Get the correct data source
    const productsArray = (window.currentChatOrderData && window.currentChatOrderData.Details)
        ? window.currentChatOrderData.Details
        : currentChatOrderDetails;

    // Find product by ProductId (non-held only)
    const product = productsArray.find(p => p.ProductId === normalizedProductId && !p.IsHeld);
    if (!product) {
        console.error('[DECREASE] Main product not found:', normalizedProductId);
        return;
    }

    // Show confirmation
    const productName = product.ProductName || product.Name || 'Sáº£n pháº©m';
    const confirmMsg = `XÃ³a 1 "${productName}" khá»i Ä‘Æ¡n hÃ ng?\n\nSáº£n pháº©m sáº½ Ä‘Æ°á»£c chuyá»ƒn sang hÃ ng rá»›t-xáº£.`;

    let confirmed = false;
    if (window.CustomPopup) {
        confirmed = await window.CustomPopup.confirm(confirmMsg, 'XÃ¡c nháº­n xÃ³a sáº£n pháº©m');
    } else {
        confirmed = confirm(confirmMsg);
    }

    if (!confirmed) return;

    try {
        // Show loading
        if (window.notificationManager) {
            window.notificationManager.show("Äang cáº­p nháº­t Ä‘Æ¡n hÃ ng...", "info");
        }

        // Fetch latest order data from API to ensure we have fresh data
        const orderId = window.currentChatOrderData?.Id;
        if (!orderId) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng");
        }

        console.log('[DECREASE-BY-ID] Fetching latest order data:', orderId);
        const freshOrderData = await getOrderDetails(orderId);

        // Update window.currentChatOrderData with fresh data
        window.currentChatOrderData = freshOrderData;

        // Find the product in fresh data by ProductId
        const freshProductIndex = freshOrderData.Details.findIndex(
            p => p.ProductId === normalizedProductId && !p.IsHeld
        );

        if (freshProductIndex === -1) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m trong Ä‘Æ¡n hÃ ng");
        }

        const freshProduct = freshOrderData.Details[freshProductIndex];

        // Create product object to add to dropped
        const droppedProductData = {
            ProductId: freshProduct.ProductId,
            ProductName: freshProduct.ProductName || freshProduct.Name,
            ProductCode: freshProduct.ProductCode || freshProduct.Code,
            Price: freshProduct.Price || 0,
            ImageUrl: freshProduct.ImageUrl || '',
            UOMId: freshProduct.UOMId || 1,
            UOMName: freshProduct.UOMName || 'CÃ¡i',
            Quantity: 1 // Moving 1 quantity to dropped
        };

        console.log('[DECREASE-BY-ID] Moving 1 to dropped:', droppedProductData);

        // Add to dropped products
        if (typeof window.addToDroppedProducts === 'function') {
            await window.addToDroppedProducts(droppedProductData, 1, 'removed', null);
        }

        // Decrease quantity in order
        if (freshProduct.Quantity <= 1) {
            // Remove product entirely
            freshOrderData.Details.splice(freshProductIndex, 1);
        } else {
            // Decrease by 1
            freshProduct.Quantity -= 1;
        }

        // Get only main products for API update
        const newDetails = freshOrderData.Details.filter(p => !p.IsHeld);
        const totalQuantity = newDetails.reduce((sum, p) => sum + (p.Quantity || 0), 0);
        const totalAmount = newDetails.reduce((sum, p) => sum + ((p.Quantity || 0) * (p.Price || 0)), 0);

        console.log('[DECREASE-BY-ID] Updating order on backend:', {
            orderId: freshOrderData.Id,
            newDetailsCount: newDetails.length,
            totalQuantity,
            totalAmount
        });

        // Update order on backend
        await updateOrderWithFullPayload(
            freshOrderData,
            newDetails,
            totalAmount,
            totalQuantity
        );

        console.log('[DECREASE-BY-ID] âœ“ Order updated successfully');

        // Sync arrays
        currentChatOrderDetails = freshOrderData.Details.filter(p => !p.IsHeld);

        // Re-render UI
        renderChatProductsTable();
        // REMOVED: saveChatProductsToFirebase - order_products/shared khÃ´ng cÃ²n listener

        // Re-render Dropped tab if visible
        if (typeof window.renderDroppedProductsTable === 'function') {
            await window.renderDroppedProductsTable();
        }

        // Show success notification
        if (window.notificationManager) {
            window.notificationManager.show("âœ… ÄÃ£ chuyá»ƒn 1 sáº£n pháº©m sang hÃ ng rá»›t", "success");
        }

    } catch (error) {
        console.error('[DECREASE-BY-ID] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error("âŒ Lá»—i: " + error.message);
        }
    }
};

/**
 * Update product quantity in chat order (legacy - by index)
 * @deprecated Use updateHeldProductQuantityById instead
 * Works with both currentChatOrderDetails and window.currentChatOrderData.Details
 * Syncs held products to Firebase for multi-user collaboration
 */
function updateChatProductQuantity(index, delta, specificValue = null) {
    // Get the correct data source
    const productsArray = (window.currentChatOrderData && window.currentChatOrderData.Details)
        ? window.currentChatOrderData.Details
        : currentChatOrderDetails;

    if (index < 0 || index >= productsArray.length) return;

    const product = productsArray[index];
    const isHeldProduct = product.IsHeld === true;

    if (specificValue !== null) {
        const val = parseInt(specificValue);
        if (val > 0) product.Quantity = val;
    } else {
        const newQty = (product.Quantity || 0) + delta;
        if (newQty > 0) product.Quantity = newQty;
    }

    // If it's a held product, sync to Firebase
    if (isHeldProduct && typeof window.updateHeldProductQuantity === 'function') {
        window.updateHeldProductQuantity(product.ProductId, product.Quantity);
    }

    // Sync both arrays if needed
    if (window.currentChatOrderData && window.currentChatOrderData.Details) {
        currentChatOrderDetails = window.currentChatOrderData.Details.filter(p => !p.IsHeld);
    }

    renderChatProductsTable();
    // REMOVED: saveChatProductsToFirebase - order_products/shared khÃ´ng cÃ²n listener
}

/**
 * Decrease main product quantity by 1
 * Shows confirmation, updates order via API, moves 1 product to dropped
 * @param {number} index - Product index in Details array
 */
async function decreaseMainProductQuantity(index) {
    // Get the correct data source
    const productsArray = (window.currentChatOrderData && window.currentChatOrderData.Details)
        ? window.currentChatOrderData.Details
        : currentChatOrderDetails;

    if (index < 0 || index >= productsArray.length) return;

    const product = productsArray[index];

    // Skip if held product
    if (product.IsHeld === true) {
        console.log('[DECREASE] Skipping held product');
        return;
    }

    // Show confirmation
    const productName = product.ProductName || product.Name || 'Sáº£n pháº©m';
    const confirmMsg = `XÃ³a 1 "${productName}" khá»i Ä‘Æ¡n hÃ ng?\n\nSáº£n pháº©m sáº½ Ä‘Æ°á»£c chuyá»ƒn sang hÃ ng rá»›t-xáº£.`;

    let confirmed = false;
    if (window.CustomPopup) {
        confirmed = await window.CustomPopup.confirm(confirmMsg, 'XÃ¡c nháº­n xÃ³a sáº£n pháº©m');
    } else {
        confirmed = confirm(confirmMsg);
    }

    if (!confirmed) return;

    try {
        // Show loading
        if (window.notificationManager) {
            window.notificationManager.show("Äang cáº­p nháº­t Ä‘Æ¡n hÃ ng...", "info");
        }

        // Fetch latest order data from API to ensure we have fresh data
        const orderId = window.currentChatOrderData?.Id;
        if (!orderId) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng");
        }

        console.log('[DECREASE] Fetching latest order data:', orderId);
        const freshOrderData = await getOrderDetails(orderId);

        // Update window.currentChatOrderData with fresh data
        window.currentChatOrderData = freshOrderData;

        // Find the product in fresh data by ProductId
        const freshProductIndex = freshOrderData.Details.findIndex(
            p => p.ProductId === product.ProductId && !p.IsHeld
        );

        if (freshProductIndex === -1) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m trong Ä‘Æ¡n hÃ ng");
        }

        const freshProduct = freshOrderData.Details[freshProductIndex];
        const currentQty = freshProduct.Quantity || 1;

        // Add 1 product to dropped
        if (typeof window.addToDroppedProducts === 'function') {
            await window.addToDroppedProducts(freshProduct, 1, 'removed', null);
            console.log('[DECREASE] âœ“ Added 1 to dropped products');
        }

        // Update quantity or remove if qty becomes 0
        if (currentQty <= 1) {
            // Remove product from order
            freshOrderData.Details.splice(freshProductIndex, 1);
            console.log('[DECREASE] Removed product (qty was 1)');
        } else {
            // Decrease quantity by 1
            freshOrderData.Details[freshProductIndex].Quantity = currentQty - 1;
            console.log('[DECREASE] Decreased quantity:', currentQty, 'â†’', currentQty - 1);
        }

        // Get main products (non-held) for API update
        const mainProducts = freshOrderData.Details.filter(p => !p.IsHeld);
        const totalQuantity = mainProducts.reduce((sum, p) => sum + (p.Quantity || 0), 0);
        const totalAmount = mainProducts.reduce((sum, p) => sum + ((p.Quantity || 0) * (p.Price || 0)), 0);

        // Update order on backend
        await updateOrderWithFullPayload(
            freshOrderData,
            mainProducts,
            totalAmount,
            totalQuantity
        );

        console.log('[DECREASE] âœ“ Order updated on backend');

        // Update local data
        window.currentChatOrderData = freshOrderData;
        currentChatOrderDetails = mainProducts;

        // Re-render UI
        renderChatProductsTable();
        // REMOVED: saveChatProductsToFirebase - order_products/shared khÃ´ng cÃ²n listener

        // Re-render dropped tab
        if (typeof window.renderDroppedProductsTable === 'function') {
            await window.renderDroppedProductsTable();
        }

        // Show success
        if (window.notificationManager) {
            window.notificationManager.show("âœ… ÄÃ£ xÃ³a 1 sáº£n pháº©m khá»i Ä‘Æ¡n hÃ ng", "success");
        }

    } catch (error) {
        console.error('[DECREASE] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error("âŒ Lá»—i: " + error.message);
        } else {
            alert("âŒ Lá»—i: " + error.message);
        }
    }
}

// Expose to window
window.decreaseMainProductQuantity = decreaseMainProductQuantity;

/**
 * Remove product from chat order
 * - Shows confirmation dialog
 * - Adds product to Dropped Products tab (with held status if applicable)
 * - Updates order on backend (for non-held products)
 * - Removes held products from Firebase
 * - Rollback on error
 */
async function removeChatProduct(index) {
    // Show confirmation using CustomPopup
    const confirmed = window.CustomPopup
        ? await window.CustomPopup.confirm("Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a sáº£n pháº©m nÃ y?", "XÃ¡c nháº­n xÃ³a")
        : confirm("Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a sáº£n pháº©m nÃ y?");

    if (!confirmed) return;

    // Get the correct data source
    const productsArray = (window.currentChatOrderData && window.currentChatOrderData.Details)
        ? window.currentChatOrderData.Details
        : currentChatOrderDetails;

    if (index < 0 || index >= productsArray.length) return;

    const product = productsArray[index];
    const isHeldProduct = product.IsHeld === true;

    // Show loading notification (non-blocking)
    if (window.notificationManager) {
        window.notificationManager.show("Äang xÃ³a sáº£n pháº©m...", "info");
    }

    // Remove from local array (save for rollback)
    const removedProduct = productsArray.splice(index, 1)[0];

    try {
        // 1. Add to Dropped Products tab (with held status)
        if (typeof window.addToDroppedProducts === 'function') {
            await window.addToDroppedProducts(
                removedProduct,
                removedProduct.Quantity,
                'removed',
                isHeldProduct ? removedProduct.HeldBy : null  // Pass holder name if held
            );
        }

        // 2. If held product, remove from Firebase held_products
        if (isHeldProduct && typeof window.removeHeldProduct === 'function') {
            await window.removeHeldProduct(removedProduct.ProductId);
        }

        // 3. Update order on backend (only for non-held products)
        if (!isHeldProduct && window.currentChatOrderData) {
            const newDetails = productsArray.filter(p => !p.IsHeld);
            const totalQuantity = newDetails.reduce((sum, p) => sum + (p.Quantity || 0), 0);
            const totalAmount = newDetails.reduce((sum, p) => sum + ((p.Quantity || 0) * (p.Price || 0)), 0);

            console.log('[REMOVE-PRODUCT] Updating order on backend:', {
                orderId: window.currentChatOrderData.Id,
                newDetailsCount: newDetails.length,
                totalQuantity,
                totalAmount
            });

            await updateOrderWithFullPayload(
                window.currentChatOrderData,
                newDetails,
                totalAmount,
                totalQuantity
            );

            console.log('[REMOVE-PRODUCT] âœ“ Order updated successfully');
        }

        // 4. Sync both arrays if needed
        if (window.currentChatOrderData && window.currentChatOrderData.Details) {
            currentChatOrderDetails = window.currentChatOrderData.Details.filter(p => !p.IsHeld);
        }

        // 5. Re-render UI
        renderChatProductsTable();
        // REMOVED: saveChatProductsToFirebase - order_products/shared khÃ´ng cÃ²n listener

        // 6. Show success notification
        if (window.notificationManager) {
            window.notificationManager.show("âœ… ÄÃ£ xÃ³a sáº£n pháº©m", "success");
        }

    } catch (error) {
        // ROLLBACK on error
        console.error('[REMOVE-PRODUCT] Error:', error);

        // Restore product at original position
        productsArray.splice(index, 0, removedProduct);

        // Sync arrays
        if (window.currentChatOrderData && window.currentChatOrderData.Details) {
            currentChatOrderDetails = window.currentChatOrderData.Details.filter(p => !p.IsHeld);
        }

        // Re-render to show restored product
        renderChatProductsTable();

        // Show error notification
        if (window.notificationManager) {
            window.notificationManager.error("âŒ Lá»—i khi xÃ³a: " + error.message);
        } else {
            alert("âŒ Lá»—i khi xÃ³a: " + error.message);
        }
    }
}

// =====================================================
// MERGE ORDER PRODUCTS API FUNCTIONS
// =====================================================

/**
 * Get order details with products from API
 * @param {string} orderId - Order ID
 * @returns {Promise<Object>} Order data with Details array
 */
async function getOrderDetails(orderId) {
    try {
        const headers = await window.tokenManager.getAuthHeader();
        const apiUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${orderId})?$expand=Details,Partner,User,CRMTeam`;

        const response = await API_CONFIG.smartFetch(apiUrl, {
            headers: {
                ...headers,
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log(`[MERGE-API] Fetched order ${orderId} with ${data.Details?.length || 0} products`);
        return data;
    } catch (error) {
        console.error(`[MERGE-API] Error fetching order ${orderId}:`, error);
        throw error;
    }
}

/**
 * Update order with full payload via API
 * @param {Object} orderData - Full order data (fetched from API)
 * @param {Array} newDetails - New Details array to set
 * @param {number} totalAmount - Total amount
 * @param {number} totalQuantity - Total quantity
 * @returns {Promise<Object>} Updated order data
 */
async function updateOrderWithFullPayload(orderData, newDetails, totalAmount, totalQuantity) {
    try {
        const headers = await window.tokenManager.getAuthHeader();
        const apiUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${orderData.Id})`;

        // Clone order data and prepare payload (same approach as prepareOrderPayload)
        const payload = JSON.parse(JSON.stringify(orderData));

        // Add @odata.context (CRITICAL for PUT request)
        if (!payload["@odata.context"]) {
            payload["@odata.context"] = "http://tomato.tpos.vn/odata/$metadata#SaleOnline_Order(Details(),Partner(),User(),CRMTeam())/$entity";
        }

        // Get CreatedById from order or auth
        const createdById = orderData.CreatedById || orderData.UserId;

        // Update Details with new products - CLEAN UP to only include API-required fields
        payload.Details = (newDetails || []).map(detail => {
            // Only include fields that API expects
            const cleaned = {
                ProductId: detail.ProductId,
                Quantity: detail.Quantity,
                Price: detail.Price,
                Note: detail.Note || null,
                UOMId: detail.UOMId || 1,
                Factor: detail.Factor || 1,
                Priority: detail.Priority || 0,
                OrderId: orderData.Id,
                LiveCampaign_DetailId: detail.LiveCampaign_DetailId || null,
                ProductWeight: detail.ProductWeight || 0,
                ProductName: detail.ProductName,
                ProductNameGet: detail.ProductNameGet,
                ProductCode: detail.ProductCode,
                UOMName: detail.UOMName || 'CÃ¡i',
                ImageUrl: detail.ImageUrl || '',
                IsOrderPriority: detail.IsOrderPriority || null,
                QuantityRegex: detail.QuantityRegex || null,
                IsDisabledLiveCampaignDetail: detail.IsDisabledLiveCampaignDetail || false,
                CreatedById: detail.CreatedById || createdById  // CRITICAL: Add CreatedById
            };

            // Keep Id if it exists (for existing details)
            if (detail.Id) {
                cleaned.Id = detail.Id;
            }

            return cleaned;
        });

        // Update totals
        payload.TotalAmount = totalAmount || 0;
        payload.TotalQuantity = totalQuantity || 0;

        console.log(`[MERGE-API] Preparing PUT payload for order ${orderData.Id}:`, {
            detailsCount: payload.Details.length,
            totalAmount: payload.TotalAmount,
            totalQuantity: payload.TotalQuantity,
            hasContext: !!payload["@odata.context"],
            hasRowVersion: !!payload.RowVersion
        });

        // Use direct fetch instead of smartFetch to avoid fallback issues
        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                ...headers,
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`[MERGE-API] PUT failed:`, errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        // Handle empty response body (PUT often returns 200 OK with no content)
        let data = null;
        const responseText = await response.text();
        if (responseText && responseText.trim()) {
            try {
                data = JSON.parse(responseText);
            } catch (parseError) {
                console.log(`[MERGE-API] Response is not JSON, treating as success`);
            }
        }

        console.log(`[MERGE-API] âœ… Updated order ${orderData.Id} with ${newDetails.length} products`);
        return data || { success: true, orderId: orderData.Id };
    } catch (error) {
        console.error(`[MERGE-API] Error updating order ${orderData.Id}:`, error);
        throw error;
    }
}

// Export API functions for external modules
window.saveChatProductsToFirebase = saveChatProductsToFirebase;
window.getOrderDetails = getOrderDetails;
window.updateOrderWithFullPayload = updateOrderWithFullPayload;

/**
 * Execute product merge for a single merged order
 * @param {Object} mergedOrder - Merged order object with TargetOrderId and SourceOrderIds
 * @returns {Promise<Object>} Merge result
 */
async function executeMergeOrderProducts(mergedOrder) {
    if (!mergedOrder.IsMerged || !mergedOrder.TargetOrderId || !mergedOrder.SourceOrderIds || mergedOrder.SourceOrderIds.length === 0) {
        console.log('[MERGE-API] Not a merged order or no source orders to merge');
        return { success: false, message: 'Not a merged order' };
    }

    try {
        console.log(`[MERGE-API] Starting merge for phone ${mergedOrder.Telephone}`);
        console.log(`[MERGE-API] Target: STT ${mergedOrder.TargetSTT} (${mergedOrder.TargetOrderId})`);
        console.log(`[MERGE-API] Sources: STT ${mergedOrder.SourceSTTs.join(', ')} (${mergedOrder.SourceOrderIds.length} orders)`);

        // Step 1: Fetch all order details
        const targetOrderData = await getOrderDetails(mergedOrder.TargetOrderId);
        const sourceOrdersData = await Promise.all(
            mergedOrder.SourceOrderIds.map(id => getOrderDetails(id))
        );

        // Step 2: Collect all products and merge by ProductId
        const productMap = new Map(); // key: ProductId, value: product detail

        // Add target order products first
        (targetOrderData.Details || []).forEach(detail => {
            const key = detail.ProductId;
            if (productMap.has(key)) {
                // Same product exists, merge quantity
                const existing = productMap.get(key);
                existing.Quantity = (existing.Quantity || 0) + (detail.Quantity || 0);
                existing.Price = detail.Price; // Keep latest price
            } else {
                productMap.set(key, { ...detail });
            }
        });

        // Add source order products
        sourceOrdersData.forEach((sourceOrder, index) => {
            const sourceProducts = sourceOrder.Details || [];
            console.log(`[MERGE-API] Source STT ${mergedOrder.SourceSTTs[index]}: ${sourceProducts.length} products`);

            sourceProducts.forEach(detail => {
                const key = detail.ProductId;
                if (productMap.has(key)) {
                    // Same product exists, merge quantity
                    const existing = productMap.get(key);
                    existing.Quantity = (existing.Quantity || 0) + (detail.Quantity || 0);
                    console.log(`[MERGE-API] Merged duplicate ProductId ${key}: new qty = ${existing.Quantity}`);
                } else {
                    productMap.set(key, { ...detail });
                }
            });
        });

        // Convert map to array
        const allProducts = Array.from(productMap.values());

        // Calculate totals from merged products
        let totalAmount = 0;
        let totalQuantity = 0;
        allProducts.forEach(p => {
            totalAmount += (p.Price || 0) * (p.Quantity || 0);
            totalQuantity += (p.Quantity || 0);
        });

        console.log(`[MERGE-API] Total products to merge: ${allProducts.length}`);
        console.log(`[MERGE-API] Total amount: ${totalAmount}, Total quantity: ${totalQuantity}`);

        // Step 3: Update target order with all products (using full payload)
        await updateOrderWithFullPayload(targetOrderData, allProducts, totalAmount, totalQuantity);
        console.log(`[MERGE-API] âœ… Updated target order STT ${mergedOrder.TargetSTT} with ${allProducts.length} products`);

        // Step 4: Clear products from source orders (using full payload)
        for (let i = 0; i < mergedOrder.SourceOrderIds.length; i++) {
            const sourceOrder = sourceOrdersData[i];
            const sourceSTT = mergedOrder.SourceSTTs[i];

            await updateOrderWithFullPayload(sourceOrder, [], 0, 0);
            console.log(`[MERGE-API] âœ… Cleared products from source order STT ${sourceSTT}`);
        }

        console.log(`[MERGE-API] âœ… Merge completed successfully!`);
        return {
            success: true,
            message: `ÄÃ£ gá»™p ${sourceOrdersData.length} Ä‘Æ¡n vÃ o STT ${mergedOrder.TargetSTT}`,
            targetSTT: mergedOrder.TargetSTT,
            sourceSTTs: mergedOrder.SourceSTTs,
            totalProducts: allProducts.length
        };

    } catch (error) {
        console.error('[MERGE-API] Error during merge:', error);

        // Extract error response for history logging
        let errorResponse = null;
        if (error.message) {
            // Try to extract HTTP response from error message (format: "HTTP XXX: {response}")
            const httpMatch = error.message.match(/^HTTP \d+:\s*(.+)$/s);
            if (httpMatch) {
                errorResponse = httpMatch[1];
            } else {
                errorResponse = error.message;
            }
        }

        return {
            success: false,
            message: 'Lá»—i: ' + error.message,
            error: error,
            errorResponse: errorResponse
        };
    }
}

/**
 * Execute product merge for all merged orders in current displayed data
 * @returns {Promise<Object>} Bulk merge result
 */
async function executeBulkMergeOrderProducts() {
    try {
        // Group orders by phone number to find duplicates
        const phoneGroups = new Map();
        displayedData.forEach(order => {
            const phone = order.Telephone?.trim();
            if (phone) {
                if (!phoneGroups.has(phone)) {
                    phoneGroups.set(phone, []);
                }
                phoneGroups.get(phone).push(order);
            }
        });

        // Find phone numbers with multiple orders (need merging)
        const mergeableGroups = [];
        phoneGroups.forEach((orders, phone) => {
            if (orders.length > 1) {
                // Sort by SessionIndex (STT) descending - target is highest STT
                orders.sort((a, b) => (b.SessionIndex || 0) - (a.SessionIndex || 0));
                const targetOrder = orders[0];
                const sourceOrders = orders.slice(1);

                mergeableGroups.push({
                    Telephone: phone,
                    TargetOrderId: targetOrder.Id,
                    TargetSTT: targetOrder.SessionIndex,
                    SourceOrderIds: sourceOrders.map(o => o.Id),
                    SourceSTTs: sourceOrders.map(o => o.SessionIndex),
                    IsMerged: true // For compatibility with executeMergeOrderProducts
                });
            }
        });

        if (mergeableGroups.length === 0) {
            if (window.notificationManager) {
                window.notificationManager.show('KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng nÃ o trÃ¹ng SÄT cáº§n gá»™p sáº£n pháº©m.', 'warning');
            }
            return { success: false, message: 'No duplicate phone orders found' };
        }

        const totalSourceOrders = mergeableGroups.reduce((sum, g) => sum + g.SourceOrderIds.length, 0);
        const confirmMsg = `TÃ¬m tháº¥y ${mergeableGroups.length} SÄT trÃ¹ng (${totalSourceOrders + mergeableGroups.length} Ä‘Æ¡n).\n\n` +
            `HÃ nh Ä‘á»™ng nÃ y sáº½:\n` +
            `- Gá»™p sáº£n pháº©m tá»« Ä‘Æ¡n STT nhá» â†’ Ä‘Æ¡n STT lá»›n\n` +
            `- XÃ³a sáº£n pháº©m khá»i ${totalSourceOrders} Ä‘Æ¡n nguá»“n`;

        const confirmed = await window.notificationManager.confirm(confirmMsg, "XÃ¡c nháº­n gá»™p sáº£n pháº©m");
        if (!confirmed) {
            return { success: false, message: 'Cancelled by user' };
        }

        // Show loading indicator
        if (window.notificationManager) {
            window.notificationManager.show(`Äang gá»™p sáº£n pháº©m cho ${mergeableGroups.length} SÄT...`, 'info');
        }

        // Execute merge for each phone group
        const results = [];
        for (let i = 0; i < mergeableGroups.length; i++) {
            const group = mergeableGroups[i];
            console.log(`[MERGE-BULK] Processing ${i + 1}/${mergeableGroups.length}: Phone ${group.Telephone}`);

            const result = await executeMergeOrderProducts(group);
            results.push({ order: group, result });

            // Small delay to avoid rate limiting
            if (i < mergeableGroups.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        // Count successes and failures
        const successCount = results.filter(r => r.result.success).length;
        const failureCount = results.length - successCount;

        // Show summary using custom notification
        if (window.notificationManager) {
            if (failureCount > 0) {
                // Show detailed failure info
                const failedPhones = results.filter(r => !r.result.success).map(r => r.order.Telephone).join(', ');
                window.notificationManager.show(
                    `âš ï¸ Gá»™p ${successCount}/${results.length} Ä‘Æ¡n. Tháº¥t báº¡i: ${failedPhones}`,
                    'warning',
                    8000
                );
            } else {
                window.notificationManager.show(
                    `âœ… ÄÃ£ gá»™p sáº£n pháº©m thÃ nh cÃ´ng cho ${successCount} Ä‘Æ¡n hÃ ng!`,
                    'success',
                    5000
                );
            }
        }
        // Refresh table - fetch fresh data from API and re-render
        try {
            // Reload orders data from current campaign
            await fetchOrders();
            // renderTable and updateStats are called inside fetchOrders flow
        } catch (refreshError) {
            console.warn('[MERGE-BULK] Could not auto-refresh, please reload manually:', refreshError);
            // Fallback: just re-render with current data
            renderTable();
            updateStats();
        }

        return {
            success: true,
            totalOrders: results.length,
            successCount,
            failureCount,
            results
        };

    } catch (error) {
        console.error('[MERGE-BULK] Error during bulk merge:', error);
        if (window.notificationManager) {
            window.notificationManager.show('âŒ Lá»—i khi gá»™p sáº£n pháº©m: ' + error.message, 'error', 5000);
        }
        return { success: false, message: error.message, error };
    }
}

// Make function globally accessible
window.executeMergeOrderProducts = executeMergeOrderProducts;
window.executeBulkMergeOrderProducts = executeBulkMergeOrderProducts;

// =====================================================
// MERGE DUPLICATE ORDERS MODAL FUNCTIONS
// =====================================================

// Store merge clusters data for modal
let mergeClustersData = [];
let selectedMergeClusters = new Set();

/**
 * Show modal with duplicate orders preview
 */
async function showMergeDuplicateOrdersModal() {
    const modal = document.getElementById('mergeDuplicateOrdersModal');
    const modalBody = document.getElementById('mergeDuplicateModalBody');
    const subtitle = document.getElementById('mergeDuplicateModalSubtitle');
    const selectAllCheckbox = document.getElementById('mergeSelectAllCheckbox');

    // Reset state
    mergeClustersData = [];
    selectedMergeClusters.clear();
    selectAllCheckbox.checked = false;

    // Show modal with loading state
    modal.classList.add('show');
    modalBody.innerHTML = `
        <div class="merge-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Äang táº£i dá»¯ liá»‡u Ä‘Æ¡n hÃ ng...</p>
        </div>
    `;

    try {
        // Group orders by phone number to find duplicates
        const phoneGroups = new Map();
        displayedData.forEach(order => {
            const phone = order.Telephone?.trim();
            if (phone) {
                if (!phoneGroups.has(phone)) {
                    phoneGroups.set(phone, []);
                }
                phoneGroups.get(phone).push(order);
            }
        });

        // Find phone numbers with multiple orders (need merging)
        const clusters = [];
        phoneGroups.forEach((orders, phone) => {
            if (orders.length > 1) {
                // Sort by SessionIndex (STT) ascending for display
                orders.sort((a, b) => (a.SessionIndex || 0) - (b.SessionIndex || 0));

                // Target is highest STT (last after sort)
                const targetOrder = orders[orders.length - 1];
                const sourceOrders = orders.slice(0, -1);

                clusters.push({
                    phone,
                    orders: orders,
                    targetOrder,
                    sourceOrders,
                    minSTT: orders[0].SessionIndex || 0
                });
            }
        });

        if (clusters.length === 0) {
            modalBody.innerHTML = `
                <div class="merge-no-duplicates">
                    <i class="fas fa-check-circle"></i>
                    <p>KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng nÃ o trÃ¹ng SÄT cáº§n gá»™p.</p>
                </div>
            `;
            subtitle.textContent = 'KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n trÃ¹ng';
            return;
        }

        // Sort clusters by minSTT
        clusters.sort((a, b) => a.minSTT - b.minSTT);

        // Fetch full details for all orders in all clusters
        const allOrderIds = clusters.flatMap(c => c.orders.map(o => o.Id));
        const orderDetailsMap = new Map();

        // Update loading message
        modalBody.innerHTML = `
            <div class="merge-loading">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Äang táº£i chi tiáº¿t ${allOrderIds.length} Ä‘Æ¡n hÃ ng...</p>
            </div>
        `;

        // Fetch details in batches to avoid rate limiting
        const batchSize = 5;
        for (let i = 0; i < allOrderIds.length; i += batchSize) {
            const batch = allOrderIds.slice(i, i + batchSize);
            const results = await Promise.all(batch.map(id => getOrderDetails(id)));
            results.forEach((detail, idx) => {
                orderDetailsMap.set(batch[idx], detail);
            });

            // Small delay between batches
            if (i + batchSize < allOrderIds.length) {
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }

        // Build clusters with full product details
        mergeClustersData = clusters.map((cluster, index) => {
            const ordersWithDetails = cluster.orders.map(order => {
                const apiOrderData = orderDetailsMap.get(order.Id);

                // Tags láº¥y tá»« displayedData (Ä‘Ã£ cÃ³ sáºµn, khÃ´ng cáº§n tá»« API)
                // Chá»‰ cáº§n Details tá»« API vÃ¬ displayedData khÃ´ng cÃ³ chi tiáº¿t sáº£n pháº©m
                console.log(`[MERGE-MODAL] Order STT ${order.SessionIndex}: Tags from displayedData: ${order.Tags || '(empty)'}`);

                return {
                    ...order,
                    Details: apiOrderData?.Details || []
                    // Tags giá»¯ nguyÃªn tá»« ...order (displayedData)
                };
            });

            // Calculate merged products preview
            const mergedProducts = calculateMergedProductsPreview(ordersWithDetails);

            return {
                id: `cluster_${index}`,
                phone: cluster.phone,
                orders: ordersWithDetails,
                targetOrder: ordersWithDetails[ordersWithDetails.length - 1],
                sourceOrders: ordersWithDetails.slice(0, -1),
                mergedProducts
            };
        });

        // Render clusters
        renderMergeClusters();

        const totalSourceOrders = mergeClustersData.reduce((sum, c) => sum + c.sourceOrders.length, 0);
        subtitle.textContent = `TÃ¬m tháº¥y ${mergeClustersData.length} SÄT trÃ¹ng (${totalSourceOrders + mergeClustersData.length} Ä‘Æ¡n)`;

    } catch (error) {
        console.error('[MERGE-MODAL] Error loading data:', error);
        modalBody.innerHTML = `
            <div class="merge-no-duplicates">
                <i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>
                <p>Lá»—i khi táº£i dá»¯ liá»‡u: ${error.message}</p>
            </div>
        `;
    }
}

/**
 * Calculate merged products preview for a cluster
 */
function calculateMergedProductsPreview(orders) {
    const productMap = new Map(); // key: ProductId, value: merged product

    orders.forEach(order => {
        (order.Details || []).forEach(detail => {
            const key = detail.ProductId;
            if (productMap.has(key)) {
                const existing = productMap.get(key);
                existing.Quantity = (existing.Quantity || 0) + (detail.Quantity || 0);
                // Keep the note from all orders
                if (detail.Note && !existing.Note?.includes(detail.Note)) {
                    existing.Note = existing.Note ? `${existing.Note}, ${detail.Note}` : detail.Note;
                }
            } else {
                productMap.set(key, { ...detail });
            }
        });
    });

    return Array.from(productMap.values());
}

/**
 * Render tag pills for merge modal headers
 * @param {string|Array} tags - Tags as JSON string or array
 * @returns {string} HTML string of tag pills
 */
function renderMergeTagPills(tags) {
    let tagsArray = [];

    if (!tags) return '';

    // Parse tags if string
    if (typeof tags === 'string' && tags.trim() !== '') {
        try {
            tagsArray = JSON.parse(tags);
        } catch (e) {
            console.warn('[renderMergeTagPills] Failed to parse tags:', tags);
            return '';
        }
    } else if (Array.isArray(tags)) {
        tagsArray = tags;
    }

    if (!Array.isArray(tagsArray) || tagsArray.length === 0) return '';

    const pillsHtml = tagsArray.map(t =>
        `<span class="merge-tag-pill" style="background: ${t.Color || '#6b7280'};" title="${escapeHtml(t.Name || '')}">${escapeHtml(t.Name || '')}</span>`
    ).join('');

    return `<div class="merge-header-tags">${pillsHtml}</div>`;
}

/**
 * Render all merge clusters in modal
 */
function renderMergeClusters() {
    const modalBody = document.getElementById('mergeDuplicateModalBody');

    if (mergeClustersData.length === 0) {
        modalBody.innerHTML = `
            <div class="merge-no-duplicates">
                <i class="fas fa-check-circle"></i>
                <p>KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng nÃ o trÃ¹ng SÄT cáº§n gá»™p.</p>
            </div>
        `;
        return;
    }

    const html = mergeClustersData.map(cluster => renderClusterCard(cluster)).join('');
    modalBody.innerHTML = html;

    updateConfirmButtonState();
}

/**
 * Render a single cluster card
 */
function renderClusterCard(cluster) {
    const isSelected = selectedMergeClusters.has(cluster.id);
    const orderTitles = cluster.orders.map(o => `STT ${o.SessionIndex} - ${o.PartnerName || 'N/A'}`).join(' | ');

    // Build table headers
    const headers = [
        `<th class="merged-col">Sau Khi Gá»™p<br><small>(STT ${cluster.targetOrder.SessionIndex})</small></th>`
    ];

    cluster.orders.forEach(order => {
        const isTarget = order.Id === cluster.targetOrder.Id;
        const className = isTarget ? 'target-col' : '';
        const targetLabel = isTarget ? ' (ÄÃ­ch)' : '';

        // Render tags pills cho header (hiá»ƒn thá»‹ dÆ°á»›i STT - TÃªn)
        const tagsHtml = renderMergeTagPills(order.Tags);

        headers.push(`<th class="${className}">
            STT ${order.SessionIndex} - ${order.PartnerName || 'N/A'}${targetLabel}
            ${tagsHtml}
        </th>`);
    });

    // Find max products count for rows
    const maxProducts = Math.max(
        cluster.mergedProducts.length,
        ...cluster.orders.map(o => (o.Details || []).length)
    );

    // Build table rows
    const rows = [];
    for (let i = 0; i < maxProducts; i++) {
        const cells = [];

        // Merged column
        const mergedProduct = cluster.mergedProducts[i];
        cells.push(`<td class="merged-col">${mergedProduct ? renderProductItem(mergedProduct) : ''}</td>`);

        // Order columns
        cluster.orders.forEach(order => {
            const isTarget = order.Id === cluster.targetOrder.Id;
            const className = isTarget ? 'target-col' : '';
            const product = (order.Details || [])[i];
            cells.push(`<td class="${className}">${product ? renderProductItem(product) : ''}</td>`);
        });

        rows.push(`<tr>${cells.join('')}</tr>`);
    }

    // If no products at all
    if (maxProducts === 0) {
        const emptyCells = ['<td class="merged-col"><div class="merge-empty-cell">Trá»‘ng</div></td>'];
        cluster.orders.forEach(order => {
            const isTarget = order.Id === cluster.targetOrder.Id;
            const className = isTarget ? 'target-col' : '';
            emptyCells.push(`<td class="${className}"><div class="merge-empty-cell">Trá»‘ng</div></td>`);
        });
        rows.push(`<tr>${emptyCells.join('')}</tr>`);
    }

    return `
        <div class="merge-cluster-card ${isSelected ? 'selected' : ''}" data-cluster-id="${cluster.id}">
            <div class="merge-cluster-header">
                <input type="checkbox" class="merge-cluster-checkbox"
                    ${isSelected ? 'checked' : ''}
                    onchange="toggleMergeClusterSelection('${cluster.id}', this.checked)">
                <div class="merge-cluster-title"># ${orderTitles}</div>
                <div class="merge-cluster-phone"><i class="fas fa-phone"></i> ${cluster.phone}</div>
            </div>
            <div class="merge-cluster-table-wrapper">
                <table class="merge-cluster-table">
                    <thead>
                        <tr>${headers.join('')}</tr>
                    </thead>
                    <tbody>
                        ${rows.join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;
}

/**
 * Render a single product item
 */
function renderProductItem(product) {
    const imgUrl = product.ProductImageUrl || product.ImageUrl || '';
    const imgHtml = imgUrl
        ? `<img src="${imgUrl}" alt="" class="merge-product-img" onerror="this.style.display='none'">`
        : `<div class="merge-product-img" style="display: flex; align-items: center; justify-content: center; color: #9ca3af;"><i class="fas fa-box"></i></div>`;

    const productCode = product.ProductCode || product.ProductName?.match(/\[([^\]]+)\]/)?.[1] || '';
    const productName = product.ProductName || product.ProductNameGet || 'Sáº£n pháº©m';
    const price = product.Price ? `${(product.Price).toLocaleString('vi-VN')}Ä‘` : '';
    const note = product.Note || '';

    return `
        <div class="merge-product-item">
            ${imgHtml}
            <div class="merge-product-info">
                <div class="merge-product-name" title="${productName}">${productName}</div>
                ${productCode ? `<span class="merge-product-code">${productCode}</span>` : ''}
                <div class="merge-product-details">
                    <span class="qty">SL: ${product.Quantity || 0}</span>
                    ${price ? ` | <span class="price">${price}</span>` : ''}
                </div>
                ${note ? `<div class="merge-product-note">Note: ${note}</div>` : ''}
            </div>
        </div>
    `;
}

/**
 * Toggle selection for a single cluster
 */
function toggleMergeClusterSelection(clusterId, checked) {
    if (checked) {
        selectedMergeClusters.add(clusterId);
    } else {
        selectedMergeClusters.delete(clusterId);
    }

    // Update card visual
    const card = document.querySelector(`.merge-cluster-card[data-cluster-id="${clusterId}"]`);
    if (card) {
        card.classList.toggle('selected', checked);
    }

    // Update select all checkbox
    updateSelectAllCheckbox();
    updateConfirmButtonState();
}

/**
 * Toggle select all clusters
 */
function toggleSelectAllMergeClusters(checked) {
    if (checked) {
        mergeClustersData.forEach(cluster => {
            selectedMergeClusters.add(cluster.id);
        });
    } else {
        selectedMergeClusters.clear();
    }

    // Update all checkboxes and cards
    document.querySelectorAll('.merge-cluster-checkbox').forEach(checkbox => {
        checkbox.checked = checked;
    });
    document.querySelectorAll('.merge-cluster-card').forEach(card => {
        card.classList.toggle('selected', checked);
    });

    updateConfirmButtonState();
}

/**
 * Update select all checkbox state based on individual selections
 */
function updateSelectAllCheckbox() {
    const selectAllCheckbox = document.getElementById('mergeSelectAllCheckbox');
    if (mergeClustersData.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedMergeClusters.size === mergeClustersData.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedMergeClusters.size === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    }
}

/**
 * Update confirm button state
 */
function updateConfirmButtonState() {
    const confirmBtn = document.getElementById('confirmMergeBtn');
    confirmBtn.disabled = selectedMergeClusters.size === 0;
}

/**
 * Close the merge modal
 */
function closeMergeDuplicateOrdersModal() {
    const modal = document.getElementById('mergeDuplicateOrdersModal');
    modal.classList.remove('show');

    // Reset state
    mergeClustersData = [];
    selectedMergeClusters.clear();
}

/**
 * Confirm and execute merge for selected clusters
 */
async function confirmMergeSelectedClusters() {
    if (selectedMergeClusters.size === 0) {
        if (window.notificationManager) {
            window.notificationManager.show('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t cá»¥m Ä‘Æ¡n hÃ ng Ä‘á»ƒ gá»™p.', 'warning');
        }
        return;
    }

    const selectedClusters = mergeClustersData.filter(c => selectedMergeClusters.has(c.id));
    const totalSourceOrders = selectedClusters.reduce((sum, c) => sum + c.sourceOrders.length, 0);

    const confirmMsg = `Báº¡n sáº¯p gá»™p ${selectedClusters.length} cá»¥m Ä‘Æ¡n hÃ ng (${totalSourceOrders + selectedClusters.length} Ä‘Æ¡n).\n\n` +
        `HÃ nh Ä‘á»™ng nÃ y sáº½:\n` +
        `- Gá»™p sáº£n pháº©m tá»« Ä‘Æ¡n STT nhá» â†’ Ä‘Æ¡n STT lá»›n\n` +
        `- XÃ³a sáº£n pháº©m khá»i ${totalSourceOrders} Ä‘Æ¡n nguá»“n\n\n` +
        `Tiáº¿p tá»¥c?`;

    const confirmed = await window.notificationManager.confirm(confirmMsg, "XÃ¡c nháº­n gá»™p Ä‘Æ¡n");
    if (!confirmed) {
        return;
    }

    // Close modal and show loading
    closeMergeDuplicateOrdersModal();

    if (window.notificationManager) {
        window.notificationManager.show(`Äang gá»™p sáº£n pháº©m cho ${selectedClusters.length} cá»¥m...`, 'info');
    }

    // Load available tags before merge (needed for tag assignment)
    await loadAvailableTags();

    // Execute merge for each selected cluster
    const results = [];
    for (let i = 0; i < selectedClusters.length; i++) {
        const cluster = selectedClusters[i];
        console.log(`[MERGE-MODAL] Processing ${i + 1}/${selectedClusters.length}: Phone ${cluster.phone}`);

        const mergeData = {
            Telephone: cluster.phone,
            TargetOrderId: cluster.targetOrder.Id,
            TargetSTT: cluster.targetOrder.SessionIndex,
            SourceOrderIds: cluster.sourceOrders.map(o => o.Id),
            SourceSTTs: cluster.sourceOrders.map(o => o.SessionIndex),
            IsMerged: true
        };

        const result = await executeMergeOrderProducts(mergeData);
        results.push({ cluster, result });

        // Save merge history to Firebase (before tag assignment to capture original tags)
        await saveMergeHistory(cluster, result, result.errorResponse || null);

        // If merge successful, assign tags
        if (result.success) {
            console.log(`[MERGE-MODAL] Merge successful, assigning tags for cluster ${cluster.phone}`);
            const tagResult = await assignTagsAfterMerge(cluster);
            if (tagResult.success) {
                console.log(`[MERGE-MODAL] âœ… Tags assigned successfully for cluster ${cluster.phone}`);
            } else {
                console.warn(`[MERGE-MODAL] âš ï¸ Tag assignment failed for cluster ${cluster.phone}:`, tagResult.error);
            }
        }

        // Small delay to avoid rate limiting
        if (i < selectedClusters.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }

    // Count successes and failures
    const successCount = results.filter(r => r.result.success).length;
    const failureCount = results.length - successCount;

    // Show summary
    if (window.notificationManager) {
        if (failureCount > 0) {
            const failedPhones = results.filter(r => !r.result.success).map(r => r.cluster.phone).join(', ');
            window.notificationManager.show(
                `Gá»™p ${successCount}/${results.length} cá»¥m. Tháº¥t báº¡i: ${failedPhones}`,
                'warning',
                8000
            );
        } else {
            window.notificationManager.show(
                `ÄÃ£ gá»™p sáº£n pháº©m thÃ nh cÃ´ng cho ${successCount} cá»¥m Ä‘Æ¡n hÃ ng!`,
                'success',
                5000
            );
        }
    }

    // Refresh table
    try {
        await fetchOrders();
    } catch (refreshError) {
        console.warn('[MERGE-MODAL] Could not auto-refresh, please reload manually:', refreshError);
        renderTable();
        updateStats();
    }
}

// Make modal functions globally accessible
window.showMergeDuplicateOrdersModal = showMergeDuplicateOrdersModal;
window.closeMergeDuplicateOrdersModal = closeMergeDuplicateOrdersModal;
window.toggleMergeClusterSelection = toggleMergeClusterSelection;
window.toggleSelectAllMergeClusters = toggleSelectAllMergeClusters;
window.confirmMergeSelectedClusters = confirmMergeSelectedClusters;

// =====================================================
// MERGE HISTORY FUNCTIONS (Firebase Storage)
// =====================================================

// Firebase collection for merge history
const MERGE_HISTORY_COLLECTION = 'merge_orders_history';

/**
 * Get current user info for history tracking
 */
function getMergeHistoryUserInfo() {
    let userId = 'guest';
    let userName = 'Unknown';

    try {
        // Try userStorageManager first
        if (window.userStorageManager && typeof window.userStorageManager.getUserIdentifier === 'function') {
            userId = window.userStorageManager.getUserIdentifier() || 'guest';
        }

        // Try to get display name from auth
        const authStr = localStorage.getItem('loginindex_auth');
        if (authStr) {
            const auth = JSON.parse(authStr);
            userName = auth.displayName || auth.name || auth.email || 'Unknown';
            if (!userId || userId === 'guest') {
                userId = auth.uid || auth.id || auth.email || 'guest';
            }
        }
    } catch (e) {
        console.warn('[MERGE-HISTORY] Error getting user info:', e);
    }

    return { userId, userName };
}

/**
 * Save merge history to Firebase
 */
async function saveMergeHistory(cluster, result, errorResponse = null) {
    if (!db) {
        console.warn('[MERGE-HISTORY] Firebase not available, cannot save history');
        return;
    }

    try {
        const { userId, userName } = getMergeHistoryUserInfo();
        const timestamp = new Date();

        // Build source orders data with original tags
        const sourceOrdersData = cluster.sourceOrders.map(order => ({
            orderId: order.Id,
            stt: order.SessionIndex,
            partnerName: order.PartnerName || '',
            originalTags: getOrderTagsArray(order).map(t => ({
                id: t.Id,
                name: t.Name || '',
                color: t.Color || ''
            })),
            products: (order.Details || []).map(p => ({
                productId: p.ProductId,
                productCode: p.ProductCode || '',
                productName: p.ProductName || '',
                productImage: p.ProductImageUrl || p.ImageUrl || '',
                quantity: p.Quantity || 0,
                price: p.Price || 0,
                note: p.Note || ''
            }))
        }));

        // Build target order data with original tags
        const targetOrderData = {
            orderId: cluster.targetOrder.Id,
            stt: cluster.targetOrder.SessionIndex,
            partnerName: cluster.targetOrder.PartnerName || '',
            originalTags: getOrderTagsArray(cluster.targetOrder).map(t => ({
                id: t.Id,
                name: t.Name || '',
                color: t.Color || ''
            })),
            products: (cluster.targetOrder.Details || []).map(p => ({
                productId: p.ProductId,
                productCode: p.ProductCode || '',
                productName: p.ProductName || '',
                productImage: p.ProductImageUrl || p.ImageUrl || '',
                quantity: p.Quantity || 0,
                price: p.Price || 0,
                note: p.Note || ''
            }))
        };

        // Build merged products data
        const mergedProductsData = (cluster.mergedProducts || []).map(p => ({
            productId: p.ProductId,
            productCode: p.ProductCode || '',
            productName: p.ProductName || '',
            productImage: p.ProductImageUrl || p.ImageUrl || '',
            quantity: p.Quantity || 0,
            price: p.Price || 0,
            note: p.Note || ''
        }));

        const historyEntry = {
            phone: cluster.phone,
            timestamp: firebase.firestore.Timestamp.fromDate(timestamp),
            timestampISO: timestamp.toISOString(),
            userId: userId,
            userName: userName,
            success: result.success,
            errorMessage: result.success ? null : (result.message || 'Unknown error'),
            errorResponse: errorResponse ? JSON.stringify(errorResponse) : null,
            sourceOrders: sourceOrdersData,
            targetOrder: targetOrderData,
            mergedProducts: mergedProductsData,
            totalSourceOrders: sourceOrdersData.length,
            totalMergedProducts: mergedProductsData.length
        };

        await db.collection(MERGE_HISTORY_COLLECTION).add(historyEntry);
        console.log('[MERGE-HISTORY] Saved history entry for phone:', cluster.phone);

    } catch (error) {
        console.error('[MERGE-HISTORY] Error saving history:', error);
    }
}

/**
 * Load merge history from Firebase
 */
async function loadMergeHistory(limit = 50) {
    if (!db) {
        console.warn('[MERGE-HISTORY] Firebase not available');
        return [];
    }

    try {
        const snapshot = await db.collection(MERGE_HISTORY_COLLECTION)
            .orderBy('timestamp', 'desc')
            .limit(limit)
            .get();

        const history = [];
        snapshot.forEach(doc => {
            history.push({
                id: doc.id,
                ...doc.data()
            });
        });

        console.log(`[MERGE-HISTORY] Loaded ${history.length} history entries`);
        return history;

    } catch (error) {
        console.error('[MERGE-HISTORY] Error loading history:', error);
        return [];
    }
}

/**
 * Show merge history modal
 */
async function showMergeHistoryModal() {
    const modal = document.getElementById('mergeHistoryModal');
    const modalBody = document.getElementById('mergeHistoryModalBody');
    const subtitle = document.getElementById('mergeHistoryModalSubtitle');

    // Show modal with loading state
    modal.classList.add('show');
    modalBody.innerHTML = `
        <div class="merge-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Äang táº£i lá»‹ch sá»­ gá»™p Ä‘Æ¡n...</p>
        </div>
    `;

    try {
        const history = await loadMergeHistory(100);

        if (history.length === 0) {
            modalBody.innerHTML = `
                <div class="merge-no-history">
                    <i class="fas fa-inbox"></i>
                    <p>ChÆ°a cÃ³ lá»‹ch sá»­ gá»™p Ä‘Æ¡n nÃ o.</p>
                </div>
            `;
            subtitle.textContent = 'KhÃ´ng cÃ³ lá»‹ch sá»­';
            return;
        }

        // Render history entries
        const html = history.map((entry, index) => renderHistoryEntry(entry, index)).join('');
        modalBody.innerHTML = html;

        const successCount = history.filter(e => e.success).length;
        const failedCount = history.length - successCount;
        subtitle.textContent = `${history.length} láº§n gá»™p (${successCount} thÃ nh cÃ´ng, ${failedCount} tháº¥t báº¡i)`;

    } catch (error) {
        console.error('[MERGE-HISTORY] Error showing history:', error);
        modalBody.innerHTML = `
            <div class="merge-no-history">
                <i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>
                <p>Lá»—i khi táº£i lá»‹ch sá»­: ${error.message}</p>
            </div>
        `;
    }
}

/**
 * Render a single history entry
 */
function renderHistoryEntry(entry, index) {
    const timestamp = entry.timestamp?.toDate ? entry.timestamp.toDate() : new Date(entry.timestampISO);
    const timeStr = timestamp.toLocaleString('vi-VN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    });

    const statusClass = entry.success ? 'success' : 'failed';
    const statusText = entry.success ? 'ThÃ nh cÃ´ng' : 'Tháº¥t báº¡i';

    // Build order titles for header
    const allSTTs = [
        ...entry.sourceOrders.map(o => `STT ${o.stt}`),
        `STT ${entry.targetOrder.stt} (ÄÃ­ch)`
    ].join(' | ');

    // Build table for details
    const tableHtml = renderHistoryTable(entry);

    // Error section if failed
    const errorHtml = !entry.success && entry.errorResponse ? `
        <div class="merge-history-error">
            <div class="merge-history-error-title">
                <i class="fas fa-exclamation-circle"></i> Chi tiáº¿t lá»—i tá»« TPOS
            </div>
            <div class="merge-history-error-content">${escapeHtml(entry.errorResponse)}</div>
        </div>
    ` : (!entry.success ? `
        <div class="merge-history-error">
            <div class="merge-history-error-title">
                <i class="fas fa-exclamation-circle"></i> Lá»—i
            </div>
            <div class="merge-history-error-content">${escapeHtml(entry.errorMessage || 'Unknown error')}</div>
        </div>
    ` : '');

    return `
        <div class="merge-history-entry" id="history-entry-${index}">
            <div class="merge-history-header ${statusClass}" onclick="toggleHistoryEntry(${index})">
                <div class="merge-history-info">
                    <span class="merge-history-time"><i class="fas fa-clock"></i> ${timeStr}</span>
                    <span class="merge-history-user"><i class="fas fa-user"></i> ${escapeHtml(entry.userName)}</span>
                    <span class="merge-history-phone"><i class="fas fa-phone"></i> ${escapeHtml(entry.phone)}</span>
                    <span class="merge-history-orders">${entry.totalSourceOrders + 1} Ä‘Æ¡n â†’ ${entry.totalMergedProducts} SP</span>
                </div>
                <span class="merge-history-status ${statusClass}">${statusText}</span>
                <i class="fas fa-chevron-down merge-history-toggle"></i>
            </div>
            <div class="merge-history-details">
                ${errorHtml}
                <div class="merge-history-orders-title" style="font-weight: 600; margin-bottom: 12px; color: #374151;">
                    # ${allSTTs}
                </div>
                ${tableHtml}
            </div>
        </div>
    `;
}

/**
 * Render tag pills for history display
 */
function renderHistoryTagPills(tags) {
    if (!tags || tags.length === 0) return '';
    return `<div style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 4px;">
        ${tags.map(t => `<span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; color: white; background: ${t.color || '#6b7280'};">${escapeHtml(t.name)}</span>`).join('')}
    </div>`;
}

/**
 * Render history table (similar to merge preview)
 */
function renderHistoryTable(entry) {
    // Build headers with original tags
    const headers = [
        `<th class="merged-col">Sau Khi Gá»™p<br><small>(STT ${entry.targetOrder.stt})</small></th>`
    ];

    // Source orders headers with original tags
    entry.sourceOrders.forEach(order => {
        const tagsHtml = renderHistoryTagPills(order.originalTags);
        headers.push(`<th>STT ${order.stt} - ${escapeHtml(order.partnerName)}${tagsHtml}</th>`);
    });

    // Target order header with original tags
    const targetTagsHtml = renderHistoryTagPills(entry.targetOrder.originalTags);
    headers.push(`<th class="target-col">STT ${entry.targetOrder.stt} - ${escapeHtml(entry.targetOrder.partnerName)} (ÄÃ­ch)${targetTagsHtml}</th>`);

    // Find max products
    const allProductCounts = [
        entry.mergedProducts.length,
        ...entry.sourceOrders.map(o => o.products.length),
        entry.targetOrder.products.length
    ];
    const maxProducts = Math.max(...allProductCounts, 1);

    // Build rows
    const rows = [];
    for (let i = 0; i < maxProducts; i++) {
        const cells = [];

        // Merged column
        const mergedProduct = entry.mergedProducts[i];
        cells.push(`<td class="merged-col">${mergedProduct ? renderHistoryProductItem(mergedProduct) : ''}</td>`);

        // Source order columns
        entry.sourceOrders.forEach(order => {
            const product = order.products[i];
            cells.push(`<td>${product ? renderHistoryProductItem(product) : ''}</td>`);
        });

        // Target order column
        const targetProduct = entry.targetOrder.products[i];
        cells.push(`<td class="target-col">${targetProduct ? renderHistoryProductItem(targetProduct) : ''}</td>`);

        rows.push(`<tr>${cells.join('')}</tr>`);
    }

    return `
        <div class="merge-cluster-table-wrapper">
            <table class="merge-cluster-table">
                <thead>
                    <tr>${headers.join('')}</tr>
                </thead>
                <tbody>
                    ${rows.join('')}
                </tbody>
            </table>
        </div>
    `;
}

/**
 * Render a product item for history
 */
function renderHistoryProductItem(product) {
    const imgUrl = product.productImage || '';
    const imgHtml = imgUrl
        ? `<img src="${imgUrl}" alt="" class="merge-product-img" onerror="this.style.display='none'">`
        : `<div class="merge-product-img" style="display: flex; align-items: center; justify-content: center; color: #9ca3af;"><i class="fas fa-box"></i></div>`;

    const price = product.price ? `${product.price.toLocaleString('vi-VN')}Ä‘` : '';

    return `
        <div class="merge-product-item">
            ${imgHtml}
            <div class="merge-product-info">
                <div class="merge-product-name" title="${escapeHtml(product.productName)}">${escapeHtml(product.productName)}</div>
                ${product.productCode ? `<span class="merge-product-code">${escapeHtml(product.productCode)}</span>` : ''}
                <div class="merge-product-details">
                    <span class="qty">SL: ${product.quantity || 0}</span>
                    ${price ? ` | <span class="price">${price}</span>` : ''}
                </div>
                ${product.note ? `<div class="merge-product-note">Note: ${escapeHtml(product.note)}</div>` : ''}
            </div>
        </div>
    `;
}

/**
 * Toggle history entry expand/collapse
 */
function toggleHistoryEntry(index) {
    const entry = document.getElementById(`history-entry-${index}`);
    if (entry) {
        entry.classList.toggle('expanded');
    }
}

/**
 * Close merge history modal
 */
function closeMergeHistoryModal() {
    const modal = document.getElementById('mergeHistoryModal');
    modal.classList.remove('show');
}

/**
 * Helper: Escape HTML to prevent XSS
 */
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// =====================================================
// MERGE TAG ASSIGNMENT FUNCTIONS
// =====================================================

const MERGE_TAG_COLOR = '#E3A21A';
const MERGED_ORDER_TAG_NAME = 'ÄÃƒ Gá»˜P KO CHá»T';

/**
 * Ensure a tag exists, create if not found
 * @param {string} tagName - Tag name to ensure exists
 * @param {string} color - Hex color for new tag
 * @returns {Promise<Object>} Tag object with Id, Name, Color
 */
async function ensureMergeTagExists(tagName, color = MERGE_TAG_COLOR) {
    try {
        // IMPORTANT: Fetch fresh tags from API (khÃ´ng dÃ¹ng cache Ä‘á»ƒ trÃ¡nh duplicate)
        console.log(`[MERGE-TAG] Fetching fresh tags from API before checking "${tagName}"...`);
        const headers = await window.tokenManager.getAuthHeader();

        const tagsResponse = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag?$format=json&$count=true&$top=1000',
            {
                method: 'GET',
                headers: {
                    ...headers,
                    'accept': 'application/json',
                    'content-type': 'application/json',
                },
            }
        );

        if (tagsResponse.ok) {
            const tagsData = await tagsResponse.json();
            availableTags = tagsData.value || [];
            window.availableTags = availableTags;
            window.cacheManager.set("tags", availableTags, "tags");
            console.log(`[MERGE-TAG] Refreshed ${availableTags.length} tags from API`);
        }

        // Check if tag already exists (case-insensitive)
        const existingTag = availableTags.find(t =>
            t.Name && t.Name.toLowerCase() === tagName.toLowerCase()
        );

        if (existingTag) {
            console.log(`[MERGE-TAG] Tag "${tagName}" already exists:`, existingTag);
            return existingTag;
        }

        // Create new tag
        console.log(`[MERGE-TAG] Creating new tag: "${tagName}" with color ${color}`);

        const response = await API_CONFIG.smartFetch(
            'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/Tag',
            {
                method: 'POST',
                headers: {
                    ...headers,
                    'accept': 'application/json, text/plain, */*',
                    'content-type': 'application/json;charset=UTF-8',
                },
                body: JSON.stringify({
                    Name: tagName,
                    Color: color
                })
            }
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const newTag = await response.json();
        console.log('[MERGE-TAG] Tag created successfully:', newTag);

        // Remove @odata.context
        if (newTag['@odata.context']) {
            delete newTag['@odata.context'];
        }

        // Update local tags list
        if (Array.isArray(availableTags)) {
            availableTags.push(newTag);
            window.availableTags = availableTags;
            window.cacheManager.set("tags", availableTags, "tags");
        }

        // Save to Firebase
        if (database) {
            await database.ref('settings/tags').set(availableTags);
        }

        return newTag;

    } catch (error) {
        console.error('[MERGE-TAG] Error ensuring tag exists:', error);
        throw error;
    }
}

/**
 * Get tags array from order object
 * NOTE: This function was renamed from parseOrderTags to avoid collision
 *       with the parseOrderTags() function at line ~4969 that renders HTML
 * @param {Object} order - Order object
 * @returns {Array} Array of tag objects
 */
function getOrderTagsArray(order) {
    if (!order || !order.Tags) return [];

    const tagsData = order.Tags;

    // Case 1: Tags Ä‘Ã£ lÃ  array (Ä‘Ã£ parse sáºµn)
    if (Array.isArray(tagsData)) {
        return tagsData;
    }

    // Case 2: Tags lÃ  JSON string
    if (typeof tagsData === 'string' && tagsData.trim() !== '') {
        try {
            const parsed = JSON.parse(tagsData);
            return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
            console.warn('[getOrderTagsArray] Failed to parse Tags:', tagsData);
            return [];
        }
    }

    return [];
}

/**
 * Assign tags to an order via API
 * @param {string} orderId - Order ID
 * @param {Array} tags - Array of tag objects
 */
async function assignTagsToOrder(orderId, tags) {
    const headers = await window.tokenManager.getAuthHeader();

    const response = await API_CONFIG.smartFetch(
        'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/TagSaleOnlineOrder/ODataService.AssignTag',
        {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            body: JSON.stringify({
                Tags: tags.map(t => ({ Id: t.Id, Color: t.Color, Name: t.Name })),
                OrderId: orderId
            })
        }
    );

    if (!response.ok) {
        throw new Error(`Lá»—i gÃ¡n tag: ${response.status}`);
    }

    // Update order in table
    const updatedData = { Tags: JSON.stringify(tags) };
    updateOrderInTable(orderId, updatedData);

    // Emit Firebase realtime update
    await emitTagUpdateToFirebase(orderId, tags);

    return true;
}

/**
 * Assign tags after successful merge
 * @param {Object} cluster - Cluster data with orders, targetOrder, sourceOrders
 * @returns {Promise<Object>} Result of tag assignment
 */
async function assignTagsAfterMerge(cluster) {
    try {
        console.log('[MERGE-TAG] Starting tag assignment for cluster:', cluster.phone);

        // Step 1: Ensure "ÄÃƒ Gá»˜P KO CHá»T" tag exists
        const mergedTag = await ensureMergeTagExists(MERGED_ORDER_TAG_NAME, MERGE_TAG_COLOR);

        // Step 2: Create "Gá»™p X Y Z" tag
        const allSTTs = cluster.orders.map(o => o.SessionIndex).sort((a, b) => a - b);
        const mergeTagName = `Gá»™p ${allSTTs.join(' ')}`;
        const mergeGroupTag = await ensureMergeTagExists(mergeTagName, MERGE_TAG_COLOR);

        // Step 3: Collect all tags from all orders (for target order)
        const allTags = new Map(); // Use Map to dedupe by tag Id

        // Helper function: Check if a tag should be excluded (merge-related tags)
        const shouldExcludeTag = (tagName) => {
            if (!tagName) return false;
            // Exclude "ÄÃƒ Gá»˜P KO CHá»T" tag - this is for source orders only
            if (tagName === MERGED_ORDER_TAG_NAME) return true;
            // Exclude old "Gá»™p X Y Z" tags from previous merges
            if (tagName.startsWith('Gá»™p ')) return true;
            return false;
        };

        // Add tags from target order (exclude merge-related tags)
        const targetTags = getOrderTagsArray(cluster.targetOrder);
        targetTags.forEach(t => {
            if (t.Id && !shouldExcludeTag(t.Name)) {
                allTags.set(t.Id, t);
            }
        });
        console.log(`[MERGE-TAG] Target order tags after filter: ${targetTags.filter(t => !shouldExcludeTag(t.Name)).map(t => t.Name).join(', ') || '(none)'}`);

        // Add tags from source orders (exclude merge-related tags)
        cluster.sourceOrders.forEach(sourceOrder => {
            const sourceTags = getOrderTagsArray(sourceOrder);
            const filteredTags = sourceTags.filter(t => t.Id && !shouldExcludeTag(t.Name));
            console.log(`[MERGE-TAG] Source order STT ${sourceOrder.SessionIndex} tags after filter: ${filteredTags.map(t => t.Name).join(', ') || '(none)'}`);
            filteredTags.forEach(t => {
                allTags.set(t.Id, t);
            });
        });

        // Add merge group tag
        allTags.set(mergeGroupTag.Id, mergeGroupTag);

        // Convert to array
        const targetOrderNewTags = Array.from(allTags.values());

        console.log(`[MERGE-TAG] Target order STT ${cluster.targetOrder.SessionIndex} will have ${targetOrderNewTags.length} tags: ${targetOrderNewTags.map(t => t.Name).join(', ')}`);

        // Step 4: Assign tags to target order
        await assignTagsToOrder(cluster.targetOrder.Id, targetOrderNewTags);
        console.log(`[MERGE-TAG] âœ… Assigned ${targetOrderNewTags.length} tags to target order STT ${cluster.targetOrder.SessionIndex}`);

        // Step 5: Assign only "ÄÃƒ Gá»˜P KO CHá»T" tag to source orders (clear all existing)
        const sourceOnlyTags = [mergedTag];

        for (const sourceOrder of cluster.sourceOrders) {
            await assignTagsToOrder(sourceOrder.Id, sourceOnlyTags);
            console.log(`[MERGE-TAG] âœ… Assigned "${MERGED_ORDER_TAG_NAME}" to source order STT ${sourceOrder.SessionIndex}`);
        }

        // Clear cache
        window.cacheManager.clear("orders");

        return {
            success: true,
            targetTags: targetOrderNewTags,
            sourceTag: mergedTag,
            mergeGroupTag: mergeGroupTag
        };

    } catch (error) {
        console.error('[MERGE-TAG] Error assigning tags:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// Make history functions globally accessible
window.showMergeHistoryModal = showMergeHistoryModal;
window.closeMergeHistoryModal = closeMergeHistoryModal;
window.toggleHistoryEntry = toggleHistoryEntry;
window.saveMergeHistory = saveMergeHistory;


// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                       SECTION 16: ADDRESS LOOKUP                            â•‘
// â•‘                            search: #ADDRESS                                 â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// ADDRESS LOOKUP LOGIC #ADDRESS
// =====================================================
async function handleAddressLookup() {
    const input = document.getElementById('addressLookupInput');
    const resultsContainer = document.getElementById('addressLookupResults');
    const keyword = input.value.trim();

    if (!keyword) {
        if (window.notificationManager) {
            window.notificationManager.show('Vui lÃ²ng nháº­p tá»« khÃ³a tÃ¬m kiáº¿m', 'warning');
        } else {
            alert('Vui lÃ²ng nháº­p tá»« khÃ³a tÃ¬m kiáº¿m');
        }
        return;
    }

    resultsContainer.style.display = 'block';
    resultsContainer.innerHTML = '<div style="padding: 12px; text-align: center; color: #6b7280;"><i class="fas fa-spinner fa-spin"></i> Äang tÃ¬m kiáº¿m...</div>';

    try {
        // Use the global searchByName function from api-handler.js which returns data without DOM manipulation
        if (typeof window.searchByName !== 'function') {
            throw new Error('HÃ m tÃ¬m kiáº¿m khÃ´ng kháº£ dá»¥ng (api-handler.js chÆ°a Ä‘Æ°á»£c táº£i)');
        }

        const items = await window.searchByName(keyword);

        if (!items || items.length === 0) {
            resultsContainer.innerHTML = '<div style="padding: 12px; text-align: center; color: #ef4444;">KhÃ´ng tÃ¬m tháº¥y káº¿t quáº£ phÃ¹ há»£p</div>';
            return;
        }

        resultsContainer.innerHTML = items.map(item => {
            // Determine display name and type label
            let displayName = item.name || item.ward_name || item.district_name || '';
            let typeLabel = '';
            let fullAddress = displayName; // Default to display name
            let subText = '';

            if (item.type === 'province') {
                typeLabel = 'Tá»‰nh/ThÃ nh phá»‘';
            } else if (item.type === 'district') {
                typeLabel = 'Quáº­n/Huyá»‡n';
                if (item.province_name) {
                    fullAddress = `${displayName}, ${item.province_name}`;
                }
            } else if (item.type === 'ward') {
                typeLabel = 'PhÆ°á»ng/XÃ£';
                // Try to construct better address if fields exist
                if (item.district_name && item.province_name) {
                    fullAddress = `${displayName}, ${item.district_name}, ${item.province_name}`;
                } else if (item.merger_details) {
                    // Use merger details as context since district_name is missing
                    subText = `<div style="font-size: 10px; color: #9ca3af; font-style: italic;">${item.merger_details}</div>`;
                    // Construct full address with province
                    if (item.province_name) {
                        fullAddress = `${displayName}, ${item.province_name}`;
                        // Append district info from merger details if possible (simple heuristic)
                        // This is optional, but helps if the user wants the "old" district name in the text
                        fullAddress += ` (${item.merger_details})`;
                    }
                } else if (item.address) {
                    fullAddress = item.address;
                }
            }

            return `
            <div class="address-result-item" 
                 onclick="selectAddress('${fullAddress.replace(/'/g, "\\'")}', '${item.type}')"
                 style="padding: 10px; cursor: pointer; border-bottom: 1px solid #f3f4f6; transition: background 0.2s; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <div style="font-weight: 500; color: #374151;">${displayName}</div>
                    <div style="font-size: 11px; color: #6b7280; margin-top: 2px;">${typeLabel}</div>
                    ${subText}
                </div>
                <i class="fas fa-chevron-right" style="font-size: 12px; color: #d1d5db;"></i>
            </div>
            `;
        }).join('');

        // Add hover effect via JS since we are injecting HTML
        const resultItems = resultsContainer.querySelectorAll('.address-result-item');
        resultItems.forEach(item => {
            item.onmouseover = () => item.style.backgroundColor = '#f9fafb';
            item.onmouseout = () => item.style.backgroundColor = 'white';
        });

    } catch (error) {
        console.error('Address lookup error:', error);
        resultsContainer.innerHTML = `<div style="padding: 12px; text-align: center; color: #ef4444;">Lá»—i: ${error.message}</div>`;
    }
}

async function handleFullAddressLookup() {
    const input = document.getElementById('fullAddressLookupInput');
    const resultsContainer = document.getElementById('addressLookupResults');

    if (!input || !resultsContainer) return;

    const keyword = input.value.trim();
    if (!keyword) {
        alert('Vui lÃ²ng nháº­p Ä‘á»‹a chá»‰ Ä‘áº§y Ä‘á»§');
        return;
    }

    resultsContainer.style.display = 'block';
    resultsContainer.innerHTML = '<div style="padding: 12px; text-align: center; color: #6b7280;"><i class="fas fa-spinner fa-spin"></i> Äang phÃ¢n tÃ­ch Ä‘á»‹a chá»‰...</div>';

    try {
        if (typeof window.searchFullAddress !== 'function') {
            throw new Error('HÃ m tÃ¬m kiáº¿m khÃ´ng kháº£ dá»¥ng (api-handler.js chÆ°a Ä‘Æ°á»£c táº£i)');
        }

        const response = await window.searchFullAddress(keyword);

        if (!response || !response.data || response.data.length === 0) {
            resultsContainer.innerHTML = '<div style="padding: 12px; text-align: center; color: #ef4444;">KhÃ´ng tÃ¬m tháº¥y káº¿t quáº£ phÃ¹ há»£p</div>';
            return;
        }

        // The API returns data in a simple format: { address: "...", note: "..." }

        const items = response.data;
        resultsContainer.innerHTML = items.map(item => {
            const fullAddress = item.address;

            return `
            <div class="address-result-item" 
                 onclick="selectAddress('${fullAddress.replace(/'/g, "\\'")}', 'full')"
                 style="padding: 10px; cursor: pointer; border-bottom: 1px solid #f3f4f6; transition: background 0.2s; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <div style="font-weight: 500; color: #374151;">${item.address}</div>
                    ${item.note ? `<div style="font-size: 11px; color: #6b7280; margin-top: 2px;">${item.note}</div>` : ''}
                </div>
                <i class="fas fa-check" style="font-size: 12px; color: #059669;"></i>
            </div>
            `;
        }).join('');

        const resultItems = resultsContainer.querySelectorAll('.address-result-item');
        resultItems.forEach(item => {
            item.onmouseover = () => item.style.backgroundColor = '#f9fafb';
            item.onmouseout = () => item.style.backgroundColor = 'white';
        });

    } catch (error) {
        console.error('Full address lookup error:', error);
        resultsContainer.innerHTML = `<div style="padding: 12px; text-align: center; color: #ef4444;">Lá»—i: ${error.message}</div>`;
    }
}

async function selectAddress(fullAddress, type) {
    const addressTextarea = document.querySelector('textarea[onchange*="updateOrderInfo(\'Address\'"]');
    if (addressTextarea) {
        let newAddress = fullAddress;

        // Logic to append or replace
        if (addressTextarea.value && addressTextarea.value.trim() !== '') {
            // Check if the textarea contains the new address already
            if (!addressTextarea.value.includes(fullAddress)) {
                // Confirm with user using custom popup
                const replaceAddress = await window.notificationManager.confirm(
                    'Báº¡n cÃ³ muá»‘n thay tháº¿ Ä‘á»‹a chá»‰ hiá»‡n táº¡i khÃ´ng?\n\nÄá»“ng Ã½: Thay tháº¿\nHá»§y: Ná»‘i thÃªm vÃ o sau',
                    'Chá»n cÃ¡ch cáº­p nháº­t Ä‘á»‹a chá»‰'
                );
                if (replaceAddress) {
                    newAddress = fullAddress;
                } else {
                    newAddress = addressTextarea.value + ', ' + fullAddress;
                }
            }
        }

        addressTextarea.value = newAddress;
        updateOrderInfo('Address', newAddress);

        // Hide results and clear input
        document.getElementById('addressLookupResults').style.display = 'none';
        document.getElementById('addressLookupInput').value = '';

        if (window.notificationManager) {
            window.notificationManager.show('ÄÃ£ cáº­p nháº­t Ä‘á»‹a chá»‰', 'success');
        }
    }
}

// =====================================================
// PRODUCT STATS MODAL FUNCTIONS
// =====================================================

/**
 * Open the product stats modal and load previous stats if available
 */
function openProductStatsModal() {
    const modal = document.getElementById('productStatsModal');
    if (modal) {
        modal.classList.add('show');
        // Load previous stats from Firebase if available
        loadStatsFromFirebase();
    }
}

/**
 * Close the product stats modal
 */
function closeProductStatsModal() {
    const modal = document.getElementById('productStatsModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

// Close modal when clicking outside
document.addEventListener('click', function (event) {
    const modal = document.getElementById('productStatsModal');
    if (modal && event.target === modal) {
        closeProductStatsModal();
    }
});

/**
 * Get current campaign ID for Firebase storage
 */
function getStatsCampaignId() {
    if (selectedCampaign && selectedCampaign.campaignId) {
        return selectedCampaign.campaignId;
    }
    return 'no_campaign';
}

/**
 * Load stats from Firebase for current campaign
 */
async function loadStatsFromFirebase() {
    const modalBody = document.getElementById('productStatsModalBody');
    const campaignId = getStatsCampaignId();

    try {
        const statsRef = window.firebase.database().ref(`product_stats/${campaignId}`);
        const snapshot = await statsRef.once('value');
        const data = snapshot.val();

        if (data && data.statsHtml) {
            // Show campaign info
            const campaignInfo = data.campaignName
                ? `<div class="stats-campaign-info"><i class="fas fa-video"></i>Chiáº¿n dá»‹ch: ${data.campaignName} | Cáº­p nháº­t: ${new Date(data.updatedAt).toLocaleString('vi-VN')}</div>`
                : '';
            modalBody.innerHTML = campaignInfo + data.statsHtml;
        } else {
            modalBody.innerHTML = `
                <div class="stats-empty-state">
                    <i class="fas fa-chart-pie"></i>
                    <p>ChÆ°a cÃ³ dá»¯ liá»‡u thá»‘ng kÃª. Báº¥m nÃºt "Thá»‘ng kÃª" Ä‘á»ƒ báº¯t Ä‘áº§u.</p>
                </div>
            `;
        }
    } catch (error) {
        console.error('[PRODUCT-STATS] Error loading from Firebase:', error);
        modalBody.innerHTML = `
            <div class="stats-empty-state">
                <i class="fas fa-chart-pie"></i>
                <p>Báº¥m nÃºt "Thá»‘ng kÃª" Ä‘á»ƒ báº¯t Ä‘áº§u</p>
            </div>
        `;
    }
}

/**
 * Save stats to Firebase for current campaign
 */
async function saveStatsToFirebase(statsHtml, summaryData) {
    const campaignId = getStatsCampaignId();
    const campaignName = selectedCampaign ? selectedCampaign.campaignName : '';

    try {
        const statsRef = window.firebase.database().ref(`product_stats/${campaignId}`);
        await statsRef.set({
            campaignId: campaignId,
            campaignName: campaignName,
            statsHtml: statsHtml,
            totalProducts: summaryData.totalProducts,
            totalQuantity: summaryData.totalQuantity,
            totalOrders: summaryData.totalOrders,
            updatedAt: new Date().toISOString()
        });
        console.log('[PRODUCT-STATS] Saved to Firebase successfully');
    } catch (error) {
        console.error('[PRODUCT-STATS] Error saving to Firebase:', error);
    }
}

/**
 * Run product statistics on all orders in allData
 */
async function runProductStats() {
    const modalBody = document.getElementById('productStatsModalBody');
    const runBtn = document.querySelector('.btn-run-stats');

    // Show loading state
    modalBody.innerHTML = `
        <div class="stats-loading">
            <div class="spinner"></div>
            <p>Äang thá»‘ng kÃª sáº£n pháº©m...</p>
        </div>
    `;

    if (runBtn) {
        runBtn.disabled = true;
        runBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Äang xá»­ lÃ½...';
    }

    try {
        // Check if allData exists
        if (!allData || allData.length === 0) {
            modalBody.innerHTML = `
                <div class="stats-empty-state">
                    <i class="fas fa-exclamation-triangle" style="color: #f59e0b;"></i>
                    <p>KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘Æ¡n hÃ ng. Vui lÃ²ng táº£i dá»¯ liá»‡u trÆ°á»›c.</p>
                </div>
            `;
            return;
        }

        // Build product statistics
        const productStats = new Map(); // key: ProductCode, value: { name, nameGet, imageUrl, sttList: [{stt, qty}] }
        const orderSet = new Set(); // Track unique orders
        let totalQuantity = 0;

        allData.forEach((order) => {
            const stt = order.SessionIndex || '';
            if (!stt) return; // Skip orders without STT

            orderSet.add(stt);

            const details = order.Details || [];
            details.forEach((product) => {
                const productCode = product.ProductCode || 'N/A';
                const quantity = product.Quantity || product.ProductUOMQty || 1;
                totalQuantity += quantity;

                if (!productStats.has(productCode)) {
                    productStats.set(productCode, {
                        code: productCode,
                        name: product.ProductName || '',
                        nameGet: product.ProductNameGet || product.ProductName || '',
                        imageUrl: product.ImageUrl || '',
                        sttList: [],
                        totalQty: 0
                    });
                }

                const stat = productStats.get(productCode);
                stat.sttList.push({ stt: stt, qty: quantity });
                stat.totalQty += quantity;
            });
        });

        // Sort products by total quantity (descending)
        const sortedProducts = Array.from(productStats.values()).sort((a, b) => b.totalQty - a.totalQty);

        // Summary data
        const summaryData = {
            totalProducts: sortedProducts.length,
            totalQuantity: totalQuantity,
            totalOrders: orderSet.size
        };

        // Build HTML table
        const tableRowsHtml = sortedProducts.map((product) => {
            // Build STT list string with quantity
            const sttListStr = product.sttList.map(item => {
                if (item.qty > 1) {
                    return `${item.stt}<span class="stats-stt-qty">(${item.qty})</span>`;
                }
                return item.stt;
            }).join(', ');

            // Product image
            const imageHtml = product.imageUrl
                ? `<img src="${product.imageUrl}" class="stats-product-image" alt="${product.code}" onerror="this.style.display='none'">`
                : `<div class="stats-product-image-placeholder"><i class="fas fa-image"></i></div>`;

            return `
                <tr>
                    <td>
                        <div class="stats-product-info">
                            ${imageHtml}
                            <div class="stats-product-details">
                                <div class="stats-product-code">[${product.code}]</div>
                                <div class="stats-product-name">${product.nameGet || product.name}</div>
                            </div>
                        </div>
                    </td>
                    <td>
                        <span class="stats-quantity-badge">${product.totalQty}</span>
                    </td>
                    <td>
                        <div class="stats-stt-list">${sttListStr}</div>
                    </td>
                </tr>
            `;
        }).join('');

        const statsHtml = `
            <div class="stats-summary-header" onclick="toggleStatsSummary(this)">
                <i class="fas fa-chevron-down toggle-icon"></i>
                <i class="fas fa-list-alt"></i>
                <span class="stats-summary-content">Tá»”NG Cá»˜NG: ${summaryData.totalProducts} sáº£n pháº©m</span>
                <div class="stats-summary-values">
                    <span>${summaryData.totalQuantity.toLocaleString('vi-VN')} mÃ³n</span>
                    <span>${summaryData.totalOrders.toLocaleString('vi-VN')} Ä‘Æ¡n hÃ ng</span>
                </div>
            </div>
            <div class="stats-table-container">
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Sáº¢N PHáº¨M</th>
                            <th>Sá» LÆ¯á»¢NG</th>
                            <th>MÃƒ ÄÆ N HÃ€NG (STT)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${tableRowsHtml}
                    </tbody>
                </table>
            </div>
        `;

        // Show campaign info
        const campaignName = selectedCampaign ? selectedCampaign.campaignName : 'KhÃ´ng cÃ³ chiáº¿n dá»‹ch';
        const campaignInfo = `<div class="stats-campaign-info"><i class="fas fa-video"></i>Chiáº¿n dá»‹ch: ${campaignName} | Cáº­p nháº­t: ${new Date().toLocaleString('vi-VN')}</div>`;

        modalBody.innerHTML = campaignInfo + statsHtml;

        // Save to Firebase
        await saveStatsToFirebase(statsHtml, summaryData);

        if (window.notificationManager) {
            window.notificationManager.show(`ÄÃ£ thá»‘ng kÃª ${summaryData.totalProducts} sáº£n pháº©m tá»« ${summaryData.totalOrders} Ä‘Æ¡n hÃ ng`, 'success');
        }

    } catch (error) {
        console.error('[PRODUCT-STATS] Error running stats:', error);
        modalBody.innerHTML = `
            <div class="stats-empty-state">
                <i class="fas fa-exclamation-circle" style="color: #ef4444;"></i>
                <p>Lá»—i khi thá»‘ng kÃª: ${error.message}</p>
            </div>
        `;
    } finally {
        if (runBtn) {
            runBtn.disabled = false;
            runBtn.innerHTML = '<i class="fas fa-play"></i> Thá»‘ng kÃª';
        }
    }
}

/**
 * Toggle stats summary collapse/expand
 */
function toggleStatsSummary(element) {
    element.classList.toggle('collapsed');
    const tableContainer = element.nextElementSibling;
    if (tableContainer) {
        tableContainer.style.display = element.classList.contains('collapsed') ? 'none' : 'block';
    }
}

// Make functions globally accessible
window.openProductStatsModal = openProductStatsModal;
window.closeProductStatsModal = closeProductStatsModal;
window.runProductStats = runProductStats;
window.toggleStatsSummary = toggleStatsSummary;

// =====================================================
// QR CODE MAPPING FOR ORDERS
// Mapping giá»¯a SÄT vÃ  mÃ£ QR tá»« balance-history
// =====================================================

const QR_CACHE_KEY = 'orders_phone_qr_cache';
const QR_API_URL = 'https://chatomni-proxy.nhijudyshop.workers.dev';

/**
 * Normalize phone number for consistent lookup
 * @param {string} phone - Raw phone number
 * @returns {string} Normalized phone number
 */
function normalizePhoneForQR(phone) {
    if (!phone) return '';
    // Remove all non-digit characters
    let cleaned = phone.replace(/\D/g, '');
    // Handle Vietnam country code: replace leading 84 with 0
    if (cleaned.startsWith('84') && cleaned.length > 9) {
        cleaned = '0' + cleaned.substring(2);
    }
    return cleaned;
}

/**
 * Get QR cache from localStorage
 * @returns {Object} Cache object { phone: { uniqueCode, createdAt, synced } }
 */
function getQRCache() {
    try {
        const cache = localStorage.getItem(QR_CACHE_KEY);
        return cache ? JSON.parse(cache) : {};
    } catch (e) {
        console.error('[QR] Error reading cache:', e);
        return {};
    }
}

/**
 * Save QR cache to localStorage
 * @param {Object} cache - Cache object to save
 */
function saveQRCache(cache) {
    try {
        localStorage.setItem(QR_CACHE_KEY, JSON.stringify(cache));
    } catch (e) {
        console.error('[QR] Error saving cache:', e);
    }
}

/**
 * Generate unique QR code (same format as balance-history)
 * Format: N2 + 16 characters (total 18 chars) - Base36 encoded
 * @returns {string} Unique code like "N2ABCD1234EFGH5678"
 */
function generateUniqueCode() {
    const timestamp = Date.now().toString(36).toUpperCase().slice(-8); // 8 chars
    const random = Math.random().toString(36).substring(2, 8).toUpperCase(); // 6 chars
    const sequence = Math.floor(Math.random() * 1296).toString(36).toUpperCase().padStart(2, '0'); // 2 chars
    return `N2${timestamp}${random}${sequence}`; // N2 (2) + 8 + 6 + 2 = 18 chars
}

/**
 * Get QR code for phone from cache
 * @param {string} phone - Phone number
 * @returns {string|null} Unique code or null
 */
function getQRFromCache(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) return null;

    const cache = getQRCache();
    return cache[normalizedPhone]?.uniqueCode || null;
}

/**
 * Save QR code to cache
 * @param {string} phone - Phone number
 * @param {string} uniqueCode - QR unique code
 * @param {boolean} synced - Whether synced to API
 */
function saveQRToCache(phone, uniqueCode, synced = false) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone || !uniqueCode) return;

    const cache = getQRCache();
    cache[normalizedPhone] = {
        uniqueCode: uniqueCode,
        createdAt: new Date().toISOString(),
        synced: synced
    };
    saveQRCache(cache);
}

/**
 * Fetch QR codes from balance-history API and populate cache
 * Called once when page loads
 */
async function syncQRFromBalanceHistory() {
    try {
        console.log('[QR] Syncing from balance-history API...');
        const response = await fetch(`${QR_API_URL}/api/sepay/customer-info`);
        const result = await response.json();

        if (result.success && result.data) {
            const cache = getQRCache();
            let newCount = 0;

            result.data.forEach(item => {
                if (item.customer_phone && item.unique_code) {
                    const normalizedPhone = normalizePhoneForQR(item.customer_phone);
                    if (normalizedPhone && !cache[normalizedPhone]) {
                        cache[normalizedPhone] = {
                            uniqueCode: item.unique_code,
                            createdAt: item.updated_at || new Date().toISOString(),
                            synced: true
                        };
                        newCount++;
                    }
                }
            });

            saveQRCache(cache);
            console.log(`[QR] âœ… Synced ${newCount} new phone-QR mappings from balance-history`);
        }
    } catch (error) {
        console.error('[QR] Failed to sync from balance-history:', error);
    }
}

/**
 * Save QR mapping to balance-history API
 * @param {string} phone - Phone number
 * @param {string} uniqueCode - QR unique code
 */
async function syncQRToBalanceHistory(phone, uniqueCode) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone || !uniqueCode) return;

    try {
        const response = await fetch(`${QR_API_URL}/api/sepay/customer-info`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                uniqueCode: uniqueCode,
                customerName: '',
                customerPhone: normalizedPhone
            })
        });

        const result = await response.json();

        if (result.success) {
            // Update cache to mark as synced
            saveQRToCache(normalizedPhone, uniqueCode, true);
            console.log(`[QR] âœ… Synced to balance-history: ${normalizedPhone} â†’ ${uniqueCode}`);
        } else {
            console.error('[QR] Failed to sync to balance-history:', result.error);
        }
    } catch (error) {
        console.error('[QR] Error syncing to balance-history:', error);
    }
}

/**
 * Get or create QR code for a phone number
 * @param {string} phone - Phone number
 * @returns {string|null} Unique code or null if no phone
 */
function getOrCreateQRForPhone(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) return null;

    // 1. Check cache first
    let uniqueCode = getQRFromCache(normalizedPhone);

    if (!uniqueCode) {
        // 2. Create new code
        uniqueCode = generateUniqueCode();

        // 3. Save to cache
        saveQRToCache(normalizedPhone, uniqueCode, false);

        // 4. Sync to balance-history API (async, don't wait)
        syncQRToBalanceHistory(normalizedPhone, uniqueCode);

        console.log(`[QR] Created new QR for ${normalizedPhone}: ${uniqueCode}`);
    }

    return uniqueCode;
}

/**
 * Copy QR code to clipboard
 * @param {string} phone - Phone number to get QR for
 */
async function copyQRCode(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) {
        showNotification('KhÃ´ng cÃ³ sá»‘ Ä‘iá»‡n thoáº¡i', 'warning');
        return;
    }

    const uniqueCode = getOrCreateQRForPhone(normalizedPhone);

    if (!uniqueCode) {
        showNotification('KhÃ´ng thá»ƒ táº¡o mÃ£ QR', 'error');
        return;
    }

    try {
        await navigator.clipboard.writeText(uniqueCode);
        showNotification('ÄÃ£ copy QR', 'success');
    } catch (error) {
        // Fallback for older browsers
        try {
            const textarea = document.createElement('textarea');
            textarea.value = uniqueCode;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            showNotification('ÄÃ£ copy QR', 'success');
        } catch (fallbackError) {
            console.error('[QR] Copy failed:', fallbackError);
            showNotification('KhÃ´ng thá»ƒ copy', 'error');
        }
    }
}

/**
 * Render QR column HTML
 * @param {string} phone - Phone number
 * @returns {string} HTML string for QR column
 */
function renderQRColumn(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);

    if (!normalizedPhone) {
        // No phone number - show disabled button
        return `
            <button class="btn-qr" disabled title="KhÃ´ng cÃ³ SÄT" style="
                padding: 4px 10px;
                border: none;
                border-radius: 4px;
                cursor: not-allowed;
                background: #e5e7eb;
                color: #9ca3af;
                font-size: 11px;
                font-weight: 600;
            ">
                QR
            </button>
        `;
    }

    // Check if QR exists in cache
    const existingQR = getQRFromCache(normalizedPhone);
    const hasQR = !!existingQR;

    return `
        <button class="btn-qr ${hasQR ? 'has-qr' : ''}"
                onclick="showOrderQRModal('${normalizedPhone}'); event.stopPropagation();"
                title="${hasQR ? 'Xem QR: ' + existingQR : 'Táº¡o QR má»›i'}"
                style="
                    padding: 4px 10px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    background: ${hasQR ? '#10b981' : '#3b82f6'};
                    color: white;
                    font-size: 11px;
                    font-weight: 600;
                    transition: all 0.2s;
                "
                onmouseover="this.style.opacity='0.8'"
                onmouseout="this.style.opacity='1'">
            QR
        </button>
    `;
}

/**
 * Show notification (uses existing notification system if available)
 * @param {string} message - Message to show
 * @param {string} type - 'success', 'error', 'warning', 'info'
 */
function showNotification(message, type = 'info') {
    // Try to use existing notification system
    if (window.NotificationManager && window.NotificationManager.show) {
        window.NotificationManager.show(message, type);
        return;
    }

    // Fallback: create simple toast notification
    const toast = document.createElement('div');
    toast.className = `qr-toast qr-toast-${type}`;
    toast.innerHTML = `
        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'times-circle' : type === 'warning' ? 'exclamation-triangle' : 'info-circle'}"></i>
        <span>${message}</span>
    `;
    toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 10000;
        animation: slideIn 0.3s ease;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
    `;

    document.body.appendChild(toast);

    // Auto remove after 2 seconds
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 2000);
}

// Add CSS animation for toast
const toastStyle = document.createElement('style');
toastStyle.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(toastStyle);

// Initialize: Sync QR data from balance-history when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Delay sync to let page load first
    setTimeout(() => {
        syncQRFromBalanceHistory();
    }, 2000);
});

// =====================================================
// QR MODAL FUNCTIONS
// =====================================================

// Bank configuration (same as balance-history)
const QR_BANK_CONFIG = {
    bin: '970416',
    name: 'ACB',
    accountNo: '75918',
    accountName: 'LAI THUY YEN NHI'
};

/**
 * Generate VietQR URL for bank transfer
 * @param {string} uniqueCode - Unique transaction code
 * @param {number} amount - Transfer amount (optional, 0 = no amount shown)
 * @returns {string} VietQR image URL
 */
function generateVietQRUrl(uniqueCode, amount = 0) {
    const baseUrl = 'https://img.vietqr.io/image';
    // Use compact2 when showing amount (has bank branding + amount line)
    // Use compact when no amount (bank branding without amount line)
    const template = amount > 0 ? 'compact2' : 'compact';
    let url = `${baseUrl}/${QR_BANK_CONFIG.bin}-${QR_BANK_CONFIG.accountNo}-${template}.png`;

    const params = new URLSearchParams();
    if (amount > 0) {
        params.append('amount', amount);
    }
    params.append('addInfo', uniqueCode);
    params.append('accountName', QR_BANK_CONFIG.accountName);

    return `${url}?${params.toString()}`;
}

/**
 * Show QR Modal for a phone number
 * @param {string} phone - Phone number
 * @param {number} amount - Transfer amount (optional)
 * @param {object} options - Display options { hideAccountNumber: boolean, showAccountNameOnly: boolean }
 */
function showOrderQRModal(phone, amount = 0, options = {}) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) {
        showNotification('KhÃ´ng cÃ³ sá»‘ Ä‘iá»‡n thoáº¡i', 'warning');
        return;
    }

    // Get or create QR code
    const uniqueCode = getOrCreateQRForPhone(normalizedPhone);
    if (!uniqueCode) {
        showNotification('KhÃ´ng thá»ƒ táº¡o mÃ£ QR', 'error');
        return;
    }

    // Generate QR URL with amount
    const qrUrl = generateVietQRUrl(uniqueCode, amount);

    // Get modal elements
    const modal = document.getElementById('orderQRModal');
    const modalBody = document.getElementById('orderQRModalBody');

    // Format amount for display
    const amountText = amount > 0 ? `<strong>Sá»‘ tiá»n:</strong> <span style="color: #059669; font-weight: 700;">${amount.toLocaleString('vi-VN')}Ä‘</span><br>` : '';

    // Build account info based on options
    let accountInfoHTML = '';
    if (options.showAccountNameOnly) {
        // Only show account name (for copyQRImageFromChat)
        accountInfoHTML = `<strong>Chá»§ TK:</strong> ${QR_BANK_CONFIG.accountName}<br>`;
    } else {
        // Show full info or hide account number based on hideAccountNumber option
        const bankLine = `<strong>NgÃ¢n hÃ ng:</strong> ${QR_BANK_CONFIG.name}<br>`;
        const accountNoLine = options.hideAccountNumber ? '' : `<strong>Sá»‘ TK:</strong> ${QR_BANK_CONFIG.accountNo}<br>`;
        const accountNameLine = `<strong>Chá»§ TK:</strong> ${QR_BANK_CONFIG.accountName}<br>`;
        accountInfoHTML = bankLine + accountNoLine + accountNameLine;
    }

    // Render modal content
    modalBody.innerHTML = `
        <img src="${qrUrl}" alt="QR Code" style="width: 280px; max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">

        <div style="margin-top: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; text-align: left; font-size: 13px;">
            <div style="margin-bottom: 8px;">
                ${accountInfoHTML}
                ${amountText}
            </div>
            <div style="padding: 8px; background: white; border: 2px dashed #dee2e6; border-radius: 6px; font-family: monospace; font-size: 13px; font-weight: bold; color: #495057; text-align: center;">
                ${uniqueCode}
            </div>
        </div>

        <div style="margin-top: 16px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
            <button onclick="copyQRCodeFromModal('${uniqueCode}')" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">
                <i class="fas fa-copy"></i> Copy mÃ£
            </button>
            <button onclick="copyQRImageUrl('${qrUrl}')" style="padding: 8px 16px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">
                <i class="fas fa-image"></i> Copy URL
            </button>
        </div>

        <div style="margin-top: 12px; padding: 10px; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px; font-size: 12px; color: #92400e; text-align: left;">
            <strong>LÆ°u Ã½:</strong> KhÃ¡ch hÃ ng cáº§n nháº­p Ä‘Ãºng mÃ£ <strong>${uniqueCode}</strong> khi chuyá»ƒn khoáº£n.
        </div>
    `;

    // Show modal
    modal.style.display = 'flex';
}

/**
 * Close QR Modal
 */
function closeOrderQRModal() {
    const modal = document.getElementById('orderQRModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Copy QR code from modal
 * @param {string} uniqueCode - QR code to copy
 */
async function copyQRCodeFromModal(uniqueCode) {
    try {
        await navigator.clipboard.writeText(uniqueCode);
        showNotification('ÄÃ£ copy QR', 'success');
    } catch (error) {
        // Fallback
        const textarea = document.createElement('textarea');
        textarea.value = uniqueCode;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        showNotification('ÄÃ£ copy QR', 'success');
    }
}

/**
 * Copy QR image URL
 * @param {string} url - URL to copy
 */
async function copyQRImageUrl(url) {
    try {
        await navigator.clipboard.writeText(url);
        showNotification('ÄÃ£ copy URL', 'success');
    } catch (error) {
        showNotification('KhÃ´ng thá»ƒ copy', 'error');
    }
}

// Close modal when clicking outside
document.addEventListener('click', function (event) {
    const modal = document.getElementById('orderQRModal');
    if (modal && event.target === modal) {
        closeOrderQRModal();
    }
});

// =====================================================
// QR FUNCTIONS FOR CHAT MODAL
// =====================================================

// QR Amount Toggle Setting
const QR_AMOUNT_SETTING_KEY = 'qr_show_amount';
let qrShowAmountEnabled = true; // Default: show amount

/**
 * Load QR amount toggle setting from localStorage and Firebase
 */
async function loadQRAmountSetting() {
    try {
        // 1. Try localStorage first (for quick load)
        if (window.userStorageManager) {
            const localValue = window.userStorageManager.loadFromLocalStorage(QR_AMOUNT_SETTING_KEY);
            if (localValue !== null) {
                qrShowAmountEnabled = localValue === true || localValue === 'true';
                updateQRAmountToggleUI();
                console.log('[QR-SETTING] Loaded from localStorage:', qrShowAmountEnabled);
            }
        }

        // 2. Try Firebase (source of truth)
        if (window.firebase && window.userStorageManager) {
            const firebaseValue = await window.userStorageManager.loadFromFirebase(
                window.firebase.database(),
                `settings/${QR_AMOUNT_SETTING_KEY}`
            );
            if (firebaseValue !== null) {
                qrShowAmountEnabled = firebaseValue === true || firebaseValue === 'true';
                // Sync to localStorage
                window.userStorageManager.saveToLocalStorage(QR_AMOUNT_SETTING_KEY, qrShowAmountEnabled);
                updateQRAmountToggleUI();
                console.log('[QR-SETTING] Loaded from Firebase:', qrShowAmountEnabled);
            }
        }
    } catch (error) {
        console.error('[QR-SETTING] Error loading setting:', error);
    }
}

/**
 * Save QR amount toggle setting to localStorage and Firebase
 */
async function saveQRAmountSetting() {
    try {
        // 1. Save to localStorage
        if (window.userStorageManager) {
            window.userStorageManager.saveToLocalStorage(QR_AMOUNT_SETTING_KEY, qrShowAmountEnabled);
            console.log('[QR-SETTING] Saved to localStorage:', qrShowAmountEnabled);
        }

        // 2. Save to Firebase
        if (window.firebase && window.userStorageManager) {
            await window.userStorageManager.saveToFirebase(
                window.firebase.database(),
                `settings/${QR_AMOUNT_SETTING_KEY}`,
                qrShowAmountEnabled
            );
            console.log('[QR-SETTING] Saved to Firebase:', qrShowAmountEnabled);
        }
    } catch (error) {
        console.error('[QR-SETTING] Error saving setting:', error);
    }
}

/**
 * Update QR amount toggle button UI
 */
function updateQRAmountToggleUI() {
    const toggleBtn = document.getElementById('qrAmountToggle');
    if (!toggleBtn) return;

    if (qrShowAmountEnabled) {
        toggleBtn.style.background = 'rgba(16, 185, 129, 0.8)'; // Green - enabled
        toggleBtn.title = 'Sá»‘ tiá»n: Báº¬T - Click Ä‘á»ƒ táº¯t';
    } else {
        toggleBtn.style.background = 'rgba(107, 114, 128, 0.6)'; // Gray - disabled
        toggleBtn.title = 'Sá»‘ tiá»n: Táº®T - Click Ä‘á»ƒ báº­t';
    }
}

/**
 * Toggle QR amount setting
 */
async function toggleQRAmountSetting() {
    qrShowAmountEnabled = !qrShowAmountEnabled;
    updateQRAmountToggleUI();
    await saveQRAmountSetting();

    const statusText = qrShowAmountEnabled ? 'Báº¬T' : 'Táº®T';
    showNotification(`Sá»‘ tiá»n trong QR: ${statusText}`, 'info');
}

// Export toggle functions
window.toggleQRAmountSetting = toggleQRAmountSetting;
window.loadQRAmountSetting = loadQRAmountSetting;

// Load setting on page load
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        loadQRAmountSetting();
    }, 1500);
});

/**
 * Copy QR image from chat modal to clipboard
 * Gets the current order's phone and copies the VietQR image with account name text below
 * The copied image includes QR code + "Chá»§ TK: [Account Name]" text
 */
async function copyQRImageFromChat() {
    if (!currentOrder || !currentOrder.Telephone) {
        showNotification('KhÃ´ng cÃ³ sá»‘ Ä‘iá»‡n thoáº¡i', 'warning');
        return;
    }

    const phone = currentOrder.Telephone;
    const normalizedPhone = normalizePhoneForQR(phone);

    if (!normalizedPhone) {
        showNotification('Sá»‘ Ä‘iá»‡n thoáº¡i khÃ´ng há»£p lá»‡', 'warning');
        return;
    }

    // Get or create QR code
    const uniqueCode = getOrCreateQRForPhone(normalizedPhone);
    if (!uniqueCode) {
        showNotification('KhÃ´ng thá»ƒ táº¡o mÃ£ QR', 'error');
        return;
    }

    // Always use 0 amount to allow customer to customize
    const amount = 0;

    // Generate QR URL with amount
    const qrUrl = generateVietQRUrl(uniqueCode, amount);

    try {
        // Fetch the QR image
        const response = await fetch(qrUrl);
        const blob = await response.blob();

        // Create an image element from the blob
        const img = new Image();
        const imageUrl = URL.createObjectURL(blob);

        // Wait for image to load
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = imageUrl;
        });

        // Create canvas to draw QR + text
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas dimensions (QR image width + padding + text area)
        const padding = 20;
        const textHeight = 60;
        canvas.width = img.width + (padding * 2);
        canvas.height = img.height + textHeight + (padding * 2);

        // Fill white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw QR image
        ctx.drawImage(img, padding, padding, img.width, img.height);

        // Draw account name text below QR
        ctx.fillStyle = '#1f2937';
        ctx.font = 'bold 16px Arial, sans-serif';
        ctx.textAlign = 'center';
        const accountNameText = `Chá»§ TK: ${QR_BANK_CONFIG.accountName}`;
        ctx.fillText(accountNameText, canvas.width / 2, img.height + padding + 30);

        // Convert canvas to blob
        const canvasBlob = await new Promise(resolve => {
            canvas.toBlob(resolve, 'image/png');
        });

        // Copy to clipboard
        const clipboardItem = new ClipboardItem({
            'image/png': canvasBlob
        });

        await navigator.clipboard.write([clipboardItem]);
        showNotification('ÄÃ£ copy áº£nh QR (cÃ³ tÃªn Chá»§ TK)', 'success');
        console.log(`[QR-CHAT] Copied QR image with account name for ${normalizedPhone}: ${uniqueCode}`);

        // Clean up
        URL.revokeObjectURL(imageUrl);
    } catch (error) {
        console.error('[QR-CHAT] Failed to copy image:', error);
        // Fallback: copy URL instead
        try {
            await navigator.clipboard.writeText(qrUrl);
            showNotification('ÄÃ£ copy URL áº£nh QR', 'success');
        } catch (fallbackError) {
            showNotification('KhÃ´ng thá»ƒ copy áº£nh QR', 'error');
        }
    }
}

/**
 * Show QR modal from chat modal
 * Opens the same QR modal as the table button
 * Always shows with amount = 0 to allow customer to customize
 */
function showQRFromChat() {
    if (!currentOrder || !currentOrder.Telephone) {
        showNotification('KhÃ´ng cÃ³ sá»‘ Ä‘iá»‡n thoáº¡i', 'warning');
        return;
    }

    const phone = currentOrder.Telephone;
    const normalizedPhone = normalizePhoneForQR(phone);

    if (!normalizedPhone) {
        showNotification('Sá»‘ Ä‘iá»‡n thoáº¡i khÃ´ng há»£p lá»‡', 'warning');
        return;
    }

    // Always use 0 amount to allow customer to customize
    const amount = 0;

    // Use existing QR modal function with amount = 0, hide account number (Sá»‘ TK)
    showOrderQRModal(normalizedPhone, amount, { hideAccountNumber: true });
}

// Export functions globally
window.copyQRImageFromChat = copyQRImageFromChat;
window.showQRFromChat = showQRFromChat;

// =====================================================
// CHAT MODAL DEBT DISPLAY
// =====================================================

/**
 * Load and display debt in chat modal header
 * NOTE: Always fetches fresh data from API (same source as salePrepaidAmount)
 * @param {string} phone - Phone number
 */
async function loadChatDebt(phone) {
    const debtValueEl = document.getElementById('chatDebtValue');
    if (!debtValueEl) return;

    const normalizedPhone = normalizePhoneForQR(phone);

    if (!normalizedPhone) {
        debtValueEl.textContent = '-';
        debtValueEl.style.color = 'rgba(255, 255, 255, 0.6)';
        return;
    }

    // Show loading
    debtValueEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    debtValueEl.style.color = 'rgba(255, 255, 255, 0.8)';

    // Always fetch fresh from API (same source as salePrepaidAmount in fetchDebtForSaleModal)
    try {
        const response = await fetch(`${QR_API_URL}/api/sepay/debt-summary?phone=${encodeURIComponent(normalizedPhone)}`);
        const result = await response.json();

        if (result.success && result.data) {
            const totalDebt = result.data.total_debt || 0;
            console.log('[CHAT-DEBT] Realtime debt for phone:', normalizedPhone, '=', totalDebt);

            // Update cache for consistency with debt column
            saveDebtToCache(normalizedPhone, totalDebt);
            updateChatDebtDisplay(totalDebt);

            // Also update debt column in orders table to keep them in sync
            updateDebtCellsInTable(normalizedPhone, totalDebt);
        } else {
            updateChatDebtDisplay(0);
        }
    } catch (error) {
        console.error('[CHAT-DEBT] Error loading debt:', error);
        debtValueEl.textContent = '-';
        debtValueEl.style.color = 'rgba(255, 255, 255, 0.6)';
    }
}

/**
 * Update chat modal debt display
 * @param {number} debt - Debt amount
 */
function updateChatDebtDisplay(debt) {
    const debtValueEl = document.getElementById('chatDebtValue');
    if (!debtValueEl) return;

    if (debt > 0) {
        debtValueEl.textContent = formatDebtCurrency(debt);
        debtValueEl.style.color = '#4ade80'; // Green for positive debt
    } else {
        debtValueEl.textContent = '0Ä‘';
        debtValueEl.style.color = 'rgba(255, 255, 255, 0.6)';
    }
}

// Export chat debt function
window.loadChatDebt = loadChatDebt;

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                   SECTION 17: QR CODE & DEBT FUNCTIONS                      â•‘
// â•‘                            search: #QR-DEBT                                 â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// DEBT (CÃ”NG Ná»¢) FUNCTIONS #QR-DEBT
// =====================================================

const DEBT_CACHE_KEY = 'orders_phone_debt_cache';
const DEBT_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Get debt cache from localStorage
 * @returns {Object} Cache object { phone: { totalDebt, lastFetched } }
 */
function getDebtCache() {
    try {
        const cache = localStorage.getItem(DEBT_CACHE_KEY);
        return cache ? JSON.parse(cache) : {};
    } catch (e) {
        console.error('[DEBT] Error reading cache:', e);
        return {};
    }
}

/**
 * Save debt cache to localStorage
 * @param {Object} cache - Cache object to save
 */
function saveDebtCache(cache) {
    try {
        localStorage.setItem(DEBT_CACHE_KEY, JSON.stringify(cache));
    } catch (e) {
        console.error('[DEBT] Error saving cache:', e);
    }
}

/**
 * Get cached debt for a phone number
 * @param {string} phone - Phone number
 * @returns {number|null} Total debt or null if not cached/expired
 */
function getCachedDebt(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) return null;

    const cache = getDebtCache();
    const cached = cache[normalizedPhone];

    if (cached && (Date.now() - cached.lastFetched) < DEBT_CACHE_TTL) {
        return cached.totalDebt;
    }

    return null;
}

/**
 * Save debt to cache
 * @param {string} phone - Phone number
 * @param {number} totalDebt - Total debt amount
 */
function saveDebtToCache(phone, totalDebt) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) return;

    const cache = getDebtCache();
    cache[normalizedPhone] = {
        totalDebt: totalDebt,
        lastFetched: Date.now()
    };
    saveDebtCache(cache);
}

/**
 * Fetch debt from API for a phone number
 * @param {string} phone - Phone number
 * @returns {Promise<number>} Total debt
 */
async function fetchDebtForPhone(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) return 0;

    try {
        const response = await fetch(`${QR_API_URL}/api/sepay/debt-summary?phone=${encodeURIComponent(normalizedPhone)}`);
        const result = await response.json();

        if (result.success && result.data) {
            const totalDebt = result.data.total_debt || 0;
            saveDebtToCache(normalizedPhone, totalDebt);
            return totalDebt;
        }
    } catch (error) {
        console.error('[DEBT] Error fetching:', error);
    }

    return 0;
}

/**
 * Format currency for display
 * @param {number} amount - Amount
 * @returns {string} Formatted string
 */
function formatDebtCurrency(amount) {
    if (!amount || amount === 0) return '0Ä‘';
    return new Intl.NumberFormat('vi-VN').format(amount) + 'Ä‘';
}

/**
 * Render debt column HTML
 * NOTE: This now only shows cached value or loading spinner.
 * Actual fetching is done by batchFetchDebts() after table render.
 * Click opens Customer 360Â° modal if WalletIntegration is available.
 * @param {string} phone - Phone number
 * @returns {string} HTML string for debt column
 */
function renderDebtColumn(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);

    if (!normalizedPhone) {
        return `<span style="color: #9ca3af;">-</span>`;
    }

    // Check cache first
    const cachedDebt = getCachedDebt(normalizedPhone);

    if (cachedDebt !== null) {
        // Has cached value - display immediately with click to open Customer 360Â° modal
        const color = cachedDebt > 0 ? '#10b981' : '#9ca3af';
        const clickHandler = typeof WalletIntegration !== 'undefined'
            ? `onclick="WalletIntegration.showWalletModal('${normalizedPhone}'); event.stopPropagation();" style="cursor: pointer;" title="Click Ä‘á»ƒ xem chi tiáº¿t vÃ­"`
            : '';
        return `<span ${clickHandler} style="color: ${color}; font-weight: 500; font-size: 12px;${typeof WalletIntegration !== 'undefined' ? ' cursor: pointer;' : ''}">${formatDebtCurrency(cachedDebt)}</span>`;
    }

    // No cache - show loading spinner (batchFetchDebts will update this later)
    // Do NOT call fetchDebtForPhone here to avoid spam!
    return `<span class="debt-loading" data-phone="${normalizedPhone}" style="color: #9ca3af; font-size: 11px;"><i class="fas fa-spinner fa-spin"></i></span>`;
}

/**
 * Update all debt cells with a specific phone number
 * @param {string} phone - Normalized phone number
 * @param {number} debt - Debt amount
 */
function updateDebtCells(phone, debt) {
    const color = debt > 0 ? '#10b981' : '#9ca3af';
    // Add click handler if WalletIntegration is available
    const clickHandler = typeof WalletIntegration !== 'undefined'
        ? `onclick="WalletIntegration.showWalletModal('${phone}'); event.stopPropagation();" style="cursor: pointer;" title="Click Ä‘á»ƒ xem chi tiáº¿t vÃ­"`
        : '';
    const html = `<span ${clickHandler} style="color: ${color}; font-weight: 500; font-size: 12px;${typeof WalletIntegration !== 'undefined' ? ' cursor: pointer;' : ''}">${formatDebtCurrency(debt)}</span>`;

    // Find all loading cells with this phone and update them
    document.querySelectorAll(`.debt-loading[data-phone="${phone}"]`).forEach(cell => {
        cell.outerHTML = html;
    });
}

/**
 * Batch fetch debts for multiple phones using NEW batch API
 * Reduces 80 API calls â†’ 1 API call!
 * @param {Array<string>} phones - Array of phone numbers
 */
async function batchFetchDebts(phones) {
    // Validate input
    if (!phones || !Array.isArray(phones)) {
        console.warn('[DEBT-BATCH] Invalid input - phones must be an array');
        return;
    }

    const uniquePhones = [...new Set(phones.map(p => normalizePhoneForQR(p)).filter(p => p))];
    const uncachedPhones = uniquePhones.filter(p => getCachedDebt(p) === null);

    // Double-check before API call to prevent 400 errors
    if (!Array.isArray(uncachedPhones) || uncachedPhones.length === 0) {
        console.log('[DEBT-BATCH] No uncached phones to fetch, skipping API call');
        return;
    }

    console.log(`[DEBT-BATCH] Fetching ${uncachedPhones.length} phones in ONE request...`);

    try {
        // Call batch API - ONE request for ALL phones!
        const requestBody = JSON.stringify({ phones: uncachedPhones });
        console.log('[DEBT-BATCH] Request body:', requestBody);

        const response = await fetch(`${QR_API_URL}/api/sepay/debt-summary-batch`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: requestBody
        });

        // Check response status first
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`[DEBT-BATCH] âŒ HTTP ${response.status}: ${errorText}`);
            // Fallback: set all to 0
            for (const phone of uncachedPhones) {
                updateDebtCells(phone, 0);
            }
            return;
        }

        const result = await response.json();

        if (result.success && result.data) {
            console.log(`[DEBT-BATCH] âœ… Received ${result.count || Object.keys(result.data).length} results`);

            // Update cache and UI for all phones
            for (const [phone, debtData] of Object.entries(result.data)) {
                const totalDebt = debtData.total_debt || 0;
                saveDebtToCache(phone, totalDebt);
                updateDebtCells(phone, totalDebt);
            }

            // Handle phones that weren't in the response (set to 0)
            for (const phone of uncachedPhones) {
                if (!result.data[phone]) {
                    saveDebtToCache(phone, 0);
                    updateDebtCells(phone, 0);
                }
            }
        } else {
            console.error('[DEBT-BATCH] âŒ API error:', result.error);
            // Fallback: set all to 0
            for (const phone of uncachedPhones) {
                updateDebtCells(phone, 0);
            }
        }
    } catch (error) {
        console.error('[DEBT-BATCH] âŒ Network error:', error);
        // Fallback: set all to 0
        for (const phone of uncachedPhones) {
            updateDebtCells(phone, 0);
        }
    }
}

// Make QR and Debt functions globally accessible
window.copyQRCode = copyQRCode;
window.getOrCreateQRForPhone = getOrCreateQRForPhone;
window.renderQRColumn = renderQRColumn;
window.syncQRFromBalanceHistory = syncQRFromBalanceHistory;
window.showOrderQRModal = showOrderQRModal;
window.closeOrderQRModal = closeOrderQRModal;
window.copyQRCodeFromModal = copyQRCodeFromModal;
window.copyQRImageUrl = copyQRImageUrl;
window.renderDebtColumn = renderDebtColumn;
window.fetchDebtForPhone = fetchDebtForPhone;
window.batchFetchDebts = batchFetchDebts;

// =====================================================
// REALTIME DEBT UPDATES (SSE)
// Láº¯ng nghe giao dá»‹ch má»›i Ä‘á»ƒ cáº­p nháº­t cÃ´ng ná»£
// =====================================================

let debtEventSource = null;
let debtReconnectTimeout = null;
let isDebtManualClose = false;

/**
 * Extract phone number from transaction content
 * TÃ¬m SÄT trong ná»™i dung giao dá»‹ch hoáº·c tá»« customer-info mapping
 * @param {Object} transaction - Transaction object
 * @returns {string|null} Phone number or null
 */
function extractPhoneFromTransaction(transaction) {
    const content = transaction.content || '';

    // Try to find unique code (N2XXXXXXXXXX) in content
    const uniqueCodeMatch = content.match(/\bN2[A-Z0-9]{16}\b/);

    if (uniqueCodeMatch) {
        const uniqueCode = uniqueCodeMatch[0];
        // Look up phone from QR cache (reverse lookup)
        const qrCache = getQRCache();
        for (const [phone, data] of Object.entries(qrCache)) {
            if (data.uniqueCode === uniqueCode) {
                return phone;
            }
        }
    }

    return null;
}

/**
 * Handle new transaction from SSE - update debt
 * @param {Object} transaction - Transaction data
 */
async function handleDebtTransaction(transaction) {
    // Only care about incoming transactions (deposits)
    if (transaction.transfer_type !== 'in') return;

    const phone = extractPhoneFromTransaction(transaction);

    if (phone) {
        console.log(`[DEBT-REALTIME] New transaction for phone ${phone}, refreshing debt...`);

        // Invalidate cache for this phone
        const cache = getDebtCache();
        delete cache[phone];
        saveDebtCache(cache);

        // Re-fetch debt
        const newDebt = await fetchDebtForPhone(phone);

        // Update all cells in the table
        updateDebtCellsInTable(phone, newDebt);

        // Show notification
        showNotification(`Cáº­p nháº­t cÃ´ng ná»£: ${formatDebtCurrency(newDebt)}`, 'info');
    }
}

/**
 * Update debt cells in the orders table
 * @param {string} phone - Phone number
 * @param {number} debt - New debt amount
 */
function updateDebtCellsInTable(phone, debt) {
    const color = debt > 0 ? '#10b981' : '#9ca3af';
    const html = `<span style="color: ${color}; font-weight: 500; font-size: 12px;">${formatDebtCurrency(debt)}</span>`;

    // Find all debt cells and update those matching this phone
    document.querySelectorAll('td[data-column="debt"]').forEach(cell => {
        // Get the phone from the same row
        const row = cell.closest('tr');
        if (row) {
            const phoneCell = row.querySelector('td[data-column="phone"]');
            if (phoneCell) {
                const cellPhone = normalizePhoneForQR(phoneCell.textContent.trim());
                if (cellPhone === phone) {
                    cell.innerHTML = html;
                }
            }
        }
    });
}

/**
 * Connect to SSE endpoint for realtime debt updates
 */
function connectDebtRealtime() {
    if (debtEventSource) return; // Already connected

    try {
        console.log('[DEBT-REALTIME] Connecting to SSE endpoint...');
        debtEventSource = new EventSource(`${QR_API_URL}/api/sepay/stream`);

        // Connection established
        debtEventSource.addEventListener('connected', (e) => {
            console.log('[DEBT-REALTIME] âœ… Connected to SSE');
        });

        // New transaction received
        debtEventSource.addEventListener('new-transaction', (e) => {
            try {
                const transaction = JSON.parse(e.data);
                console.log('[DEBT-REALTIME] New transaction:', transaction.content?.substring(0, 50));
                handleDebtTransaction(transaction);
            } catch (err) {
                console.error('[DEBT-REALTIME] Error parsing transaction:', err);
            }
        });

        // Connection error
        debtEventSource.onerror = (error) => {
            console.error('[DEBT-REALTIME] SSE Error:', error);

            // Close current connection
            if (debtEventSource) {
                debtEventSource.close();
                debtEventSource = null;
            }

            // Attempt to reconnect after 10 seconds (if not manually closed)
            if (!isDebtManualClose) {
                clearTimeout(debtReconnectTimeout);
                debtReconnectTimeout = setTimeout(() => {
                    console.log('[DEBT-REALTIME] Attempting to reconnect...');
                    connectDebtRealtime();
                }, 10000);
            }
        };

    } catch (error) {
        console.error('[DEBT-REALTIME] Failed to connect:', error);
    }
}

/**
 * Disconnect from SSE
 */
function disconnectDebtRealtime() {
    isDebtManualClose = true;
    clearTimeout(debtReconnectTimeout);

    if (debtEventSource) {
        debtEventSource.close();
        debtEventSource = null;
        console.log('[DEBT-REALTIME] Disconnected from SSE');
    }
}

// Auto-connect realtime when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Delay connection to let page load first
    setTimeout(() => {
        connectDebtRealtime();
    }, 3000);
});

// =====================================================
// SALE BUTTON MODAL FUNCTIONS
// =====================================================
let currentSaleOrderData = null;
let currentSalePartnerData = null;

// =====================================================
// DELIVERY CARRIER MANAGEMENT
// =====================================================
const DELIVERY_CARRIER_CACHE_KEY = 'tpos_delivery_carriers';
const DELIVERY_CARRIER_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours

/**
 * Get cached delivery carriers from localStorage
 * @returns {Array|null} Cached carriers or null if expired/not found
 */
function getCachedDeliveryCarriers() {
    try {
        const cached = localStorage.getItem(DELIVERY_CARRIER_CACHE_KEY);
        if (!cached) return null;

        const { data, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp > DELIVERY_CARRIER_CACHE_TTL) {
            localStorage.removeItem(DELIVERY_CARRIER_CACHE_KEY);
            return null;
        }
        return data;
    } catch (e) {
        console.error('[DELIVERY-CARRIER] Error reading cache:', e);
        return null;
    }
}

/**
 * Save delivery carriers to localStorage cache
 * @param {Array} carriers - Array of carrier objects
 */
function saveDeliveryCarriersToCache(carriers) {
    try {
        localStorage.setItem(DELIVERY_CARRIER_CACHE_KEY, JSON.stringify({
            data: carriers,
            timestamp: Date.now()
        }));
    } catch (e) {
        console.error('[DELIVERY-CARRIER] Error saving cache:', e);
    }
}

/**
 * Fetch delivery carriers from TPOS API
 * @returns {Promise<Array>} Array of delivery carrier objects
 */
async function fetchDeliveryCarriers() {
    // Check cache first
    const cached = getCachedDeliveryCarriers();
    if (cached) {
        console.log('[DELIVERY-CARRIER] Using cached data:', cached.length, 'carriers');
        return cached;
    }

    // Get auth token from various possible localStorage keys
    // Priority: bearer_token_data > auth > tpos_token
    let token = null;
    try {
        // Try bearer_token_data first (most common key used by TPOS)
        const bearerData = localStorage.getItem('bearer_token_data');
        if (bearerData) {
            const parsed = JSON.parse(bearerData);
            token = parsed.access_token || parsed.AccessToken;
            console.log('[DELIVERY-CARRIER] Found token in bearer_token_data');
        }

        // Fallback to auth
        if (!token) {
            const authData = localStorage.getItem('auth');
            if (authData) {
                const parsed = JSON.parse(authData);
                token = parsed.AccessToken || parsed.access_token;
                console.log('[DELIVERY-CARRIER] Found token in auth');
            }
        }

        // Fallback to tpos_token
        if (!token) {
            const tokenData = localStorage.getItem('tpos_token');
            if (tokenData) {
                const parsed = JSON.parse(tokenData);
                token = parsed.AccessToken || parsed.access_token;
                console.log('[DELIVERY-CARRIER] Found token in tpos_token');
            }
        }
    } catch (e) {
        console.error('[DELIVERY-CARRIER] Error parsing auth:', e);
    }

    if (!token) {
        console.warn('[DELIVERY-CARRIER] No auth token found in: bearer_token_data, auth, tpos_token');
        return [];
    }

    try {
        // Use Cloudflare Worker proxy to bypass CORS
        // Proxy: /api/odata/* â†’ tomato.tpos.vn/odata/*
        const proxyUrl = 'https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/DeliveryCarrier?$format=json&$orderby=DateCreated+desc&$filter=Active+eq+true&$count=true';
        console.log('[DELIVERY-CARRIER] Fetching from proxy:', proxyUrl);

        const response = await fetch(proxyUrl, {
            method: 'GET',
            headers: {
                'accept': 'application/json, text/javascript, */*; q=0.01',
                'authorization': `Bearer ${token}`,
                'tposappversion': window.TPOS_CONFIG?.tposAppVersion || '5.11.16.1'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        const carriers = data.value || [];

        console.log('[DELIVERY-CARRIER] Fetched:', carriers.length, 'carriers');

        // Save to cache
        saveDeliveryCarriersToCache(carriers);

        return carriers;
    } catch (error) {
        console.error('[DELIVERY-CARRIER] Error fetching:', error);
        return [];
    }
}

/**
 * Populate delivery partner dropdown with carriers
 * @param {string} selectedId - Optional: ID of carrier to select
 */
async function populateDeliveryCarrierDropdown(selectedId = null) {
    console.log('[DELIVERY-CARRIER] populateDeliveryCarrierDropdown called');

    const select = document.getElementById('saleDeliveryPartner');
    if (!select) {
        console.error('[DELIVERY-CARRIER] Select element not found!');
        return;
    }

    console.log('[DELIVERY-CARRIER] Found select element, showing loading...');

    // Show loading
    select.innerHTML = '<option value="">Äang táº£i...</option>';
    select.disabled = true;

    const carriers = await fetchDeliveryCarriers();
    console.log('[DELIVERY-CARRIER] Got carriers:', carriers.length);

    // Build options
    let optionsHtml = '<option value="">-- Chá»n Ä‘á»‘i tÃ¡c giao hÃ ng --</option>';
    carriers.forEach(carrier => {
        const fee = carrier.Config_DefaultFee || carrier.FixedPrice || 0;
        const feeText = fee > 0 ? ` (${formatCurrencyVND(fee)})` : '';
        const selected = selectedId && carrier.Id == selectedId ? 'selected' : '';
        optionsHtml += `<option value="${carrier.Id}" data-fee="${fee}" data-name="${carrier.Name}"${selected}>${carrier.Name}${feeText}</option>`;
    });

    select.innerHTML = optionsHtml;
    select.disabled = false;

    // Add change event to update shipping fee
    select.onchange = function () {
        const selectedOption = this.options[this.selectedIndex];
        const fee = parseFloat(selectedOption.dataset.fee) || 0;
        const shippingFeeInput = document.getElementById('saleShippingFee');
        if (shippingFeeInput) {
            shippingFeeInput.value = fee;
            // Trigger recalculation of COD
            updateSaleCOD();
        }
    };

    // If a carrier was pre-selected, trigger the change event to set fee
    if (selectedId) {
        select.dispatchEvent(new Event('change'));
    }
}

/**
 * Update COD based on total amount, shipping fee, and prepaid amount
 */
function updateSaleCOD() {
    const totalAmount = parseFloat(document.getElementById('saleTotalAmount')?.textContent?.replace(/[^\d]/g, '')) || 0;
    const shippingFee = parseFloat(document.getElementById('saleShippingFee')?.value) || 0;
    const codInput = document.getElementById('saleCOD');

    if (codInput) {
        // COD = Total + Shipping (khÃ´ng trá»« prepaid)
        const cod = totalAmount + shippingFee;
        codInput.value = cod;
    }

    // Update remaining balance after COD changes
    updateSaleRemainingBalance();
}

/**
 * Update Remaining Balance (CÃ²n láº¡i) in the modal
 * Logic:
 * - If Prepaid >= COD: Remaining = 0
 * - If Prepaid < COD: Remaining = COD - Prepaid
 */
function updateSaleRemainingBalance() {
    const codValue = parseFloat(document.getElementById('saleCOD')?.value) || 0;
    const prepaidAmount = parseFloat(document.getElementById('salePrepaidAmount')?.value) || 0;
    const remainingElement = document.getElementById('saleRemainingBalance');

    if (remainingElement) {
        let remaining = 0;
        if (prepaidAmount < codValue) {
            remaining = codValue - prepaidAmount;
        }
        // Format the remaining balance
        remainingElement.textContent = formatNumber(remaining);
    }
}

// Export remaining balance function to window for debugging
window.updateSaleRemainingBalance = updateSaleRemainingBalance;

// Export delivery carrier functions to window for debugging
window.fetchDeliveryCarriers = fetchDeliveryCarriers;
window.populateDeliveryCarrierDropdown = populateDeliveryCarrierDropdown;
window.getCachedDeliveryCarriers = getCachedDeliveryCarriers;

/**
 * Smart select delivery partner based on customer address
 * Parses the carrier names to find matching district/ward
 * @param {string} address - Full customer address string
 * @param {object} extraAddress - Optional ExtraAddress object with District, Ward, City
 */
function smartSelectDeliveryPartner(address, extraAddress = null) {
    console.log('[SMART-DELIVERY] Starting smart selection...');
    console.log('[SMART-DELIVERY] Address:', address);
    console.log('[SMART-DELIVERY] ExtraAddress:', extraAddress);

    const select = document.getElementById('saleDeliveryPartner');
    if (!select || select.options.length <= 1) {
        console.log('[SMART-DELIVERY] Dropdown not ready, skipping');
        return;
    }

    // Extract district info from address or ExtraAddress
    let districtInfo = extractDistrictFromAddress(address, extraAddress);
    console.log('[SMART-DELIVERY] Extracted district info:', districtInfo);

    if (!districtInfo) {
        console.log('[SMART-DELIVERY] Could not extract district, selecting SHIP Tá»ˆNH as fallback');
        selectCarrierByName(select, 'SHIP Tá»ˆNH', true);
        return;
    }

    // Try to find matching carrier based on district
    const matchedCarrier = findMatchingCarrier(select, districtInfo);

    if (matchedCarrier) {
        console.log('[SMART-DELIVERY] âœ… Found matching carrier:', matchedCarrier.name);
        select.value = matchedCarrier.id;
        select.dispatchEvent(new Event('change'));

        // Show success notification (subtle)
        if (window.notificationManager) {
            window.notificationManager.success(`Tá»± Ä‘á»™ng chá»n: ${matchedCarrier.name}`, 2000);
        }
    } else {
        console.log('[SMART-DELIVERY] âš ï¸ No matching carrier found, selecting SHIP Tá»ˆNH');
        selectCarrierByName(select, 'SHIP Tá»ˆNH', true);
    }
}

/**
 * Extract district information from address string or ExtraAddress object
 * @returns {object|null} - { districtName, districtNumber, wardName, cityName }
 */
function extractDistrictFromAddress(address, extraAddress) {
    let result = {
        districtName: null,
        districtNumber: null,
        wardName: null,
        cityName: null,
        originalText: address
    };

    // Try to get structured data from ExtraAddress first
    if (extraAddress) {
        if (extraAddress.District?.name) {
            result.districtName = extraAddress.District.name;
            // Extract number from district name like "Quáº­n 1", "Quáº­n 12", etc.
            const numMatch = extraAddress.District.name.match(/(\d+)/);
            if (numMatch) {
                result.districtNumber = numMatch[1];
            }
        }
        if (extraAddress.Ward?.name) {
            result.wardName = extraAddress.Ward.name;
        }
        if (extraAddress.City?.name) {
            result.cityName = extraAddress.City.name;
        }
    }

    // Also parse from address string as fallback/supplement
    if (address) {
        const normalizedAddress = address.toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, ''); // Remove Vietnamese diacritics for matching

        // Try to match district patterns
        // "Quáº­n 1", "Q1", "Q.1", "Quan 1", "District 1"
        const districtPatterns = [
            /quan\s*(\d+)/i,
            /q\.?\s*(\d+)/i,
            /district\s*(\d+)/i
        ];

        for (const pattern of districtPatterns) {
            const match = normalizedAddress.match(pattern);
            if (match) {
                result.districtNumber = match[1];
                break;
            }
        }

        // Match named districts (without diacritics)
        const namedDistricts = [
            { normalized: 'binh chanh', original: 'BÃ¬nh ChÃ¡nh' },
            { normalized: 'binh tan', original: 'BÃ¬nh TÃ¢n' },
            { normalized: 'binh thanh', original: 'BÃ¬nh Tháº¡nh' },
            { normalized: 'go vap', original: 'GÃ² Váº¥p' },
            { normalized: 'phu nhuan', original: 'PhÃº Nhuáº­n' },
            { normalized: 'tan binh', original: 'TÃ¢n BÃ¬nh' },
            { normalized: 'tan phu', original: 'TÃ¢n PhÃº' },
            { normalized: 'thu duc', original: 'Thá»§ Äá»©c' },
            { normalized: 'nha be', original: 'NhÃ  BÃ¨' },
            { normalized: 'hoc mon', original: 'HÃ³c MÃ´n' },
            { normalized: 'cu chi', original: 'Cá»§ Chi' },
            { normalized: 'can gio', original: 'Cáº§n Giá»' }
        ];

        for (const district of namedDistricts) {
            if (normalizedAddress.includes(district.normalized)) {
                result.districtName = district.original;
                break;
            }
        }
    }

    // Return null if we couldn't extract any district info
    if (!result.districtName && !result.districtNumber) {
        return null;
    }

    return result;
}

/**
 * Find matching carrier based on district information
 * Parses carrier names to find coverage areas in parentheses
 * @param {HTMLSelectElement} select - The delivery partner dropdown
 * @param {object} districtInfo - Extracted district information
 * @returns {object|null} - { id, name } of matching carrier
 */
function findMatchingCarrier(select, districtInfo) {
    console.log('[SMART-DELIVERY] Searching for carrier matching:', districtInfo);

    let bestMatch = null;
    let bestMatchScore = 0;

    for (let i = 0; i < select.options.length; i++) {
        const option = select.options[i];
        if (!option.value) continue; // Skip placeholder

        const carrierName = option.dataset.name || option.text;

        // Skip non-matching carriers (Gá»˜P, BÃN HÃ€NG SHOP)
        if (carrierName.includes('Gá»˜P') || carrierName === 'BÃN HÃ€NG SHOP') {
            continue;
        }

        // Extract coverage area from carrier name (text in parentheses)
        const coverageMatch = carrierName.match(/\(([^)]+)\)/);
        if (!coverageMatch) continue;

        const coverageArea = coverageMatch[1].toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, '');

        let matchScore = 0;

        // Check if district number matches
        if (districtInfo.districtNumber) {
            // Look for the number in coverage area
            // Need to be careful: "1" shouldn't match "10" or "11"
            const districtNum = districtInfo.districtNumber;

            // Pattern to match standalone numbers or numbers at word boundaries
            // For coverage like "1 3 4 5 6 7 8 10 11" or "Q2-12-BÃ¬nh TÃ¢n"
            const numPatterns = [
                new RegExp(`\\b${districtNum}\\b`),           // Word boundary
                new RegExp(`^${districtNum}\\s`),             // Start of string
                new RegExp(`\\s${districtNum}\\s`),           // Space surrounded
                new RegExp(`\\s${districtNum}$`),             // End of string
                new RegExp(`-${districtNum}-`),               // Dash surrounded
                new RegExp(`^${districtNum}-`),               // Start with dash
                new RegExp(`-${districtNum}$`),               // End with dash
                new RegExp(`q${districtNum}\\b`, 'i'),        // Q prefix (Q9, Q2)
            ];

            for (const pattern of numPatterns) {
                if (pattern.test(coverageArea) || pattern.test(carrierName)) {
                    matchScore = 10;
                    console.log(`[SMART-DELIVERY] District number ${districtNum} matched in: ${carrierName}`);
                    break;
                }
            }
        }

        // Check if district name matches
        if (districtInfo.districtName && matchScore === 0) {
            const normalizedDistrictName = districtInfo.districtName.toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '');

            if (coverageArea.includes(normalizedDistrictName)) {
                matchScore = 8;
                console.log(`[SMART-DELIVERY] District name "${districtInfo.districtName}" matched in: ${carrierName}`);
            }
        }

        // Update best match
        if (matchScore > bestMatchScore) {
            bestMatchScore = matchScore;
            bestMatch = {
                id: option.value,
                name: carrierName
            };
        }
    }

    return bestMatch;
}

/**
 * Select carrier by name pattern (fallback selection)
 * @param {HTMLSelectElement} select - The delivery partner dropdown
 * @param {string} namePattern - Name to search for
 * @param {boolean} showWarning - Whether to show a warning notification
 */
function selectCarrierByName(select, namePattern, showWarning = false) {
    for (let i = 0; i < select.options.length; i++) {
        const option = select.options[i];
        const carrierName = option.dataset.name || option.text;

        if (carrierName.includes(namePattern)) {
            select.value = option.value;
            select.dispatchEvent(new Event('change'));

            if (showWarning && window.notificationManager) {
                window.notificationManager.info(
                    `KhÃ´ng xÃ¡c Ä‘á»‹nh Ä‘Æ°á»£c quáº­n/huyá»‡n, Ä‘Ã£ chá»n: ${carrierName}`,
                    3000
                );
            }
            return true;
        }
    }
    return false;
}

// Export smart delivery functions for debugging
window.smartSelectDeliveryPartner = smartSelectDeliveryPartner;
window.extractDistrictFromAddress = extractDistrictFromAddress;
window.findMatchingCarrier = findMatchingCarrier;

/**
 * Format currency in Vietnamese style
 */
function formatCurrencyVND(amount) {
    if (!amount && amount !== 0) return '0Ä‘';
    return new Intl.NumberFormat('vi-VN', {
        style: 'currency',
        currency: 'VND'
    }).format(amount);
}

/**
 * Open Sale Button Modal and fetch order details from API
 */
async function openSaleButtonModal() {
    console.log('[SALE-MODAL] Opening Sale Button Modal...');

    // Get the selected order ID (should be exactly 1)
    if (selectedOrderIds.size !== 1) {
        if (window.notificationManager) {
            window.notificationManager.warning('Vui lÃ²ng chá»n Ä‘Ãºng 1 Ä‘Æ¡n hÃ ng');
        }
        return;
    }

    const orderId = Array.from(selectedOrderIds)[0];
    const order = allData.find(o => o.Id === orderId);

    if (!order) {
        if (window.notificationManager) {
            window.notificationManager.error('KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng');
        }
        return;
    }

    currentSaleOrderData = order;
    console.log('[SALE-MODAL] Selected order:', order);

    // Show modal with loading state
    const modal = document.getElementById('saleButtonModal');
    modal.style.display = 'flex';

    // Check if user is admin and enable/disable CÃ´ng ná»£ field accordingly
    const prepaidAmountField = document.getElementById('salePrepaidAmount');
    const confirmDebtBtn = document.getElementById('confirmDebtBtn');

    // Check admin access via detailedPermissions
    const authState = window.authManager ? window.authManager.getAuthState() : null;
    let isAdmin = authState?.detailedPermissions?.['baocaosaleonline']?.['viewRevenue'] === true ||
        authState?.roleTemplate === 'admin';
    // Fallback: Check username for admin (legacy support)
    if (!isAdmin) {
        const currentUserType = window.authManager?.getCurrentUser?.()?.name || localStorage.getItem('current_user_name') || '';
        const lowerName = currentUserType.toLowerCase();
        if (lowerName.includes('admin') || lowerName.includes('quáº£n trá»‹') || lowerName.includes('administrator')) {
            isAdmin = true;
        }
    }

    if (prepaidAmountField) {
        if (isAdmin) {
            prepaidAmountField.disabled = false;
            prepaidAmountField.style.background = '#ffffff';
            if (confirmDebtBtn) confirmDebtBtn.style.display = 'inline-flex';
            console.log('[SALE-MODAL] Admin detected - CÃ´ng ná»£ field enabled with confirm button');
        } else {
            prepaidAmountField.disabled = true;
            prepaidAmountField.style.background = '#f3f4f6';
            if (confirmDebtBtn) confirmDebtBtn.style.display = 'none';
        }

        // Add event listener for prepaid amount changes (for admin)
        prepaidAmountField.oninput = function () {
            updateSaleRemainingBalance();
        };
    }

    // Add event listener for COD input changes
    const codInput = document.getElementById('saleCOD');
    if (codInput) {
        codInput.oninput = function () {
            updateSaleRemainingBalance();
        };
    }

    // Add event listener for shipping fee changes to update COD realtime
    const shippingFeeInput = document.getElementById('saleShippingFee');
    if (shippingFeeInput) {
        shippingFeeInput.oninput = function () {
            // Recalculate COD when shipping fee changes
            const finalTotal = parseFloat(document.getElementById('saleFinalTotal')?.textContent?.replace(/[^\d]/g, '')) || 0;
            const shippingFee = parseFloat(this.value) || 0;
            const codInput = document.getElementById('saleCOD');
            if (codInput) {
                codInput.value = finalTotal + shippingFee;
                updateSaleRemainingBalance();
            }
        };
    }

    // Add event listener for discount changes to update totals realtime
    const discountInput = document.getElementById('saleDiscount');
    if (discountInput) {
        discountInput.oninput = function () {
            // Recalculate totals when discount changes
            const totalAmount = parseFloat(document.getElementById('saleTotalAmount')?.textContent?.replace(/[^\d]/g, '')) || 0;
            const totalQuantity = parseInt(document.getElementById('saleTotalQuantity')?.textContent) || 0;
            updateSaleTotals(totalQuantity, totalAmount);
        };
    }

    // Populate basic order data first (from local data)
    populateSaleModalWithOrder(order);

    // Fetch realtime debt for the phone number (same as debt column in table)
    const phone = order.Telephone || order.PartnerPhone;
    if (phone) {
        fetchDebtForSaleModal(phone);
    }

    // Populate delivery carrier dropdown (async, with localStorage cache)
    // Must await to ensure dropdown is ready for smart selection
    await populateDeliveryCarrierDropdown();

    // Fetch detailed order data from API (includes partner, orderLines)
    const orderDetails = await fetchOrderDetailsForSale(orderId);

    if (orderDetails) {
        // Store partner data
        currentSalePartnerData = orderDetails.partner;

        // Populate partner data
        if (orderDetails.partner) {
            populatePartnerData(orderDetails.partner);

            // Smart select delivery partner based on customer address
            const receiverAddress = document.getElementById('saleReceiverAddress')?.value || '';
            const extraAddress = orderDetails.partner.ExtraAddress || null;
            smartSelectDeliveryPartner(receiverAddress, extraAddress);
        }

        // Populate order lines if available
        if (orderDetails.orderLines && orderDetails.orderLines.length > 0) {
            // ğŸ”¥ Map SaleOnlineDetailId from orderLine.Id for FastSaleOrder compatibility
            const mappedOrderLines = orderDetails.orderLines.map(line => ({
                ...line,
                SaleOnlineDetailId: line.Id || line.SaleOnlineDetailId || null
            }));
            populateSaleOrderLinesFromAPI(mappedOrderLines);
        }
    } else {
        // Fallback: try smart selection with basic order address if no partner details
        const receiverAddress = order.PartnerAddress || order.Address || '';
        if (receiverAddress) {
            smartSelectDeliveryPartner(receiverAddress, null);
        }
    }

    // Initialize product search for this modal
    initSaleProductSearch();
}

/**
 * Close Sale Button Modal
 * @param {boolean} clearSelection - If true, clear checkbox selection and selectedOrderIds
 */
function closeSaleButtonModal(clearSelection = false) {
    const modal = document.getElementById('saleButtonModal');
    modal.style.display = 'none';
    currentSaleOrderData = null;
    currentSalePartnerData = null;

    // Clear selection if requested (after successful order creation)
    if (clearSelection) {
        // Clear selectedOrderIds
        selectedOrderIds.clear();

        // Uncheck all checkboxes in table
        const checkboxes = document.querySelectorAll('#tableBody input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = false);

        // Uncheck "Select All" checkbox
        const selectAllCheckbox = document.getElementById('selectAll');
        if (selectAllCheckbox) {
            selectAllCheckbox.checked = false;
        }

        // Update action buttons visibility
        updateActionButtons();
    }
}

/**
 * Confirm debt update - Admin only
 * Updates the debt value in the database (customers.debt field on SQL Render)
 */
async function confirmDebtUpdate() {
    const prepaidAmountField = document.getElementById('salePrepaidAmount');
    const confirmBtn = document.getElementById('confirmDebtBtn');

    if (!prepaidAmountField || !currentSaleOrderData) {
        if (window.notificationManager) {
            window.notificationManager.error('KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘á»ƒ cáº­p nháº­t');
        }
        return;
    }

    const phone = currentSaleOrderData.Telephone || currentSaleOrderData.PartnerPhone;
    if (!phone) {
        if (window.notificationManager) {
            window.notificationManager.error('KhÃ´ng tÃ¬m tháº¥y sá»‘ Ä‘iá»‡n thoáº¡i khÃ¡ch hÃ ng');
        }
        return;
    }

    const newDebt = parseFloat(prepaidAmountField.value) || 0;

    // Show loading state
    const originalText = confirmBtn?.textContent;
    if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.textContent = '...';
    }

    try {
        console.log('[DEBT-UPDATE] Updating debt for phone:', phone, 'to:', newDebt);

        const response = await fetch(`${QR_API_URL}/api/sepay/update-debt`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                phone: phone,
                new_debt: newDebt,
                reason: 'Admin manual adjustment from Sale Modal'
            })
        });

        const result = await response.json();

        if (result.success) {
            console.log('[DEBT-UPDATE] âœ… Success:', result);
            if (window.notificationManager) {
                window.notificationManager.success(`ÄÃ£ cáº­p nháº­t CÃ´ng ná»£: ${newDebt.toLocaleString('vi-VN')}Ä‘`);
            }
            // Update the field background to indicate saved
            prepaidAmountField.style.background = '#d1fae5'; // Light green
            setTimeout(() => {
                prepaidAmountField.style.background = '#ffffff';
            }, 2000);

            // ğŸ”„ REALTIME UPDATE: Invalidate cache and update table cells immediately
            const normalizedPhone = normalizePhoneForQR(phone);
            if (normalizedPhone) {
                // Invalidate debt cache for this phone
                const cache = getDebtCache();
                delete cache[normalizedPhone];
                saveDebtCache(cache);
                console.log('[DEBT-UPDATE] Cache invalidated for phone:', normalizedPhone);

                // Update debt cells in the orders table immediately
                updateDebtCellsInTable(normalizedPhone, newDebt);
                console.log('[DEBT-UPDATE] Table cells updated for phone:', normalizedPhone);

                // Also update "Ná»£ cÅ©" display in modal
                const oldDebtField = document.getElementById('saleOldDebt');
                if (oldDebtField) {
                    oldDebtField.textContent = newDebt > 0 ? `${newDebt.toLocaleString('vi-VN')} Ä‘` : '0';
                }
            }
        } else {
            throw new Error(result.error || 'Failed to update debt');
        }

    } catch (error) {
        console.error('[DEBT-UPDATE] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error('Lá»—i cáº­p nháº­t CÃ´ng ná»£: ' + error.message);
        }
    } finally {
        // Restore button state
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.textContent = originalText || 'XÃ¡c nháº­n';
        }
    }
}

/**
 * Switch tabs in Sale Modal
 */
function switchSaleTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.sale-tab').forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        }
    });

    // Update tab contents
    document.querySelectorAll('.sale-tab-content').forEach(content => {
        content.classList.remove('active');
        content.style.display = 'none';
    });

    const activeContent = document.getElementById(`saleTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
    if (activeContent) {
        activeContent.classList.add('active');
        activeContent.style.display = 'block';
    }
}

/**
 * Populate modal with order data
 */
function populateSaleModalWithOrder(order) {
    console.log('[SALE-MODAL] Populating order data:', order);

    // Basic info - Update header (moved from Tab "ThÃ´ng tin")
    const customerName = order.PartnerName || order.Name || '';
    document.getElementById('saleCustomerName').textContent = customerName;
    document.getElementById('saleCustomerNameHeader').textContent = customerName;

    // Customer status (will be updated by API)
    document.getElementById('saleCustomerStatus').textContent = '';
    document.getElementById('saleCustomerStatusHeader').textContent = '';
    document.getElementById('saleLoyaltyPoints').textContent = '0';
    document.getElementById('saleLoyaltyPointsHeader').textContent = '0';
    document.getElementById('saleUsedPointsHeader').textContent = '0';
    document.getElementById('saleRemainingPointsHeader').textContent = '0';
    document.getElementById('saleOldDebt').textContent = '0';

    // Tab "ThÃ´ng tin ngÆ°á»i nháº­n"
    document.getElementById('saleReceiverName').value = order.PartnerName || order.Name || '';
    document.getElementById('saleReceiverPhone').value = order.PartnerPhone || order.Telephone || '';
    document.getElementById('saleReceiverAddress').value = order.PartnerAddress || order.Address || '';
    document.getElementById('saleReceiverNote').value = '';

    // Tab "ThÃ´ng tin giao hÃ ng"
    // ğŸ”¥ FIX: Use proper check to allow 0 value
    const shippingFeeValue = document.getElementById('saleShippingFee')?.value;
    const shippingFee = (shippingFeeValue !== '' && shippingFeeValue !== null && shippingFeeValue !== undefined)
        ? parseInt(shippingFeeValue)
        : 35000;
    const totalAmount = order.TotalAmount || 0;

    // COD = Tá»•ng tiá»n hÃ ng + phÃ­ ship (náº¿u khÃ¡ch tráº£ ship)
    document.getElementById('saleCOD').value = totalAmount + shippingFee;

    // Ghi chÃº giao hÃ ng máº·c Ä‘á»‹nh
    const defaultDeliveryNote = 'KHÃ”NG ÄÆ¯á»¢C Tá»° Ã HOÃ€N ÄÆ N CÃ“ GÃŒ LIÃŠN Há»† HOTLINE Cá»¦A SHOP 090 8888 674 Äá»‚ ÄÆ¯á»¢C Há»– TRá»¢';
    document.getElementById('saleDeliveryNote').value = order.Comment || defaultDeliveryNote;

    // GiÃ¡ trá»‹ hÃ ng hÃ³a
    document.getElementById('saleGoodsValue').value = totalAmount;

    // Set delivery date
    const now = new Date();
    document.getElementById('saleDeliveryDate').value = formatDateTimeLocal(now);
    document.getElementById('saleInvoiceDate').textContent = formatDateTimeDisplay(now);

    // Populate order items (products)
    populateSaleOrderItems(order);
}

/**
 * Fetch order details (partner, orderLines) from TPOS API
 */
async function fetchOrderDetailsForSale(orderUuid) {
    console.log('[SALE-MODAL] Fetching order details for UUID:', orderUuid);

    try {
        // Use tokenManager to get valid token (auto-refreshes if expired)
        let token;
        if (window.tokenManager) {
            token = await window.tokenManager.getToken();
        } else {
            // Fallback: try to get from bearer_token_data storage
            const storedData = localStorage.getItem('bearer_token_data');
            if (storedData) {
                const data = JSON.parse(storedData);
                token = data.access_token;
            }
        }

        if (!token) {
            console.warn('[SALE-MODAL] No auth token found');
            return null;
        }

        const response = await fetch('https://tomato.tpos.vn/odata/SaleOnline_Order/ODataService.GetDetails?$expand=orderLines($expand=Product,ProductUOM),partner,warehouse', {
            method: 'POST',
            headers: {
                'accept': 'application/json, text/plain, */*',
                'authorization': `Bearer ${token}`,
                'content-type': 'application/json;charset=UTF-8',
                'tposappversion': window.TPOS_CONFIG?.tposAppVersion || '5.11.16.1',
                'x-tpos-lang': 'vi'
            },
            body: JSON.stringify({ ids: [orderUuid] })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('[SALE-MODAL] Order details response:', data);

        return data;

    } catch (error) {
        console.error('[SALE-MODAL] Error fetching order details:', error);
        if (window.notificationManager) {
            window.notificationManager.warning('KhÃ´ng thá»ƒ táº£i thÃ´ng tin Ä‘Æ¡n hÃ ng');
        }
        return null;
    }
}

/**
 * Populate partner data into modal
 */
function populatePartnerData(partner) {
    if (!partner) return;

    // Customer info - Update both hidden elements and header
    const customerName = partner.DisplayName || partner.Name || '';
    const customerStatus = partner.StatusText || 'BÃ¬nh thÆ°á»ng';
    const loyaltyPoints = partner.LoyaltyPoints || 0;

    // Hidden elements (for JS compatibility)
    document.getElementById('saleCustomerName').textContent = customerName;
    document.getElementById('saleCustomerStatus').textContent = customerStatus;
    document.getElementById('saleLoyaltyPoints').textContent = loyaltyPoints;

    // Header elements (visible)
    document.getElementById('saleCustomerNameHeader').textContent = customerName;
    document.getElementById('saleCustomerStatusHeader').textContent = customerStatus;
    document.getElementById('saleLoyaltyPointsHeader').textContent = loyaltyPoints;
    document.getElementById('saleUsedPointsHeader').textContent = '0';
    document.getElementById('saleRemainingPointsHeader').textContent = loyaltyPoints;

    // NOTE: Prepaid amount (salePrepaidAmount) and Old Debt (saleOldDebt) are now
    // populated by fetchDebtForSaleModal() using REALTIME debt from balance-history API
    // instead of TPOS partner.Debit/Credit data. This ensures consistency with
    // the "CÃ´ng Ná»£" column in the orders table.

    // Receiver info (update if not already set)
    const receiverName = document.getElementById('saleReceiverName');
    const receiverPhone = document.getElementById('saleReceiverPhone');
    const receiverAddress = document.getElementById('saleReceiverAddress');

    if (!receiverName.value) receiverName.value = partner.DisplayName || partner.Name || '';
    if (!receiverPhone.value) receiverPhone.value = partner.Phone || partner.Mobile || '';

    // Build address from ExtraAddress or FullAddress
    if (!receiverAddress.value) {
        let address = partner.FullAddress || partner.Street || '';
        if (!address && partner.ExtraAddress) {
            const ea = partner.ExtraAddress;
            const parts = [ea.Street, ea.Ward?.name, ea.District?.name, ea.City?.name].filter(p => p);
            address = parts.join(', ');
        }
        receiverAddress.value = address;
    }
}

/**
 * Fetch realtime debt for sale modal (same source as debt column in table)
 * @param {string} phone - Phone number
 */
async function fetchDebtForSaleModal(phone) {
    const normalizedPhone = normalizePhoneForQR(phone);
    if (!normalizedPhone) return;

    const prepaidAmountField = document.getElementById('salePrepaidAmount');
    const oldDebtField = document.getElementById('saleOldDebt');

    // Show loading state
    if (prepaidAmountField) {
        prepaidAmountField.value = '...';
    }

    try {
        // Use the same API as the debt column in table
        const response = await fetch(`${QR_API_URL}/api/sepay/debt-summary?phone=${encodeURIComponent(normalizedPhone)}`);
        const result = await response.json();

        if (result.success && result.data) {
            const totalDebt = result.data.total_debt || 0;
            console.log('[SALE-MODAL] Realtime debt for phone:', normalizedPhone, '=', totalDebt);

            // Update prepaid amount field
            if (prepaidAmountField) {
                prepaidAmountField.value = totalDebt > 0 ? totalDebt : 0;
            }

            // Also update the "Ná»£ cÅ©" display to show realtime debt
            if (oldDebtField) {
                oldDebtField.textContent = formatCurrencyVND(totalDebt);
            }

            // Cache it for later use
            saveDebtToCache(normalizedPhone, totalDebt);

            // Also update debt column in orders table to keep them in sync
            updateDebtCellsInTable(normalizedPhone, totalDebt);

            // Update remaining balance after prepaid amount changes
            updateSaleRemainingBalance();
        }
    } catch (error) {
        console.error('[SALE-MODAL] Error fetching realtime debt:', error);
        // Fallback to 0 on error
        if (prepaidAmountField) {
            prepaidAmountField.value = 0;
        }
        // Update remaining balance even on error
        updateSaleRemainingBalance();
    }
}

/**
 * Populate order items (products) into the modal
 */
function populateSaleOrderItems(order) {
    const container = document.getElementById('saleOrderItems');

    if (!order.Details || order.Details.length === 0) {
        container.innerHTML = `
            <tr>
                <td colspan="6" style="text-align: center; padding: 40px; color: #9ca3af;">
                    <i class="fas fa-box-open"></i> ChÆ°a cÃ³ sáº£n pháº©m
                </td>
            </tr>
        `;
        updateSaleTotals(0, 0);
        return;
    }

    let totalQuantity = 0;
    let totalAmount = 0;

    const itemsHTML = order.Details.map((item, index) => {
        const qty = item.Quantity || item.ProductUOMQty || 1;
        const price = item.PriceUnit || item.Price || 0;
        const total = qty * price;

        totalQuantity += qty;
        totalAmount += total;

        return `
            <tr>
                <td>${index + 1}</td>
                <td>
                    <div class="sale-product-name">${item.ProductNameGet || item.ProductName || ''}</div>
                    <div style="font-size: 11px; color: #6b7280;">${item.Note || 'Ghi chÃº'}</div>
                </td>
                <td>
                    <input type="number" class="sale-input" value="${qty}" min="1"
                        onchange="updateSaleItemQuantity(${index}, this.value)"
                        style="width: 60px; text-align: center;">
                </td>
                <td style="text-align: right;">${formatNumber(price)}</td>
                <td style="text-align: right;">${formatNumber(total)}</td>
                <td style="text-align: center;">
                    <button onclick="removeSaleItem(${index})" style="background: none; border: none; color: #ef4444; cursor: pointer;">
                        <i class="fas fa-trash"></i>
                    </button>
                </td>
            </tr>
        `;
    }).join('');

    container.innerHTML = itemsHTML;
    updateSaleTotals(totalQuantity, totalAmount);
}

/**
 * Populate order lines from API response (orderLines with Product, ProductUOM)
 */
function populateSaleOrderLinesFromAPI(orderLines) {
    const container = document.getElementById('saleOrderItems');

    if (!orderLines || orderLines.length === 0) {
        container.innerHTML = `
            <tr>
                <td colspan="6" style="text-align: center; padding: 40px; color: #9ca3af;">
                    <i class="fas fa-box-open"></i> ChÆ°a cÃ³ sáº£n pháº©m
                </td>
            </tr>
        `;
        updateSaleTotals(0, 0);
        return;
    }

    // Store order lines for editing
    currentSaleOrderData.orderLines = orderLines;

    let totalQuantity = 0;
    let totalAmount = 0;

    const itemsHTML = orderLines.map((item, index) => {
        const qty = item.ProductUOMQty || item.Quantity || 1;
        const price = item.PriceUnit || item.Price || 0;
        const total = qty * price;

        // Get product info from nested Product object or direct field
        const productName = item.Product?.NameGet || item.ProductName || '';
        const productNote = item.Note || 'Ghi chÃº';
        const productUOM = item.ProductUOMName || item.ProductUOM?.Name || 'CÃ¡i';

        // Get product image (prefer thumbnail 128x128, fallback to ImageUrl)
        const productImage = item.Product?.Thumbnails?.[1] || item.Product?.ImageUrl || '';
        const imageHTML = productImage
            ? `<img src="${productImage}" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; border: 1px solid #e5e7eb;">`
            : `<div style="width: 40px; height: 40px; background: #f3f4f6; border-radius: 4px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-image" style="color: #9ca3af;"></i></div>`;

        totalQuantity += qty;
        totalAmount += total;

        return `
            <tr>
                <td>${index + 1}</td>
                <td>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        ${imageHTML}
                        <div>
                            <div class="sale-product-name">${productName}</div>
                            <div style="font-size: 11px; color: #6b7280;">${productNote}</div>
                        </div>
                    </div>
                </td>
                <td>
                    <input type="number" class="sale-input" value="${qty}" min="1"
                        onchange="updateSaleItemQuantityFromAPI(${index}, this.value)"
                        style="width: 60px; text-align: center;">
                </td>
                <td style="text-align: right;">${formatNumber(price)}</td>
                <td style="text-align: right;">${formatNumber(total)}</td>
                <td style="text-align: center;">
                    <button onclick="removeSaleItemFromAPI(${index})" style="background: none; border: none; color: #ef4444; cursor: pointer;">
                        <i class="fas fa-trash"></i>
                    </button>
                </td>
            </tr>
        `;
    }).join('');

    container.innerHTML = itemsHTML;
    updateSaleTotals(totalQuantity, totalAmount);
}

/**
 * Update item quantity from API order lines
 */
async function updateSaleItemQuantityFromAPI(index, value) {
    if (!currentSaleOrderData || !currentSaleOrderData.orderLines) return;

    const oldQty = currentSaleOrderData.orderLines[index].ProductUOMQty || currentSaleOrderData.orderLines[index].Quantity || 1;
    const newQty = parseInt(value) || 1;

    // Update local data
    currentSaleOrderData.orderLines[index].ProductUOMQty = newQty;
    currentSaleOrderData.orderLines[index].Quantity = newQty;

    // Recalculate totals
    let totalQuantity = 0;
    let totalAmount = 0;

    currentSaleOrderData.orderLines.forEach(item => {
        const itemQty = item.ProductUOMQty || item.Quantity || 1;
        const price = item.PriceUnit || item.Price || 0;
        totalQuantity += itemQty;
        totalAmount += itemQty * price;
    });

    updateSaleTotals(totalQuantity, totalAmount);

    // ğŸ”¥ UPDATE ORDER VIA API
    try {
        console.log(`[SALE-UPDATE-QTY] Updating quantity ${oldQty} â†’ ${newQty}, calling API...`);
        await updateSaleOrderWithAPI();
        console.log('[SALE-UPDATE-QTY] âœ… Order updated successfully via API');
    } catch (apiError) {
        console.error('[SALE-UPDATE-QTY] âš ï¸ API update failed:', apiError);
        // Rollback on error
        currentSaleOrderData.orderLines[index].ProductUOMQty = oldQty;
        currentSaleOrderData.orderLines[index].Quantity = oldQty;
        populateSaleOrderLinesFromAPI(currentSaleOrderData.orderLines);

        if (window.notificationManager) {
            window.notificationManager.error('KhÃ´ng thá»ƒ cáº­p nháº­t sá»‘ lÆ°á»£ng. Vui lÃ²ng thá»­ láº¡i.');
        }
    }
}

/**
 * Remove item from API order lines
 */
async function removeSaleItemFromAPI(index) {
    if (!currentSaleOrderData || !currentSaleOrderData.orderLines) return;

    // Get product info for confirmation
    const productName = currentSaleOrderData.orderLines[index].Product?.NameGet ||
        currentSaleOrderData.orderLines[index].ProductName ||
        'sáº£n pháº©m nÃ y';

    // Confirm before removing
    const confirmed = await window.notificationManager.confirm(
        `Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a ${productName}?`,
        'XÃ³a sáº£n pháº©m'
    );

    if (!confirmed) return;

    // Backup for rollback
    const removedItem = currentSaleOrderData.orderLines[index];
    const removedIndex = index;

    // Remove from local data
    currentSaleOrderData.orderLines.splice(index, 1);
    populateSaleOrderLinesFromAPI(currentSaleOrderData.orderLines);

    // ğŸ”¥ UPDATE ORDER VIA API
    try {
        console.log(`[SALE-REMOVE-PRODUCT] Removing product at index ${index}, calling API...`);
        await updateSaleOrderWithAPI();
        console.log('[SALE-REMOVE-PRODUCT] âœ… Order updated successfully via API');

        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ xÃ³a ${productName}`);
        }
    } catch (apiError) {
        console.error('[SALE-REMOVE-PRODUCT] âš ï¸ API update failed:', apiError);
        // Rollback on error
        currentSaleOrderData.orderLines.splice(removedIndex, 0, removedItem);
        populateSaleOrderLinesFromAPI(currentSaleOrderData.orderLines);

        if (window.notificationManager) {
            window.notificationManager.error('KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m. Vui lÃ²ng thá»­ láº¡i.');
        }
    }
}

/**
 * Update totals in the modal
 */
function updateSaleTotals(quantity, amount) {
    document.getElementById('saleTotalQuantity').textContent = quantity;
    document.getElementById('saleTotalAmount').textContent = formatNumber(amount);

    const discount = parseInt(document.getElementById('saleDiscount').value) || 0;
    const finalTotal = amount - discount;
    document.getElementById('saleFinalTotal').textContent = formatNumber(finalTotal);

    // Update COD = Tá»•ng tiá»n hÃ ng + PhÃ­ ship
    // ğŸ”¥ FIX: Use proper check to allow 0 value (0 is valid, empty is not)
    const shippingFeeValue = document.getElementById('saleShippingFee')?.value;
    const shippingFee = (shippingFeeValue !== '' && shippingFeeValue !== null && shippingFeeValue !== undefined)
        ? parseInt(shippingFeeValue)
        : 0;
    document.getElementById('saleCOD').value = finalTotal + shippingFee;

    // Update GiÃ¡ trá»‹ hÃ ng hÃ³a
    document.getElementById('saleGoodsValue').value = finalTotal;

    // Update remaining balance after COD changes
    updateSaleRemainingBalance();
}

/**
 * Update item quantity
 */
function updateSaleItemQuantity(index, value) {
    if (!currentSaleOrderData || !currentSaleOrderData.Details) return;

    const qty = parseInt(value) || 1;
    currentSaleOrderData.Details[index].Quantity = qty;

    // Recalculate totals
    let totalQuantity = 0;
    let totalAmount = 0;

    currentSaleOrderData.Details.forEach(item => {
        const itemQty = item.Quantity || item.ProductUOMQty || 1;
        const price = item.PriceUnit || item.Price || 0;
        totalQuantity += itemQty;
        totalAmount += itemQty * price;
    });

    updateSaleTotals(totalQuantity, totalAmount);
}

/**
 * Remove item from order
 */
function removeSaleItem(index) {
    if (!currentSaleOrderData || !currentSaleOrderData.Details) return;

    currentSaleOrderData.Details.splice(index, 1);
    populateSaleOrderItems(currentSaleOrderData);
}

/**
 * Format date for datetime-local input
 */
function formatDateTimeLocal(date) {
    const pad = (n) => n.toString().padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
}

/**
 * Format date for display
 */
function formatDateTimeDisplay(date) {
    return date.toLocaleString('vi-VN');
}

/**
 * Format number with thousand separator
 */
function formatNumber(num) {
    return (num || 0).toLocaleString('vi-VN');
}

// Close modal when clicking outside
document.addEventListener('click', function (e) {
    const modal = document.getElementById('saleButtonModal');
    if (e.target === modal) {
        closeSaleButtonModal();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') {
        const modal = document.getElementById('saleButtonModal');
        if (modal && modal.style.display === 'flex') {
            closeSaleButtonModal();
        }
    }
});

// Disconnect when page unloads and cleanup held products
window.addEventListener('beforeunload', () => {
    disconnectDebtRealtime();

    // Cleanup held products for current user
    if (typeof window.cleanupHeldProductsSync === 'function') {
        window.cleanupHeldProductsSync();
    }

    // Cleanup held products listener
    if (typeof window.cleanupHeldProductsListener === 'function') {
        window.cleanupHeldProductsListener();
    }
});

// Export realtime functions
window.connectDebtRealtime = connectDebtRealtime;
window.disconnectDebtRealtime = disconnectDebtRealtime;

// #region â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                    SECTION 18: SALE MODAL - PRODUCT SEARCH                  â•‘
// â•‘                            search: #SALE-PROD                               â•‘
// #endregion â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// =====================================================
// SALE MODAL - PRODUCT SEARCH (Similar to Edit Modal #PRODUCT)
// =====================================================
let saleSearchTimeout = null;

/**
 * Initialize product search for Sale Modal
 * Similar to initInlineProductSearch() from Edit Modal (~7300)
 */
function initSaleProductSearch() {
    const searchInput = document.getElementById("saleProductSearch");
    if (!searchInput) return;

    console.log('[SALE-PRODUCT-SEARCH] Initializing product search...');

    searchInput.addEventListener("input", () => {
        const query = searchInput.value.trim();
        if (saleSearchTimeout) clearTimeout(saleSearchTimeout);
        if (query.length < 2) {
            displaySaleProductResults([]);
            return;
        }
        saleSearchTimeout = setTimeout(() => performSaleProductSearch(query), 500);
    });

    // Add F2 keyboard shortcut to focus search
    document.addEventListener('keydown', (e) => {
        const modal = document.getElementById('saleButtonModal');
        if (modal && modal.style.display === 'flex' && e.key === 'F2') {
            e.preventDefault();
            searchInput.focus();
        }
    });
}

/**
 * Perform product search
 * Similar to performInlineSearch() from Edit Modal (~7300)
 */
async function performSaleProductSearch(query) {
    const searchInput = document.getElementById("saleProductSearch");
    const productList = document.getElementById("saleProductList");

    searchInput.classList.add("searching");
    productList.innerHTML = `
        <tr>
            <td colspan="4" style="text-align: center; padding: 20px; color: #6b7280;">
                <i class="fas fa-spinner fa-spin"></i> Äang tÃ¬m kiáº¿m...
            </td>
        </tr>
    `;

    try {
        if (!window.productSearchManager.isLoaded) {
            await window.productSearchManager.fetchExcelProducts();
        }
        const results = window.productSearchManager.search(query, 20);
        displaySaleProductResults(results);
    } catch (error) {
        console.error('[SALE-PRODUCT-SEARCH] Error:', error);
        productList.innerHTML = `
            <tr>
                <td colspan="4" style="text-align: center; padding: 20px; color: #ef4444;">
                    <i class="fas fa-exclamation-circle"></i> Lá»—i: ${error.message}
                </td>
            </tr>
        `;
    } finally {
        searchInput.classList.remove("searching");
    }
}

/**
 * Display search results in the product list table
 * Similar to displayInlineResults() from Edit Modal (~7300)
 */
function displaySaleProductResults(results) {
    const productList = document.getElementById("saleProductList");

    if (!results || results.length === 0) {
        productList.innerHTML = `
            <tr>
                <td colspan="4" style="text-align: center; padding: 20px; color: #9ca3af;">
                    <i class="fas fa-search"></i> KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m
                </td>
            </tr>
        `;
        return;
    }

    // Check which products are already in the order
    const productsInOrder = new Map();
    if (currentSaleOrderData && currentSaleOrderData.orderLines) {
        currentSaleOrderData.orderLines.forEach(line => {
            const productId = line.ProductId || line.Product?.Id;
            const qty = line.ProductUOMQty || line.Quantity || 0;
            productsInOrder.set(productId, qty);
        });
    }

    productList.innerHTML = results.map((product) => {
        const isInOrder = productsInOrder.has(product.Id);
        const currentQty = productsInOrder.get(product.Id) || 0;
        const rowClass = isInOrder ? 'style="background-color: #f0fdf4;"' : '';

        return `
            <tr ${rowClass} onclick="addProductToSaleFromSearch(${product.Id})" style="cursor: pointer;">
                <td style="width: 40px; text-align: center;">
                    ${product.ImageUrl ?
                `<img src="${product.ImageUrl}" style="width: 30px; height: 30px; object-fit: cover; border-radius: 4px;">` :
                `<div style="width: 30px; height: 30px; background: #f3f4f6; border-radius: 4px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-image" style="color: #9ca3af; font-size: 12px;"></i></div>`
            }
                </td>
                <td>
                    <div style="font-weight: 500;">${product.Name}</div>
                    <div style="font-size: 11px; color: #6b7280;">MÃ£: ${product.Code}</div>
                    ${isInOrder ? `<div style="font-size: 11px; color: #10b981;"><i class="fas fa-shopping-cart"></i> ÄÃ£ cÃ³ trong Ä‘Æ¡n (SL: ${currentQty})</div>` : ''}
                </td>
                <td style="width: 60px; text-align: center;">${product.UOMName || 'CÃ¡i'}</td>
                <td style="width: 80px; text-align: right; font-weight: 600; color: #3b82f6;">
                    ${(product.Price || 0).toLocaleString('vi-VN')}
                </td>
            </tr>
        `;
    }).join('');
}

/**
 * Add product to sale order from search
 * Similar to addProductToOrderFromInline() from Edit Modal (~2214)
 */
async function addProductToSaleFromSearch(productId) {
    let notificationId = null;

    try {
        // Show loading notification
        if (window.notificationManager) {
            notificationId = window.notificationManager.show(
                "Äang táº£i thÃ´ng tin sáº£n pháº©m...",
                "info",
                0,
                {
                    showOverlay: true,
                    persistent: true,
                    icon: "package",
                }
            );
        }

        console.log('[SALE-ADD-PRODUCT] Fetching product details for ID:', productId);
        const fullProduct = await window.productSearchManager.getFullProductDetails(productId);

        if (!fullProduct) {
            throw new Error("KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin sáº£n pháº©m");
        }

        console.log('[SALE-ADD-PRODUCT] Full product details:', fullProduct);

        // Close loading notification
        if (window.notificationManager && notificationId) {
            window.notificationManager.remove(notificationId);
        }

        // Ensure orderLines array exists
        if (!currentSaleOrderData.orderLines) {
            currentSaleOrderData.orderLines = [];
        }

        // Check if product already exists in order
        const existingIndex = currentSaleOrderData.orderLines.findIndex(
            line => (line.ProductId || line.Product?.Id) === productId
        );

        if (existingIndex > -1) {
            // Product exists - increase quantity
            const existingLine = currentSaleOrderData.orderLines[existingIndex];
            const oldQty = existingLine.ProductUOMQty || existingLine.Quantity || 0;
            const newQty = oldQty + 1;

            existingLine.ProductUOMQty = newQty;
            existingLine.Quantity = newQty;

            console.log(`[SALE-ADD-PRODUCT] Product exists, increased quantity: ${oldQty} â†’ ${newQty}`);

            if (window.notificationManager) {
                window.notificationManager.success(
                    `ÄÃ£ tÄƒng sá»‘ lÆ°á»£ng ${fullProduct.Name} (${oldQty} â†’ ${newQty})`
                );
            }
        } else {
            // Validate sale price
            const salePrice = fullProduct.PriceVariant || fullProduct.ListPrice;
            if (salePrice == null || salePrice < 0) {
                throw new Error(`Sáº£n pháº©m "${fullProduct.Name}" khÃ´ng cÃ³ giÃ¡ bÃ¡n.`);
            }

            // Create new order line
            const newLine = {
                ProductId: fullProduct.Id,
                Product: {
                    Id: fullProduct.Id,
                    Name: fullProduct.Name,
                    DefaultCode: fullProduct.DefaultCode,
                    NameGet: fullProduct.NameGet || `[${fullProduct.DefaultCode}] ${fullProduct.Name}`,
                    ImageUrl: fullProduct.ImageUrl
                },
                ProductUOMId: fullProduct.UOM?.Id || 1,
                ProductUOM: {
                    Id: fullProduct.UOM?.Id || 1,
                    Name: fullProduct.UOM?.Name || 'CÃ¡i'
                },
                ProductUOMQty: 1,
                Quantity: 1,
                PriceUnit: salePrice,
                ProductName: fullProduct.Name,
                ProductNameGet: fullProduct.NameGet || `[${fullProduct.DefaultCode}] ${fullProduct.Name}`,
                ProductUOMName: fullProduct.UOM?.Name || 'CÃ¡i',
                Note: null,
                Discount: 0,
                Weight: fullProduct.Weight || 0
            };

            currentSaleOrderData.orderLines.push(newLine);

            console.log('[SALE-ADD-PRODUCT] Added new product:', newLine);

            if (window.notificationManager) {
                window.notificationManager.success(`ÄÃ£ thÃªm ${fullProduct.Name} vÃ o Ä‘Æ¡n hÃ ng`);
            }
        }

        // Refresh the order items table
        populateSaleOrderLinesFromAPI(currentSaleOrderData.orderLines);

        // Refresh search results to show updated quantity
        const searchInput = document.getElementById("saleProductSearch");
        if (searchInput && searchInput.value.trim().length >= 2) {
            performSaleProductSearch(searchInput.value.trim());
        }

        // ğŸ”¥ UPDATE ORDER VIA API (Similar to Edit Modal flow)
        try {
            console.log('[SALE-ADD-PRODUCT] Calling PUT API to update order...');
            await updateSaleOrderWithAPI();
            console.log('[SALE-ADD-PRODUCT] âœ… Order updated successfully via API');
        } catch (apiError) {
            console.error('[SALE-ADD-PRODUCT] âš ï¸ API update failed:', apiError);
            // Show warning but don't rollback (product is already added locally)
            if (window.notificationManager) {
                window.notificationManager.warning('Sáº£n pháº©m Ä‘Ã£ Ä‘Æ°á»£c thÃªm nhÆ°ng chÆ°a Ä‘á»“ng bá»™ vá»›i server. Vui lÃ²ng thá»­ láº¡i.');
            }
        }

    } catch (error) {
        console.error('[SALE-ADD-PRODUCT] Error:', error);

        if (window.notificationManager && notificationId) {
            window.notificationManager.remove(notificationId);
        }

        if (window.notificationManager) {
            window.notificationManager.error(error.message || 'KhÃ´ng thá»ƒ thÃªm sáº£n pháº©m');
        }
    }
}

/**
 * Recalculate totals for sale modal
 * Similar to recalculateTotals() from Edit Modal (~7273)
 */
function recalculateSaleTotals() {
    if (!currentSaleOrderData || !currentSaleOrderData.orderLines) return;

    let totalQuantity = 0;
    let totalAmount = 0;

    currentSaleOrderData.orderLines.forEach(item => {
        const qty = item.ProductUOMQty || item.Quantity || 1;
        const price = item.PriceUnit || item.Price || 0;
        totalQuantity += qty;
        totalAmount += qty * price;
    });

    updateSaleTotals(totalQuantity, totalAmount);
}

/**
 * Update Sale Order via PUT API
 * Similar to updateOrderWithFullPayload() from Edit Modal (~15687)
 * Fetches FULL order object from API, merges local changes, then PUTs back
 */
async function updateSaleOrderWithAPI() {
    if (!currentSaleOrderData || !currentSaleOrderData.Id) {
        console.error('[SALE-API] No order data to update');
        return null;
    }

    try {
        console.log('[SALE-API] Preparing to update order:', currentSaleOrderData.Id);

        // Get auth headers
        const headers = await window.tokenManager.getAuthHeader();

        // ğŸ”¥ STEP 1: Fetch FULL order object from API first (critical!)
        // This ensures we have all required fields like RowVersion, Partner, User, CRMTeam, etc.
        const getUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${currentSaleOrderData.Id})?$expand=Details,Partner,User,CRMTeam`;
        console.log('[SALE-API] Fetching full order from API...');

        const getResponse = await fetch(getUrl, {
            method: 'GET',
            headers: {
                ...headers,
                Accept: "application/json",
            }
        });

        if (!getResponse.ok) {
            throw new Error(`Failed to fetch order: HTTP ${getResponse.status}`);
        }

        const fullOrder = await getResponse.json();
        console.log('[SALE-API] Got full order from API:', fullOrder);

        // ğŸ”¥ STEP 2: Merge local changes (orderLines) into full order object
        // Clone to avoid mutation
        const payload = JSON.parse(JSON.stringify(fullOrder));

        // Add @odata.context (CRITICAL for PUT request)
        if (!payload["@odata.context"]) {
            payload["@odata.context"] = "http://tomato.tpos.vn/odata/$metadata#SaleOnline_Order(Details(),Partner(),User(),CRMTeam())/$entity";
        }

        // Get CreatedById from order or auth
        const createdById = fullOrder.CreatedById || fullOrder.UserId;

        // Convert local orderLines to Details format (API expects Details, not orderLines)
        if (currentSaleOrderData.orderLines && Array.isArray(currentSaleOrderData.orderLines)) {
            payload.Details = currentSaleOrderData.orderLines.map(line => {
                const cleaned = {
                    ProductId: line.ProductId || line.Product?.Id,
                    Quantity: line.ProductUOMQty || line.Quantity || 1,
                    Price: line.PriceUnit || line.Price || 0,
                    Note: line.Note || null,
                    UOMId: line.ProductUOMId || line.ProductUOM?.Id || 1,
                    Factor: 1,
                    Priority: 0,
                    OrderId: currentSaleOrderData.Id,
                    LiveCampaign_DetailId: null,
                    ProductWeight: line.Weight || 0,
                    ProductName: line.Product?.Name || line.ProductName || '',
                    ProductNameGet: line.Product?.NameGet || line.ProductNameGet || '',
                    ProductCode: line.Product?.DefaultCode || line.ProductCode || '',
                    UOMName: line.ProductUOMName || line.ProductUOM?.Name || 'CÃ¡i',
                    ImageUrl: line.Product?.ImageUrl || '',
                    IsOrderPriority: null,
                    QuantityRegex: null,
                    IsDisabledLiveCampaignDetail: false,
                    CreatedById: createdById
                };

                // Keep Id if it exists (for existing details)
                if (line.Id) {
                    cleaned.Id = line.Id;
                }

                return cleaned;
            });
        }

        // Calculate totals from local orderLines
        let totalQuantity = 0;
        let totalAmount = 0;
        if (payload.Details) {
            payload.Details.forEach(detail => {
                const qty = detail.Quantity || 1;
                const price = detail.Price || 0;
                totalQuantity += qty;
                totalAmount += qty * price;
            });
        }

        payload.TotalAmount = totalAmount;
        payload.TotalQuantity = totalQuantity;

        console.log('[SALE-API] PUT payload:', {
            orderId: currentSaleOrderData.Id,
            detailsCount: payload.Details?.length || 0,
            totalAmount: payload.TotalAmount,
            totalQuantity: payload.TotalQuantity,
            hasContext: !!payload["@odata.context"],
            hasRowVersion: !!payload.RowVersion,
            hasPartner: !!payload.Partner,
            hasUser: !!payload.User,
            hasCRMTeam: !!payload.CRMTeam
        });

        // ğŸ”¥ STEP 3: PUT updated order back to API
        const putUrl = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/SaleOnline_Order(${currentSaleOrderData.Id})`;
        const response = await fetch(putUrl, {
            method: 'PUT',
            headers: {
                ...headers,
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('[SALE-API] PUT failed:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        // Handle empty response body (PUT often returns 200 OK with no content)
        let data = null;
        const responseText = await response.text();
        if (responseText && responseText.trim()) {
            try {
                data = JSON.parse(responseText);
            } catch (parseError) {
                console.log('[SALE-API] Response is not JSON, treating as success');
            }
        }

        console.log(`[SALE-API] âœ… Updated order ${currentSaleOrderData.Id} with ${payload.Details?.length || 0} products`);

        // ğŸ”¥ STEP 4: Fetch updated order AFTER PUT to get new Detail IDs
        console.log('[SALE-API] Fetching updated order to get new Detail IDs...');
        const refreshResponse = await fetch(getUrl, {
            method: 'GET',
            headers: {
                ...headers,
                Accept: "application/json",
            }
        });

        if (!refreshResponse.ok) {
            console.warn('[SALE-API] Could not fetch updated order, using old data');
        } else {
            const updatedOrder = await refreshResponse.json();
            console.log('[SALE-API] Got updated order with fresh Details:', updatedOrder);

            // Update local currentSaleOrderData with fresh data from API
            // Convert Details back to orderLines format for consistency
            currentSaleOrderData = updatedOrder;
            if (updatedOrder.Details && Array.isArray(updatedOrder.Details)) {
                currentSaleOrderData.orderLines = updatedOrder.Details.map(detail => ({
                    Id: detail.Id,
                    ProductId: detail.ProductId,
                    ProductUOMId: detail.UOMId,
                    ProductUOMQty: detail.Quantity,
                    Quantity: detail.Quantity,
                    PriceUnit: detail.Price,
                    Price: detail.Price,
                    ProductName: detail.ProductName,
                    ProductNameGet: detail.ProductNameGet,
                    ProductCode: detail.ProductCode,
                    ProductUOMName: detail.UOMName,
                    Note: detail.Note,
                    Weight: detail.ProductWeight,
                    SaleOnlineDetailId: detail.Id, // ğŸ”¥ CRITICAL: Map Detail.Id to SaleOnlineDetailId for FastSaleOrder
                    Product: {
                        Id: detail.ProductId,
                        Name: detail.ProductName,
                        DefaultCode: detail.ProductCode,
                        NameGet: detail.ProductNameGet,
                        ImageUrl: detail.ImageUrl
                    },
                    ProductUOM: {
                        Id: detail.UOMId,
                        Name: detail.UOMName
                    }
                }));
            } else {
                currentSaleOrderData.orderLines = [];
            }
        }

        return data || { success: true, orderId: currentSaleOrderData.Id };

    } catch (error) {
        console.error('[SALE-API] Error updating order:', error);
        throw error;
    }
}

/**
 * Confirm and Print Sale Order (F9)
 * Flow: FastSaleOrder POST -> print1 GET -> ODataService.DefaultGet POST -> Open print popup
 */
async function confirmAndPrintSale() {
    console.log('[SALE-CONFIRM] Starting confirm and print...');

    // Validate we have order data
    if (!currentSaleOrderData) {
        if (window.notificationManager) {
            window.notificationManager.error('KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘Æ¡n hÃ ng');
        }
        return;
    }

    // Show loading state
    const confirmBtn = document.querySelector('.sale-btn-teal');
    const originalText = confirmBtn?.textContent;
    if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.textContent = 'Äang xá»­ lÃ½...';
    }

    try {
        // Get auth token
        let token;
        if (window.tokenManager) {
            token = await window.tokenManager.getToken();
        } else {
            const storedData = localStorage.getItem('bearer_token_data');
            if (storedData) {
                const data = JSON.parse(storedData);
                token = data.access_token;
            }
        }

        if (!token) {
            throw new Error('KhÃ´ng tÃ¬m tháº¥y token xÃ¡c thá»±c');
        }

        // Step 0: Fetch default data if not already loaded (to get User, Company, etc.)
        if (!window.lastDefaultSaleData) {
            console.log('[SALE-CONFIRM] Step 0: Fetching default data first...');
            const defaultResponse = await fetch('https://tomato.tpos.vn/odata/FastSaleOrder/ODataService.DefaultGet?$expand=Warehouse,User,PriceList,Company,Journal,PaymentJournal,Partner,Carrier,Tax,SaleOrder,DestConvertCurrencyUnit', {
                method: 'POST',
                headers: {
                    'accept': 'application/json, text/plain, */*',
                    'authorization': `Bearer ${token}`,
                    'content-type': 'application/json;charset=UTF-8',
                    'tposappversion': window.TPOS_CONFIG?.tposAppVersion || '5.11.16.1',
                    'x-tpos-lang': 'vi'
                },
                body: JSON.stringify({ model: { Type: 'invoice' } })
            });
            if (defaultResponse.ok) {
                window.lastDefaultSaleData = await defaultResponse.json();
                console.log('[SALE-CONFIRM] Default data loaded:', window.lastDefaultSaleData);
            }
        }

        // Step 1: Build and POST FastSaleOrder
        console.log('[SALE-CONFIRM] Step 1: Creating FastSaleOrder...');
        const payload = buildFastSaleOrderPayload();

        const createResponse = await fetch('https://tomato.tpos.vn/odata/FastSaleOrder', {
            method: 'POST',
            headers: {
                'accept': 'application/json, text/plain, */*',
                'authorization': `Bearer ${token}`,
                'content-type': 'application/json;charset=UTF-8',
                'tposappversion': window.TPOS_CONFIG?.tposAppVersion || '5.11.16.1',
                'x-tpos-lang': 'vi'
            },
            body: JSON.stringify(payload)
        });

        if (!createResponse.ok) {
            const errorText = await createResponse.text();
            throw new Error(`Lá»—i táº¡o Ä‘Æ¡n: ${createResponse.status} - ${errorText}`);
        }

        const createResult = await createResponse.json();
        console.log('[SALE-CONFIRM] FastSaleOrder created:', createResult);

        const orderId = createResult.Id;
        const orderNumber = createResult.Number || orderId;
        if (!orderId) {
            throw new Error('KhÃ´ng nháº­n Ä‘Æ°á»£c ID Ä‘Æ¡n hÃ ng');
        }

        // Step 1.5: Update debt after order creation
        // Logic: actualPayment = min(debt, COD), remainingDebt = debt - actualPayment
        const currentDebt = parseFloat(document.getElementById('salePrepaidAmount')?.value) || 0;
        const codAmount = parseFloat(document.getElementById('saleCOD')?.value) || 0;
        if (currentDebt > 0) {
            const customerPhone = document.getElementById('saleReceiverPhone')?.value || currentSaleOrderData?.PartnerPhone || currentSaleOrderData?.Telephone;
            if (customerPhone) {
                // Calculate actual payment and remaining debt based on COD
                const actualPayment = Math.min(currentDebt, codAmount);
                const remainingDebt = Math.max(0, currentDebt - codAmount);

                console.log('[SALE-CONFIRM] Step 1.5: Debt calculation - current:', currentDebt, 'COD:', codAmount, 'paid:', actualPayment, 'remaining:', remainingDebt);

                // Update UI: update prepaidAmount to remaining debt
                const prepaidInput = document.getElementById('salePrepaidAmount');
                if (prepaidInput) {
                    prepaidInput.value = remainingDebt;
                    console.log('[SALE-CONFIRM] âœ… Updated prepaidAmount UI to:', remainingDebt);
                    // Trigger updates for COD and remaining balance
                    updateSaleCOD();
                }

                // Call API to update debt and save history (async, don't block)
                fetch(`${QR_API_URL}/api/sepay/update-debt`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        phone: customerPhone,
                        new_debt: remainingDebt,
                        old_debt: currentDebt,
                        reason: `Thanh toÃ¡n cÃ´ng ná»£ ${actualPayment.toLocaleString('vi-VN')}Ä‘ qua Ä‘Æ¡n hÃ ng #${orderNumber}${remainingDebt > 0 ? ` (cÃ²n ná»£ ${remainingDebt.toLocaleString('vi-VN')}Ä‘)` : ''}`
                    })
                }).then(res => res.json()).then(result => {
                    if (result.success) {
                        console.log('[SALE-CONFIRM] âœ… Debt updated to', remainingDebt, ', history saved');
                        // Update UI: update debt cells in table
                        const normalizedPhone = normalizePhoneForQR(customerPhone);
                        if (normalizedPhone) {
                            // Invalidate cache
                            const cache = getDebtCache();
                            delete cache[normalizedPhone];
                            saveDebtCache(cache);
                            // Update table cells with remaining debt
                            updateDebtCellsInTable(normalizedPhone, remainingDebt);
                        }
                    } else {
                        console.error('[SALE-CONFIRM] Failed to update debt:', result.error);
                    }
                }).catch(err => {
                    console.error('[SALE-CONFIRM] Error updating debt:', err);
                });
            }
        }

        // Step 2: Fetch default data for next order (async, don't block)
        console.log('[SALE-CONFIRM] Step 2: Fetching default data for new order...');
        fetch('https://tomato.tpos.vn/odata/FastSaleOrder/ODataService.DefaultGet?$expand=Warehouse,User,PriceList,Company,Journal,PaymentJournal,Partner,Carrier,Tax,SaleOrder,DestConvertCurrencyUnit', {
            method: 'POST',
            headers: {
                'accept': 'application/json, text/plain, */*',
                'authorization': `Bearer ${token}`,
                'content-type': 'application/json;charset=UTF-8',
                'tposappversion': window.TPOS_CONFIG?.tposAppVersion || '5.11.16.1',
                'x-tpos-lang': 'vi'
            },
            body: JSON.stringify({ model: { Type: 'invoice' } })
        }).then(res => res.json()).then(data => {
            console.log('[SALE-CONFIRM] Default data received for next order');
            // Store for next order if needed
            window.lastDefaultSaleData = data;
        }).catch(err => {
            console.warn('[SALE-CONFIRM] Failed to fetch default data:', err);
        });

        // Step 3: Open print popup with custom bill (no longer fetches from TPOS API)
        console.log('[SALE-CONFIRM] Step 3: Opening custom bill popup...');
        openPrintPopup(createResult, { currentSaleOrderData });

        // Step 4: Send bill image to customer via Messenger (async, don't block)
        console.log('[SALE-CONFIRM] Step 4: Sending bill to customer...');
        console.log('[SALE-CONFIRM] Order data for chat:', {
            Facebook_ASUserId: currentSaleOrderData?.Facebook_ASUserId,
            Facebook_PostId: currentSaleOrderData?.Facebook_PostId,
            Facebook_ConversationId: currentSaleOrderData?.Facebook_ConversationId,
            chatDataManager: !!window.chatDataManager
        });

        let chatInfo = window.chatDataManager?.getChatInfoForOrder(currentSaleOrderData);

        // Fallback: get chat info directly from order if chatDataManager not available
        if (!chatInfo || !chatInfo.hasChat) {
            const psid = currentSaleOrderData?.Facebook_ASUserId;
            const postId = currentSaleOrderData?.Facebook_PostId;
            const channelId = postId ? postId.split('_')[0] : null;
            if (psid && channelId) {
                chatInfo = { channelId, psid, hasChat: true };
                console.log('[SALE-CONFIRM] Using fallback chat info:', chatInfo);
            }
        }
        console.log('[SALE-CONFIRM] Final chat info:', chatInfo);

        if (chatInfo?.hasChat) {
            sendBillToCustomer(createResult, chatInfo.channelId, chatInfo.psid, { currentSaleOrderData })
                .then(result => {
                    if (result.success) {
                        console.log('[SALE-CONFIRM] âœ… Bill sent to customer successfully');
                        if (window.notificationManager) {
                            window.notificationManager.success('ÄÃ£ gá»­i phiáº¿u bÃ¡n hÃ ng qua Messenger', 3000);
                        }
                    } else {
                        console.warn('[SALE-CONFIRM] âš ï¸ Failed to send bill:', result.error);
                    }
                })
                .catch(err => {
                    console.error('[SALE-CONFIRM] âŒ Error sending bill:', err);
                });
        } else {
            console.log('[SALE-CONFIRM] â­ï¸ Skipping bill send - no chat info available');
            console.log('[SALE-CONFIRM] Reason: chatDataManager=', !!window.chatDataManager, 'hasChat=', chatInfo?.hasChat);
        }

        // Success notification
        if (window.notificationManager) {
            window.notificationManager.success(`ÄÃ£ táº¡o Ä‘Æ¡n hÃ ng ${createResult.Number || orderId}`);
        }

        // Close modal after successful creation and clear selection
        setTimeout(() => {
            closeSaleButtonModal(true); // true = clear checkbox selection
        }, 500);

    } catch (error) {
        console.error('[SALE-CONFIRM] Error:', error);
        if (window.notificationManager) {
            window.notificationManager.error(error.message || 'Lá»—i xÃ¡c nháº­n Ä‘Æ¡n hÃ ng');
        }
    } finally {
        // Restore button state
        if (confirmBtn) {
            confirmBtn.disabled = false;
            confirmBtn.textContent = originalText || 'XÃ¡c nháº­n vÃ  in (F9)';
        }
    }
}

/**
 * Format date with timezone like: 2025-12-11T21:58:53.4497898+07:00
 */
function formatDateWithTimezone(date) {
    const pad = (n, len = 2) => n.toString().padStart(len, '0');
    const year = date.getFullYear();
    const month = pad(date.getMonth() + 1);
    const day = pad(date.getDate());
    const hours = pad(date.getHours());
    const minutes = pad(date.getMinutes());
    const seconds = pad(date.getSeconds());
    const ms = pad(date.getMilliseconds(), 3);

    // Get timezone offset in hours and minutes
    const tzOffset = -date.getTimezoneOffset();
    const tzHours = pad(Math.floor(Math.abs(tzOffset) / 60));
    const tzMinutes = pad(Math.abs(tzOffset) % 60);
    const tzSign = tzOffset >= 0 ? '+' : '-';

    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${ms}0000${tzSign}${tzHours}:${tzMinutes}`;
}

/**
 * Build FastSaleOrder payload from current form data
 */
function buildFastSaleOrderPayload() {
    const order = currentSaleOrderData;
    const partner = currentSalePartnerData;
    const defaultData = window.lastDefaultSaleData || {};

    // Get form values
    const receiverName = document.getElementById('saleReceiverName')?.value || order.PartnerName || '';
    const receiverPhone = document.getElementById('saleReceiverPhone')?.value || order.PartnerPhone || '';
    const receiverAddressRaw = document.getElementById('saleReceiverAddress')?.value || '';
    const receiverAddress = receiverAddressRaw || null; // Use null instead of empty string
    const deliveryNote = document.getElementById('saleDeliveryNote')?.value || '';

    // ğŸ”¥ FIX: Use ?? instead of || to allow 0 value for shipping fee
    const shippingFeeValue = document.getElementById('saleShippingFee')?.value;
    const shippingFee = (shippingFeeValue !== '' && shippingFeeValue !== null && shippingFeeValue !== undefined)
        ? parseFloat(shippingFeeValue)
        : 35000;

    const codValue = parseFloat(document.getElementById('saleCOD')?.value) || 0;
    const prepaidAmount = parseFloat(document.getElementById('salePrepaidAmount')?.value) || 0;

    // ğŸ”¥ CashOnDelivery should equal "CÃ²n láº¡i" (Remaining balance)
    // Logic: Remaining = COD - Prepaid (if Prepaid < COD), otherwise 0
    const cashOnDelivery = prepaidAmount < codValue ? (codValue - prepaidAmount) : 0;

    // Get carrier from dropdown (saleDeliveryPartner)
    const carrierSelect = document.getElementById('saleDeliveryPartner');
    const carrierId = carrierSelect?.value ? parseInt(carrierSelect.value) : 7;
    const selectedOption = carrierSelect?.selectedOptions[0];
    // Get carrier name from data-name attribute (clean name without fee), fallback to option text
    const carrierName = selectedOption?.dataset?.name || selectedOption?.text?.replace(/\s*\([^)]*\)$/, '') || 'SHIP Tá»ˆNH';
    const carrierFee = parseFloat(selectedOption?.dataset?.fee) || shippingFee;

    // Get full carrier data from cache if available
    const cachedCarriers = getCachedDeliveryCarriers();
    const fullCarrierData = cachedCarriers?.find(c => c.Id === carrierId) || null;

    // Build order lines from current products (with full Product data)
    const orderLines = buildOrderLines();

    // Calculate totals
    const amountTotal = orderLines.reduce((sum, line) => sum + (line.PriceTotal || 0), 0);
    const totalQuantity = orderLines.reduce((sum, line) => sum + (line.ProductUOMQty || 0), 0);

    const now = new Date();
    const dateInvoice = now.toISOString();
    // Format DateCreated with timezone like: 2025-12-11T21:58:53.4497898+07:00
    const dateCreated = formatDateWithTimezone(now);

    // Get User from defaultData (from ODataService.DefaultGet)
    const user = defaultData.User || null;
    const userId = user?.Id || null;
    const userName = user?.Name || null;

    // Build payload matching the sample from fetchFastSaleOrder.text
    const payload = {
        Id: 0,
        Name: null,
        PrintShipCount: 0,
        PrintDeliveryCount: 0,
        PaymentMessageCount: 0,
        MessageCount: 0,
        PartnerId: partner?.Id || order.PartnerId || 0,
        PartnerDisplayName: partner?.DisplayName || partner?.Name || receiverName || null,
        PartnerEmail: null,
        PartnerFacebookId: partner?.FacebookId || order.Facebook_ASUserId || null,
        PartnerFacebook: null,
        PartnerPhone: receiverPhone || null,
        Reference: order.Code || '',
        PriceListId: 1,
        AmountTotal: amountTotal,
        TotalQuantity: totalQuantity,
        Discount: 0,
        DiscountAmount: 0,
        DecreaseAmount: 0,
        DiscountLoyaltyTotal: null,
        WeightTotal: 0,
        AmountTax: 0,
        AmountUntaxed: amountTotal,
        TaxId: null,
        MoveId: null,
        UserId: userId,
        UserName: userName,
        DateInvoice: dateInvoice,
        DateCreated: dateCreated,
        CreatedById: null,
        State: 'draft',
        ShowState: 'NhÃ¡p',
        CompanyId: 1,
        Comment: document.getElementById('saleReceiverNote')?.value || '',
        WarehouseId: 1,
        SaleOnlineIds: order.Id ? [order.Id] : [],
        SaleOnlineNames: [],
        Residual: null,
        Type: 'invoice',
        RefundOrderId: null,
        ReferenceNumber: null,
        AccountId: 1,
        JournalId: 3,
        Number: null,
        MoveName: null,
        PartnerNameNoSign: null,
        DeliveryPrice: shippingFee,
        CustomerDeliveryPrice: null,
        CarrierId: carrierId,
        CarrierName: carrierName,
        CarrierDeliveryType: fullCarrierData?.DeliveryType || 'fixed',
        DeliveryNote: deliveryNote,
        ReceiverName: receiverName,
        ReceiverPhone: receiverPhone,
        ReceiverAddress: receiverAddress,
        ReceiverDate: dateCreated,
        ReceiverNote: null,
        CashOnDelivery: cashOnDelivery,
        TrackingRef: null,
        TrackingArea: null,
        TrackingTransport: null,
        TrackingSortLine: null,
        TrackingUrl: '',
        IsProductDefault: false,
        TrackingRefSort: null,
        ShipStatus: 'none',
        ShowShipStatus: 'ChÆ°a tiáº¿p nháº­n',
        SaleOnlineName: '',
        PartnerShippingId: null,
        PaymentJournalId: 1,
        PaymentAmount: prepaidAmount < codValue ? prepaidAmount : codValue, // Náº¿u tráº£ trÆ°á»›c < COD thÃ¬ PaymentAmount = tráº£ trÆ°á»›c, ngÆ°á»£c láº¡i = COD
        SaleOrderId: null,
        SaleOrderIds: [],
        FacebookName: receiverName,
        FacebookNameNosign: null,
        FacebookId: partner?.FacebookId || order.Facebook_ASUserId || null,
        DisplayFacebookName: null,
        Deliver: null,
        ShipWeight: 100,
        ShipPaymentStatus: null,
        ShipPaymentStatusCode: null,
        OldCredit: 0,
        NewCredit: amountTotal,
        Phone: receiverPhone || null,
        Address: receiverAddress || null,
        AmountTotalSigned: null,
        ResidualSigned: null,
        Origin: null,
        AmountDeposit: 0,
        CompanyName: 'NJD Live',
        PreviousBalance: codValue,
        ToPay: null,
        NotModifyPriceFromSO: false,
        Ship_ServiceId: null,
        Ship_ServiceName: null,
        Ship_ServiceExtrasText: '[]',
        Ship_ExtrasText: null,
        Ship_InsuranceFee: 0,
        CurrencyName: 'VND',
        TeamId: null,
        TeamOrderCode: null,
        TeamOrderId: null,
        TeamType: null,
        Revenue: null,
        SaleOrderDeposit: 0,
        Seri: null,
        NumberOrder: null,
        DateOrderRed: null,
        ApplyPromotion: null,
        TimeLock: null,
        PageName: null,
        Tags: null,
        IRAttachmentUrl: null,
        IRAttachmentUrls: [],
        SaleOnlinesOfPartner: null,
        IsDeposited: null,
        LiveCampaignName: null,
        LiveCampaignId: null,
        Source: null,
        CartNote: null,
        ExtraPaymentAmount: null,
        QuantityUpdateDeposit: null,
        IsMergeCancel: null,
        IsPickUpAtShop: null,
        DateDeposit: null,
        IsRefund: null,
        StateCode: 'None',
        ActualPaymentAmount: null,
        RowVersion: null,
        ExchangeRate: null,
        DestConvertCurrencyUnitId: null,
        WiPointQRCode: null,
        WiInvoiceId: null,
        WiInvoiceChannelId: null,
        WiInvoiceStatus: null,
        WiInvoiceTrackingUrl: '',
        WiInvoiceIsReplate: false,
        FormAction: 'SaveAndPrint',
        Ship_Receiver: {
            IsNewAddress: false,
            Name: receiverName,
            Phone: receiverPhone,
            Street: null,
            City: { name: null, code: null, cityCode: null, cityName: null, districtCode: null, districtName: null },
            District: { name: null, code: null, cityCode: null, cityName: null, districtCode: null, districtName: null },
            Ward: { name: null, code: null, cityCode: null, cityName: null, districtCode: null, districtName: null },
            ExtraAddress: {
                Street: null,
                NewStreet: null,
                City: { name: null, nameNoSign: null, code: null },
                District: { name: null, nameNoSign: null, code: null, cityName: null, cityCode: null },
                Ward: { name: null, nameNoSign: null, code: null, cityName: null, cityCode: null, districtName: null, districtCode: null },
                NewCity: null,
                NewWard: null
            }
        },
        Ship_Extras: {
            PickWorkShift: null,
            PickWorkShiftName: null,
            DeliverWorkShift: null,
            DeliverWorkShiftName: null,
            PaymentTypeId: null,
            PosId: null,
            IsDropoff: false,
            IsInsurance: false,
            InsuranceFee: null,
            IsPackageViewable: false,
            Is_Fragile: false,
            PickupAccountId: null,
            SoldToAccountId: null,
            IsPartSign: null,
            IsAllowTryout: false,
            IsDeductCod: false,
            IsCollectMoneyGoods: false,
            CollectMoneyGoods: null,
            ConfirmType: null,
            PartialDelivery: null,
            IsRefund: null,
            ServiceCustoms: [],
            IsInsuranceEqualTotalAmount: false,
            IsReturn: false,
            IsSenderAddress: false,
            SenderAddress: { Street: null, City: null, District: null, Ward: null }
        },
        PaymentInfo: [],
        Search: null,
        ShipmentDetailsAship: {
            ConfigsProvider: [],
            PackageInfo: { PackageLength: 0, PackageWidth: 0, PackageHeight: 0 }
        },
        OrderMergeds: [],
        OrderAfterMerged: null,
        TPayment: null,
        ExtraUpdateCODCarriers: [],
        AppliedPromotionLoyalty: null,
        FastSaleOrderOmniExtras: null,
        Billing: null,
        PackageInfo: { PackageLength: 0, PackageWidth: 0, PackageHeight: 0 },
        Error: null,
        Warehouse: window.lastDefaultSaleData?.Warehouse || { Id: 1, Code: 'WH', Name: 'Nhi Judy Store', CompanyId: 1, LocationId: 12, NameGet: '[WH] Nhi Judy Store', CompanyName: 'NJD Live', LocationActive: true },
        User: window.lastDefaultSaleData?.User || null,
        PriceList: window.lastDefaultSaleData?.PriceList || { Id: 1, Name: 'Báº£ng giÃ¡ máº·c Ä‘á»‹nh', CurrencyId: 1, CurrencyName: 'VND', Active: true },
        Company: window.lastDefaultSaleData?.Company || { Id: 1, Name: 'NJD Live', Phone: '19003357' },
        Journal: window.lastDefaultSaleData?.Journal || { Id: 3, Code: 'INV', Name: 'Nháº­t kÃ½ bÃ¡n hÃ ng', Type: 'sale' },
        PaymentJournal: window.lastDefaultSaleData?.PaymentJournal || { Id: 1, Code: 'CSH1', Name: 'Tiá»n máº·t', Type: 'cash' },
        Partner: partner || null,
        Carrier: fullCarrierData || { Id: carrierId, Name: carrierName, DeliveryType: 'fixed', Config_DefaultFee: carrierFee, Active: true },
        Tax: null,
        SaleOrder: null,
        DestConvertCurrencyUnit: null,
        Ship_ServiceExtras: [],
        OrderLines: orderLines,
        OfferAmountDetails: [],
        Account: { Id: 1, Name: 'Pháº£i thu cá»§a khÃ¡ch hÃ ng', Code: '131' }
    };

    return payload;
}

/**
 * Build order lines from current modal data (uses API data with full Product/ProductUOM)
 */
function buildOrderLines() {
    const order = currentSaleOrderData;

    // Use orderLines from API (stored by populateSaleOrderLinesFromAPI)
    if (order?.orderLines && order.orderLines.length > 0) {
        return order.orderLines.map(item => {
            const qty = item.ProductUOMQty || item.Quantity || 1;
            const price = item.PriceUnit || item.Price || 0;
            const total = qty * price;

            return {
                Id: 0,
                ProductId: item.ProductId || item.Product?.Id || 0,
                ProductUOMId: item.ProductUOMId || 1,
                PriceUnit: price,
                ProductUOMQty: qty,
                Discount: item.Discount || 0,
                PriceTotal: total,
                PriceSubTotal: total,
                AccountId: item.AccountId || 5,
                PriceRecent: price,
                ProductName: item.Product?.NameGet || item.ProductName || '',
                ProductUOMName: item.ProductUOMName || item.ProductUOM?.Name || 'CÃ¡i',
                Weight: item.Weight || 0,
                Note: item.Note || null,
                SaleOnlineDetailId: item.SaleOnlineDetailId || item.Id || null,
                Product: item.Product || null, // Include full Product object
                ProductUOM: item.ProductUOM || { Id: 1, Name: 'CÃ¡i', Factor: 1, FactorInv: 1 }, // Include full ProductUOM
                Discount_Fixed: item.Discount_Fixed || 0,
                Type: item.Type || 'fixed',
                WeightTotal: item.WeightTotal || 0
            };
        });
    }

    // Fallback to order.Details if orderLines not available
    if (order?.Details && order.Details.length > 0) {
        return order.Details.map(detail => {
            const price = detail.Price || 0;
            const quantity = detail.Quantity || 1;
            const total = price * quantity;

            return {
                Id: 0,
                ProductId: detail.ProductId || 0,
                ProductUOMId: 1,
                PriceUnit: price,
                ProductUOMQty: quantity,
                Discount: 0,
                PriceTotal: total,
                PriceSubTotal: total,
                AccountId: 5,
                PriceRecent: price,
                ProductName: detail.ProductName || detail.ProductNameGet || '',
                ProductUOMName: 'CÃ¡i',
                Weight: 0,
                Note: detail.Note || null,
                SaleOnlineDetailId: detail.Id || null,
                Product: null,
                ProductUOM: { Id: 1, Name: 'CÃ¡i', Factor: 1, FactorInv: 1 },
                Discount_Fixed: 0,
                Type: 'fixed',
                WeightTotal: 0
            };
        });
    }

    return [];
}

// ============================================================================
// BILL SERVICE - Functions moved to bill-service.js
// Use window.BillService.generateCustomBillHTML, openPrintPopup, generateBillImage, sendBillToCustomer
// or global functions: generateCustomBillHTML, openPrintPopup, generateBillImage, sendBillToCustomer
// ============================================================================

// Add keyboard shortcut F9 for confirm and print
document.addEventListener('keydown', function (e) {
    if (e.key === 'F9') {
        const modal = document.getElementById('saleButtonModal');
        if (modal && modal.style.display === 'flex') {
            e.preventDefault();
            confirmAndPrintSale();
        }
    }
});

// ============================================================================
// CHAT MODAL - RIGHT PANEL TOGGLE
// ============================================================================

/**
 * Toggle chat right panel visibility
 */
function toggleChatRightPanel() {
    const rightPanel = document.querySelector('.chat-right-panel');
    const toggleIcon = document.getElementById('chatPanelToggleIcon');

    if (!rightPanel || !toggleIcon) return;

    const isCollapsed = rightPanel.classList.contains('collapsed');

    if (isCollapsed) {
        // Open panel
        rightPanel.classList.remove('collapsed');
        toggleIcon.className = 'fas fa-chevron-right';
    } else {
        // Close panel
        rightPanel.classList.add('collapsed');
        toggleIcon.className = 'fas fa-chevron-left';
    }
}

// Export functions
window.confirmAndPrintSale = confirmAndPrintSale;
window.confirmDebtUpdate = confirmDebtUpdate;
// Note: openPrintPopup is now exported from bill-service.js
window.toggleChatRightPanel = toggleChatRightPanel;
window.removeChatProduct = removeChatProduct;
window.updateChatProductQuantity = updateChatProductQuantity;

// Chat Product Manager - For Orders tab in right panel
window.chatProductManager = {
    addProductFromSearch: addChatProductFromSearch,
    renderInvoiceHistory: function () {
        // TODO: Implement invoice history rendering
        const container = document.getElementById('chatInvoiceHistoryContainer');
        if (container) {
            container.innerHTML = `
                <div class="chat-empty-products" style="text-align: center; padding: 40px 20px; color: #94a3b8;">
                    <i class="fas fa-file-invoice-dollar" style="font-size: 40px; margin-bottom: 12px; opacity: 0.5;"></i>
                    <p style="font-size: 14px; margin: 0;">Chá»©c nÄƒng Ä‘ang phÃ¡t triá»ƒn</p>
                    <p style="font-size: 12px; margin-top: 4px;">Lá»‹ch sá»­ hÃ³a Ä‘Æ¡n sáº½ sá»›m Ä‘Æ°á»£c cáº­p nháº­t</p>
                </div>
            `;
        }
    }
};

// ====================================
// #region IMAGE ZOOM
// ====================================

/**
 * Show image zoom overlay
 * @param {string} imageUrl - URL of the image to zoom
 * @param {string} productName - Name of the product (for caption)
 */
window.showImageZoom = function (imageUrl, productName = '') {
    const overlay = document.getElementById('imageZoomOverlay');
    const img = document.getElementById('imageZoomImg');
    const caption = document.getElementById('imageZoomCaption');

    if (!overlay || !img) {
        console.error('[IMAGE-ZOOM] Overlay elements not found');
        return;
    }

    // Set image source
    img.src = imageUrl;

    // Set caption if provided
    if (caption && productName) {
        caption.textContent = productName;
        caption.style.display = 'block';
    } else if (caption) {
        caption.style.display = 'none';
    }

    // Show overlay with animation
    overlay.classList.add('show');

    // Prevent body scroll when overlay is open
    document.body.style.overflow = 'hidden';

    console.log('[IMAGE-ZOOM] Showing image:', imageUrl);
};

/**
 * Close image zoom overlay
 */
window.closeImageZoom = function () {
    const overlay = document.getElementById('imageZoomOverlay');
    if (!overlay) return;

    // Hide overlay
    overlay.classList.remove('show');

    // Restore body scroll
    document.body.style.overflow = '';

    console.log('[IMAGE-ZOOM] Closed');
};

// Close on ESC key
document.addEventListener('keydown', function (event) {
    if (event.key === 'Escape') {
        const overlay = document.getElementById('imageZoomOverlay');
        if (overlay && overlay.classList.contains('show')) {
            window.closeImageZoom();
        }
    }
});

// #endregion IMAGE ZOOM

// =====================================================
// FAST SALE MODAL (Táº¡o nhanh PBH)
// =====================================================

let fastSaleOrdersData = [];

/**
 * Show Fast Sale Modal and fetch data for selected orders
 */
async function showFastSaleModal() {
    const modal = document.getElementById('fastSaleModal');
    const modalBody = document.getElementById('fastSaleModalBody');
    const subtitle = document.getElementById('fastSaleModalSubtitle');

    // Reset state
    fastSaleOrdersData = [];

    // Show modal with loading state
    modal.classList.add('show');
    modalBody.innerHTML = `
        <div class="merge-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Äang táº£i dá»¯ liá»‡u Ä‘Æ¡n hÃ ng...</p>
        </div>
    `;

    try {
        // Get selected order IDs
        const selectedIds = Array.from(selectedOrderIds);

        if (selectedIds.length === 0) {
            modalBody.innerHTML = `
                <div class="merge-no-duplicates">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>Vui lÃ²ng chá»n Ã­t nháº¥t má»™t Ä‘Æ¡n hÃ ng.</p>
                </div>
            `;
            return;
        }

        subtitle.textContent = `ÄÃ£ chá»n ${selectedIds.length} Ä‘Æ¡n hÃ ng`;

        // Fetch FastSaleOrder data using batch API
        fastSaleOrdersData = await fetchFastSaleOrdersData(selectedIds);

        if (fastSaleOrdersData.length === 0) {
            modalBody.innerHTML = `
                <div class="merge-no-duplicates">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>KhÃ´ng thá»ƒ táº£i dá»¯ liá»‡u Ä‘Æ¡n hÃ ng. Vui lÃ²ng thá»­ láº¡i.</p>
                </div>
            `;
            return;
        }

        // Render modal body
        renderFastSaleModalBody();

    } catch (error) {
        console.error('[FAST-SALE] Error loading data:', error);
        modalBody.innerHTML = `
            <div class="merge-no-duplicates">
                <i class="fas fa-exclamation-circle"></i>
                <p>ÄÃ£ xáº£y ra lá»—i khi táº£i dá»¯ liá»‡u: ${error.message}</p>
            </div>
        `;
    }
}

/**
 * Close Fast Sale Modal
 */
function closeFastSaleModal() {
    const modal = document.getElementById('fastSaleModal');
    modal.classList.remove('show');

    // Reset state
    fastSaleOrdersData = [];
}

/**
 * Fetch FastSaleOrder data for multiple orders (batch)
 * @param {Array<string>} orderIds - Array of Order IDs
 * @returns {Promise<Array<Object>>} Array of FastSaleOrder data
 */
async function fetchFastSaleOrdersData(orderIds) {
    try {
        const headers = await window.tokenManager.getAuthHeader();

        // Fetch FastSaleOrder using POST with order IDs
        const url = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/FastSaleOrder/ODataService.GetListOrderIds?$expand=OrderLines,Partner,Carrier`;

        console.log(`[FAST-SALE] Fetching ${orderIds.length} orders from API...`);

        const response = await API_CONFIG.smartFetch(url, {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ids: orderIds
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const data = await response.json();

        if (data.value && data.value.length > 0) {
            console.log(`[FAST-SALE] Successfully fetched ${data.value.length} FastSaleOrders`);
            return data.value;
        } else {
            console.warn(`[FAST-SALE] No FastSaleOrder found for ${orderIds.length} orders`);
            return [];
        }
    } catch (error) {
        console.error(`[FAST-SALE] Error fetching orders:`, error);

        // Fallback: return basic data from displayedData
        console.warn('[FAST-SALE] Using fallback data from displayedData');
        return orderIds.map(orderId => {
            const order = displayedData.find(o => o.Id === orderId);
            if (!order) return null;

            return {
                Id: null,
                Reference: order.Code,
                PartnerDisplayName: order.Name || order.PartnerName,
                PartnerPhone: order.Telephone,
                PartnerAddress: order.Address,
                DeliveryPrice: 35000,
                CarrierName: 'SHIP Tá»ˆNH',
                SaleOnlineOrder: order,
                OrderLines: order.Details || [],
                NotFound: true
            };
        }).filter(o => o !== null);
    }
}

/**
 * Render Fast Sale Modal Body
 */
async function renderFastSaleModalBody() {
    const modalBody = document.getElementById('fastSaleModalBody');

    if (fastSaleOrdersData.length === 0) {
        modalBody.innerHTML = `
            <div class="merge-no-duplicates">
                <i class="fas fa-inbox"></i>
                <p>KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘á»ƒ hiá»ƒn thá»‹.</p>
            </div>
        `;
        return;
    }

    // Fetch delivery carriers first
    const carriers = await fetchDeliveryCarriers();
    console.log(`[FAST-SALE] Fetched ${carriers.length} delivery carriers`);

    // Render table similar to the image provided
    const html = `
        <div class="fast-sale-container">
            <div class="fast-sale-header">
                <div class="fast-sale-partner-select">
                    <label for="fastSalePartner">Äá»‘i tÃ¡c giao hÃ ng</label>
                    <select id="fastSalePartner" class="form-control">
                        <option value="">-- Chá»n máº·c Ä‘á»‹nh --</option>
                        ${carriers.map(c => {
        const fee = c.Config_DefaultFee || c.FixedPrice || 0;
        const feeText = fee > 0 ? ` (${formatCurrencyVND(fee)})` : '';
        return `<option value="${c.Id}" data-fee="${fee}" data-name="${c.Name}">${c.Name}${feeText}</option>`;
    }).join('')}
                    </select>
                </div>
                <div class="fast-sale-search">
                    <label>Nháº­p tá»« khÃ³a tÃ¬m kiáº¿m</label>
                    <select class="form-control">
                        <option>Nháº­p tá»« khÃ³a tÃ¬m kiáº¿m</option>
                    </select>
                </div>
                <div class="fast-sale-note">
                    <p style="color: #dc2626; font-size: 13px; margin: 0;">
                        <i class="fas fa-exclamation-triangle"></i>
                        Pháº§n má»m sáº½ tá»± chá»n vá»›i sá»‘ tiá»n ship tháº¥p nháº¥t
                    </p>
                    <p style="color: #dc2626; font-size: 13px; margin: 4px 0 0 0;">
                        <i class="fas fa-info-circle"></i>
                        LÆ°u Ã½: Chá»‰ cÃ³ thá»ƒ tÃ¬m kiáº¿m Ä‘Æ¡n hÃ ng phÃ¡t sinh trong 2 thÃ¡ng vá»«a qua!
                    </p>
                </div>
            </div>
            <div class="fast-sale-table-wrapper">
                <table class="fast-sale-table">
                    <thead>
                        <tr>
                            <th>STT</th>
                            <th>Sáº£n pháº©m</th>
                            <th>Sá»‘ lÆ°á»£ng</th>
                            <th>Sá»‘ tiá»n</th>
                            <th>Tá»•ng tiá»n</th>
                            <th>Ghi chÃº</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${fastSaleOrdersData.map((order, index) => renderFastSaleOrderRow(order, index, carriers)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;

    modalBody.innerHTML = html;

    // Auto-select carriers for each order based on address
    setTimeout(() => {
        fastSaleOrdersData.forEach((order, index) => {
            const rowCarrierSelect = document.querySelector(`#fastSaleCarrier_${index}`);
            if (rowCarrierSelect && rowCarrierSelect.options.length > 1) {
                // Get address from SaleOnlineOrder
                let address = '';
                let saleOnlineOrder = null;
                if (order.SaleOnlineIds && order.SaleOnlineIds.length > 0) {
                    const saleOnlineId = order.SaleOnlineIds[0];
                    saleOnlineOrder = displayedData.find(o => o.Id === saleOnlineId);
                    address = saleOnlineOrder?.Address || '';
                }

                if (address) {
                    console.log(`[FAST-SALE] Auto-selecting carrier for order ${index} with address: ${address}`);
                    smartSelectCarrierForRow(rowCarrierSelect, address, null);
                }
            }
        });
    }, 100);
}

/**
 * Render a single order row in Fast Sale Modal
 * @param {Object} order - FastSaleOrder data
 * @param {number} index - Row index
 * @param {Array} carriers - Array of delivery carriers
 * @returns {string} HTML string
 */
function renderFastSaleOrderRow(order, index, carriers = []) {
    // Get SaleOnlineOrder from displayedData to get phone and address
    let saleOnlineOrder = null;
    if (order.SaleOnlineIds && order.SaleOnlineIds.length > 0) {
        const saleOnlineId = order.SaleOnlineIds[0];
        saleOnlineOrder = displayedData.find(o => o.Id === saleOnlineId);
    }

    const customerName = order.PartnerDisplayName || order.Partner?.PartnerDisplayName || saleOnlineOrder?.Name || 'N/A';
    const customerCode = order.Reference || 'N/A';

    // Get phone from SaleOnlineOrder first, then fallback to FastSaleOrder
    const customerPhone = saleOnlineOrder?.Telephone || order.PartnerPhone || order.Partner?.PartnerPhone || 'N/A';

    // Get address from SaleOnlineOrder first, then fallback to FastSaleOrder
    const customerAddress = saleOnlineOrder?.Address || order.Partner?.PartnerAddress || '*ChÆ°a cÃ³ Ä‘á»‹a chá»‰';

    // Get products from OrderLines or SaleOnlineOrder Details
    const products = order.OrderLines || saleOnlineOrder?.Details || [];

    // Build carrier options
    const carrierOptions = carriers.map(c => {
        const fee = c.Config_DefaultFee || c.FixedPrice || 0;
        const feeText = fee > 0 ? ` (${formatCurrencyVND(fee)})` : '';
        return `<option value="${c.Id}" data-fee="${fee}" data-name="${c.Name}">${c.Name}${feeText}</option>`;
    }).join('');

    // Get default shipping fee from order or use 35000
    const defaultShippingFee = order.DeliveryPrice || 35000;

    // Build product rows
    const productRows = products.map((product, pIndex) => {
        const productName = product.ProductName || 'N/A';
        const quantity = product.ProductUOMQty || product.Quantity || 0;
        const price = product.PriceUnit || product.Price || 0;
        const total = product.PriceSubTotal || (quantity * price) || 0;
        const note = product.Note || '';

        return `
            <tr>
                ${pIndex === 0 ? `
                    <td rowspan="${products.length}" style="vertical-align: top;">
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div style="font-weight: 600;">${customerName}</div>
                            <div style="font-size: 12px; color: #6b7280;">${customerCode}</div>
                            <div style="display: flex; align-items: center; gap: 4px;">
                                <i class="fas fa-phone" style="font-size: 10px; color: #9ca3af;"></i>
                                <span style="font-size: 12px;">${customerPhone}</span>
                            </div>
                            ${order.ShowShipStatus ? `<span class="badge" style="background: #10b981; color: white; font-size: 11px; padding: 2px 6px; border-radius: 4px;">Bom hÃ ng</span>` : ''}
                            <div style="font-size: 12px; color: #6b7280;">
                                <i class="fas fa-map-marker-alt" style="font-size: 10px;"></i>
                                ${customerAddress}
                            </div>
                            <div style="font-size: 11px; color: #9ca3af;">
                                Chiáº¿n dá»‹ch Live: ${order.SaleOnlineNames || 'N/A'}
                            </div>
                            <div style="margin-top: 8px;">
                                <div style="font-size: 11px; color: #6b7280;">Äá»‘i tÃ¡c:</div>
                                <select id="fastSaleCarrier_${index}" class="form-control form-control-sm fast-sale-carrier-select"
                                        data-row-index="${index}"
                                        style="font-size: 12px; margin-top: 4px;"
                                        onchange="updateFastSaleShippingFee(${index})">
                                    <option value="">-- Chá»n --</option>
                                    ${carrierOptions}
                                </select>
                            </div>
                            <div style="margin-top: 4px;">
                                <div style="font-size: 11px; color: #6b7280;">Tiá»n ship:</div>
                                <input id="fastSaleShippingFee_${index}" type="number" class="form-control form-control-sm"
                                       value="${defaultShippingFee}" style="font-size: 12px; margin-top: 4px;" />
                            </div>
                            <div style="margin-top: 4px;">
                                <div style="font-size: 11px; color: #6b7280;">KL (g)</div>
                                <input id="fastSaleWeight_${index}" type="number" class="form-control form-control-sm" value="100" style="font-size: 12px; margin-top: 4px;" />
                            </div>
                            <div style="display: flex; gap: 8px; margin-top: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-size: 11px; color: #6b7280;">Chiá»u dÃ i:</div>
                                    <input id="fastSaleLength_${index}" type="number" class="form-control form-control-sm" value="0.00" style="font-size: 12px; margin-top: 4px;" step="0.01" />
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-size: 11px; color: #6b7280;">Chiá»u rá»™ng:</div>
                                    <input id="fastSaleWidth_${index}" type="number" class="form-control form-control-sm" value="0.00" style="font-size: 12px; margin-top: 4px;" step="0.01" />
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-size: 11px; color: #6b7280;">Chiá»u cao:</div>
                                    <input id="fastSaleHeight_${index}" type="number" class="form-control form-control-sm" value="0.00" style="font-size: 12px; margin-top: 4px;" step="0.01" />
                                </div>
                            </div>
                        </div>
                    </td>
                ` : ''}
                <td>
                    <div style="font-weight: 500; font-size: 13px;">${productName}</div>
                </td>
                <td style="text-align: center;">${quantity}</td>
                <td style="text-align: right;">${price.toLocaleString('vi-VN')}</td>
                <td style="text-align: right; font-weight: 600;">${total.toLocaleString('vi-VN')}</td>
                <td>${note}</td>
            </tr>
        `;
    }).join('');

    return productRows;
}

/**
 * Update shipping fee when carrier is selected for a row
 * @param {number} index - Row index
 */
function updateFastSaleShippingFee(index) {
    const carrierSelect = document.getElementById(`fastSaleCarrier_${index}`);
    const shippingFeeInput = document.getElementById(`fastSaleShippingFee_${index}`);

    if (carrierSelect && shippingFeeInput) {
        const selectedOption = carrierSelect.options[carrierSelect.selectedIndex];
        const fee = parseFloat(selectedOption.dataset.fee) || 0;
        shippingFeeInput.value = fee;
    }
}

/**
 * Smart select carrier for a specific row based on address
 * @param {HTMLSelectElement} select - The carrier dropdown for this row
 * @param {string} address - Customer address
 * @param {object} extraAddress - Optional ExtraAddress object
 */
function smartSelectCarrierForRow(select, address, extraAddress = null) {
    if (!select || select.options.length <= 1) {
        return;
    }

    // Extract district info
    const districtInfo = extractDistrictFromAddress(address, extraAddress);

    if (!districtInfo) {
        console.log('[FAST-SALE] Could not extract district, selecting default carrier');
        selectCarrierByName(select, 'SHIP Tá»ˆNH', false);
        return;
    }

    // Find matching carrier
    const matchedCarrier = findMatchingCarrier(select, districtInfo);

    if (matchedCarrier) {
        console.log('[FAST-SALE] âœ… Auto-selected carrier:', matchedCarrier.name);
        select.value = matchedCarrier.id;
        select.dispatchEvent(new Event('change'));
    } else {
        console.log('[FAST-SALE] No matching carrier, selecting SHIP Tá»ˆNH');
        selectCarrierByName(select, 'SHIP Tá»ˆNH', false);
    }
}

/**
 * Collect Fast Sale data from modal inputs
 * @returns {Array<Object>} Array of order models
 */
function collectFastSaleData() {
    const models = [];

    fastSaleOrdersData.forEach((order, index) => {
        // Get input values
        const carrierSelect = document.getElementById(`fastSaleCarrier_${index}`);
        const shippingFeeInput = document.getElementById(`fastSaleShippingFee_${index}`);
        const weightInput = document.getElementById(`fastSaleWeight_${index}`);
        const lengthInput = document.getElementById(`fastSaleLength_${index}`);
        const widthInput = document.getElementById(`fastSaleWidth_${index}`);
        const heightInput = document.getElementById(`fastSaleHeight_${index}`);

        // Get carrier info
        const carrierId = parseInt(carrierSelect?.value) || 0;
        const carrierName = carrierSelect?.options[carrierSelect.selectedIndex]?.dataset?.name || '';

        // Get SaleOnlineOrder for phone and address
        let saleOnlineOrder = null;
        if (order.SaleOnlineIds && order.SaleOnlineIds.length > 0) {
            const saleOnlineId = order.SaleOnlineIds[0];
            saleOnlineOrder = displayedData.find(o => o.Id === saleOnlineId);
        }

        // Get dimensions
        const packageLength = parseFloat(lengthInput?.value) || 0;
        const packageWidth = parseFloat(widthInput?.value) || 0;
        const packageHeight = parseFloat(heightInput?.value) || 0;

        // Get current user ID from token or global context
        const currentUserId = window.tokenManager?.userId || window.currentUser?.Id || null;

        // Build order model matching exact API structure
        const model = {
            Id: 0,
            Name: null,
            PrintShipCount: 0,
            PrintDeliveryCount: 0,
            PaymentMessageCount: 0,
            MessageCount: 0,
            PartnerId: order.PartnerId || 0,
            PartnerDisplayName: order.PartnerDisplayName || saleOnlineOrder?.Name || '',
            PartnerEmail: null,
            PartnerFacebookId: null,
            PartnerFacebook: null,
            PartnerPhone: null,
            Reference: order.Reference || '',
            PriceListId: 0,
            AmountTotal: order.AmountTotal || 0,
            TotalQuantity: 0,
            Discount: 0,
            DiscountAmount: 0,
            DecreaseAmount: 0,
            DiscountLoyaltyTotal: null,
            WeightTotal: 0,
            AmountTax: null,
            AmountUntaxed: null,
            TaxId: null,
            MoveId: null,
            UserId: currentUserId,
            UserName: null,
            DateInvoice: new Date().toISOString(),
            DateCreated: order.DateCreated || new Date().toISOString(),
            CreatedById: null,
            State: "draft",
            ShowState: "NhÃ¡p",
            CompanyId: 0,
            Comment: "",
            WarehouseId: 0,
            SaleOnlineIds: order.SaleOnlineIds || [],
            SaleOnlineNames: Array.isArray(order.SaleOnlineNames) ? order.SaleOnlineNames : [order.SaleOnlineNames || ''],
            Residual: null,
            Type: null,
            RefundOrderId: null,
            ReferenceNumber: null,
            AccountId: 0,
            JournalId: 0,
            Number: null,
            MoveName: null,
            PartnerNameNoSign: null,
            DeliveryPrice: parseFloat(shippingFeeInput?.value) || 0,
            CustomerDeliveryPrice: null,
            CarrierId: carrierId,
            CarrierName: carrierName,
            CarrierDeliveryType: null,
            DeliveryNote: null,
            ReceiverName: null,
            ReceiverPhone: null,
            ReceiverAddress: null,
            ReceiverDate: null,
            ReceiverNote: null,
            CashOnDelivery: 0,
            TrackingRef: null,
            TrackingArea: null,
            TrackingTransport: null,
            TrackingSortLine: null,
            TrackingUrl: "",
            IsProductDefault: false,
            TrackingRefSort: null,
            ShipStatus: "none",
            ShowShipStatus: order.ShowShipStatus || "ChÆ°a tiáº¿p nháº­n",
            SaleOnlineName: order.Reference || '',
            PartnerShippingId: null,
            PaymentJournalId: null,
            PaymentAmount: 0,
            SaleOrderId: null,
            SaleOrderIds: [],
            FacebookName: order.PartnerDisplayName || saleOnlineOrder?.Name || '',
            FacebookNameNosign: null,
            FacebookId: null,
            DisplayFacebookName: null,
            Deliver: null,
            ShipWeight: parseFloat(weightInput?.value) || 100,
            ShipPaymentStatus: null,
            ShipPaymentStatusCode: null,
            OldCredit: 0,
            NewCredit: 0,
            Phone: null,
            Address: null,
            AmountTotalSigned: null,
            ResidualSigned: null,
            Origin: null,
            AmountDeposit: 0,
            CompanyName: null,
            PreviousBalance: null,
            ToPay: null,
            NotModifyPriceFromSO: false,
            Ship_ServiceId: null,
            Ship_ServiceName: null,
            Ship_ServiceExtrasText: null,
            Ship_ExtrasText: null,
            Ship_InsuranceFee: null,
            CurrencyName: null,
            TeamId: null,
            TeamOrderCode: null,
            TeamOrderId: null,
            TeamType: null,
            Revenue: null,
            SaleOrderDeposit: null,
            Seri: null,
            NumberOrder: null,
            DateOrderRed: null,
            ApplyPromotion: null,
            TimeLock: null,
            PageName: null,
            Tags: null,
            IRAttachmentUrl: null,
            IRAttachmentUrls: [],
            SaleOnlinesOfPartner: null,
            IsDeposited: null,
            LiveCampaignName: order.LiveCampaignName || '',
            LiveCampaignId: order.LiveCampaignId || null,
            Source: null,
            CartNote: null,
            ExtraPaymentAmount: null,
            QuantityUpdateDeposit: null,
            IsMergeCancel: null,
            IsPickUpAtShop: null,
            DateDeposit: null,
            IsRefund: null,
            StateCode: "None",
            ActualPaymentAmount: null,
            RowVersion: null,
            ExchangeRate: null,
            DestConvertCurrencyUnitId: null,
            WiPointQRCode: null,
            WiInvoiceId: null,
            WiInvoiceChannelId: null,
            WiInvoiceStatus: null,
            WiInvoiceTrackingUrl: "",
            WiInvoiceIsReplate: false,
            FormAction: null,
            Ship_Receiver: null,
            Ship_Extras: null,
            PaymentInfo: [],
            Search: null,
            ShipmentDetailsAship: {
                PackageInfo: {
                    PackageLength: packageLength,
                    PackageWidth: packageWidth,
                    PackageHeight: packageHeight
                }
            },
            OrderMergeds: [],
            OrderAfterMerged: null,
            TPayment: null,
            ExtraUpdateCODCarriers: [],
            AppliedPromotionLoyalty: null,
            FastSaleOrderOmniExtras: null,
            Billing: null,
            PackageInfo: {
                PackageLength: packageLength,
                PackageWidth: packageWidth,
                PackageHeight: packageHeight
            },
            Error: null,
            OrderLines: (order.OrderLines || []).map(line => ({
                Id: 0,
                OrderId: 0,
                ProductId: line.ProductId,
                ProductUOMId: line.ProductUOMId || 1,
                PriceUnit: line.PriceUnit || 0,
                ProductUOMQty: line.ProductUOMQty || 0,
                ProductUOMQtyAvailable: 0,
                UserId: null,
                Discount: 0,
                Discount_Fixed: 0,
                DiscountTotalLoyalty: null,
                PriceTotal: line.PriceTotal || line.PriceSubTotal || 0,
                PriceSubTotal: line.PriceSubTotal || 0,
                Weight: 0,
                WeightTotal: null,
                AccountId: 0,
                PriceRecent: null,
                Name: null,
                IsName: false,
                ProductName: line.ProductName || '',
                ProductUOMName: line.ProductUOMName || 'CÃ¡i',
                SaleLineIds: [],
                ProductNameGet: null,
                SaleLineId: null,
                Type: "fixed",
                PromotionProgramId: null,
                Note: line.Note || null,
                FacebookPostId: null,
                ChannelType: null,
                ProductBarcode: null,
                CompanyId: null,
                PartnerId: null,
                PriceSubTotalSigned: null,
                PromotionProgramComboId: null,
                LiveCampaign_DetailId: null,
                LiveCampaignQtyChange: 0,
                ProductImageUrl: "",
                SaleOnlineDetailId: null,
                PriceCheck: null,
                IsNotEnoughInventory: null,
                Tags: [],
                CreatedById: null,
                TrackingRef: null,
                ReturnTotal: 0,
                ConversionPrice: null
            })),
            Partner: order.Partner || {
                Id: order.PartnerId || 0,
                Name: order.PartnerDisplayName || saleOnlineOrder?.Name || '',
                DisplayName: order.PartnerDisplayName || saleOnlineOrder?.Name || '',
                Street: saleOnlineOrder?.Address || order.Partner?.Street || null,
                Phone: saleOnlineOrder?.Telephone || order.Partner?.Phone || '',
                Customer: true,
                Type: "contact",
                CompanyType: "person",
                DateCreated: new Date().toISOString(),
                ExtraAddress: order.Partner?.ExtraAddress || null
            },
            Carrier: order.Carrier || {
                Id: carrierId,
                Name: carrierName,
                DeliveryType: "fixed",
                Config_DefaultFee: parseFloat(shippingFeeInput?.value) || 0
            }
        };

        models.push(model);
    });

    return models;
}

/**
 * Confirm and save Fast Sale (LÆ°u button)
 */
async function confirmFastSale() {
    await saveFastSaleOrders(false);
}

/**
 * Confirm and check Fast Sale (LÆ°u xÃ¡c nháº­n button)
 */
async function confirmAndCheckFastSale() {
    await saveFastSaleOrders(true);
}

/**
 * Save Fast Sale orders to backend
 * @param {boolean} isApprove - Whether to approve orders (LÆ°u xÃ¡c nháº­n)
 */
async function saveFastSaleOrders(isApprove = false) {
    try {
        console.log(`[FAST-SALE] Saving Fast Sale orders (is_approve: ${isApprove})...`);

        // Collect data from modal
        const models = collectFastSaleData();

        if (models.length === 0) {
            window.notificationManager.error('KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘á»ƒ lÆ°u', 'Lá»—i');
            return;
        }

        // Validate required fields
        const invalidOrders = models.filter((m, index) => {
            if (!m.CarrierId || m.CarrierId === 0) {
                console.error(`[FAST-SALE] Order ${index} (${m.Reference}) missing carrier`);
                return true;
            }
            if (!m.Partner || !m.Partner.Phone) {
                console.error(`[FAST-SALE] Order ${index} (${m.Reference}) missing phone`);
                return true;
            }
            if (!m.Partner || !m.Partner.Street) {
                console.error(`[FAST-SALE] Order ${index} (${m.Reference}) missing address`);
                return true;
            }
            return false;
        });

        if (invalidOrders.length > 0) {
            window.notificationManager.error(
                `CÃ³ ${invalidOrders.length} Ä‘Æ¡n hÃ ng thiáº¿u thÃ´ng tin báº¯t buá»™c (Ä‘á»‘i tÃ¡c ship, SÄT, Ä‘á»‹a chá»‰)`,
                'Lá»—i validation'
            );
            return;
        }

        // Show loading notification with timeout
        const loadingNotif = window.notificationManager.info(
            `Äang ${isApprove ? 'lÆ°u vÃ  xÃ¡c nháº­n' : 'lÆ°u'} ${models.length} Ä‘Æ¡n hÃ ng...`,
            3000 // Auto-dismiss after 3 seconds
        );

        // Build request body
        const requestBody = {
            is_approve: isApprove,
            model: models
        };

        console.log('[FAST-SALE] Request body:', requestBody);

        // Call API
        const headers = await window.tokenManager.getAuthHeader();

        // Use different endpoint based on isApprove
        // "LÆ°u xÃ¡c nháº­n" uses isForce=true endpoint with is_approve: true
        // "LÆ°u" uses normal endpoint with is_approve: false
        let url;
        if (isApprove) {
            url = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/FastSaleOrder/InsertListOrderModel?isForce=true&$expand=DataErrorFast($expand=Partner,OrderLines),OrdersError($expand=Partner),OrdersSucessed($expand=Partner)`;
        } else {
            url = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/FastSaleOrder/ODataService.InsertListOrderModel?$expand=DataErrorFast($expand=Partner,OrderLines),OrdersError($expand=Partner),OrdersSucessed($expand=Partner)`;
        }

        const response = await API_CONFIG.smartFetch(url, {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const result = await response.json();
        console.log('[FAST-SALE] Save result:', result);

        // Close loading notification
        if (loadingNotif && typeof loadingNotif.close === 'function') {
            loadingNotif.close();
        }

        // Show results modal
        showFastSaleResultsModal(result);

        // Note: Bill sending is handled manually via "In hÃ³a Ä‘Æ¡n" button in printSuccessOrders()

    } catch (error) {
        console.error('[FAST-SALE] Error saving orders:', error);

        // Close loading notification on error
        if (loadingNotif && typeof loadingNotif.close === 'function') {
            loadingNotif.close();
        }

        window.notificationManager.error(
            `Lá»—i khi lÆ°u Ä‘Æ¡n hÃ ng: ${error.message}`,
            'Lá»—i há»‡ thá»‘ng'
        );
    }
}

/**
 * Store Fast Sale results data
 */
let fastSaleResultsData = {
    forced: [],
    failed: [],
    success: []
};

/**
 * Cache for pre-generated bill images and send tasks
 * Key: order ID or order Number
 * Value: { imageBlob, contentUrl, contentId, enrichedOrder, sendTask }
 */
window.preGeneratedBillData = new Map();

/**
 * Flag to track if pre-generation is in progress
 */
window.isPreGeneratingBills = false;

/**
 * Pre-generate bill images in background after orders are created
 * This runs automatically when success orders are available
 */
async function preGenerateBillImages() {
    const successOrders = fastSaleResultsData.success;
    if (!successOrders || successOrders.length === 0) {
        console.log('[FAST-SALE] No success orders to pre-generate bills for');
        return;
    }

    window.isPreGeneratingBills = true;
    // Run in background - don't disable print button

    console.log(`[FAST-SALE] ğŸ¨ Pre-generating ${successOrders.length} bill images in background...`);
    window.preGeneratedBillData.clear();

    for (let i = 0; i < successOrders.length; i++) {
        const order = successOrders[i];

        try {
            // Find original order by matching SaleOnlineIds or Reference (same logic as printSuccessOrders)
            const originalOrderIndex = fastSaleOrdersData.findIndex(o =>
                (o.SaleOnlineIds && order.SaleOnlineIds &&
                    JSON.stringify(o.SaleOnlineIds) === JSON.stringify(order.SaleOnlineIds)) ||
                (o.Reference && o.Reference === order.Reference)
            );
            const originalOrder = originalOrderIndex >= 0 ? fastSaleOrdersData[originalOrderIndex] : null;

            // Find saleOnline order from displayedData
            const saleOnlineId = order.SaleOnlineIds?.[0];
            const saleOnlineOrderForData = saleOnlineId
                ? displayedData.find(o => o.Id === saleOnlineId || String(o.Id) === String(saleOnlineId))
                : null;

            // Get CarrierName from form dropdown
            const carrierSelect = originalOrderIndex >= 0 ? document.getElementById(`fastSaleCarrier_${originalOrderIndex}`) : null;
            const carrierNameFromDropdown = carrierSelect?.options[carrierSelect.selectedIndex]?.text || '';
            const carrierName = carrierNameFromDropdown ||
                originalOrder?.Carrier?.Name ||
                originalOrder?.CarrierName ||
                order.CarrierName ||
                order.Carrier?.Name ||
                '';
            const shippingFee = originalOrderIndex >= 0
                ? parseFloat(document.getElementById(`fastSaleShippingFee_${originalOrderIndex}`)?.value) || 0
                : order.DeliveryPrice || 0;

            // Get OrderLines
            let orderLines = originalOrder?.OrderLines || order.OrderLines || [];
            if ((!orderLines || orderLines.length === 0) && saleOnlineOrderForData?.Details) {
                orderLines = saleOnlineOrderForData.Details.map(d => ({
                    ProductName: d.ProductName || d.ProductNameGet || '',
                    ProductNameGet: d.ProductNameGet || d.ProductName || '',
                    ProductUOMQty: d.Quantity || d.ProductUOMQty || 1,
                    Quantity: d.Quantity || d.ProductUOMQty || 1,
                    PriceUnit: d.Price || d.PriceUnit || 0,
                    Note: d.Note || ''
                }));
            }

            // Create enriched order
            const enrichedOrder = {
                ...order,
                OrderLines: orderLines,
                CarrierName: carrierName,
                DeliveryPrice: shippingFee,
                PartnerDisplayName: order.PartnerDisplayName || originalOrder?.PartnerDisplayName || '',
            };

            // Find saleOnline order for chat info
            let saleOnlineOrder = saleOnlineOrderForData;
            const saleOnlineName = order.SaleOnlineNames?.[0];
            if (!saleOnlineOrder && saleOnlineName) {
                saleOnlineOrder = displayedData.find(o => o.Code === saleOnlineName);
            }
            if (!saleOnlineOrder && order.PartnerId) {
                saleOnlineOrder = displayedData.find(o => o.PartnerId === order.PartnerId);
            }

            // Prepare send task
            let sendTask = null;
            if (saleOnlineOrder) {
                const psid = saleOnlineOrder.Facebook_ASUserId;
                const postId = saleOnlineOrder.Facebook_PostId;
                const channelId = postId ? postId.split('_')[0] : null;

                if (psid && channelId) {
                    sendTask = {
                        channelId,
                        psid,
                        customerName: saleOnlineOrder.Name,
                        orderNumber: order.Number
                    };
                }
            }

            // Generate bill image in background
            const imageBlob = await generateBillImage(enrichedOrder, {});

            // Upload image to Pancake immediately if we have sendTask
            let contentUrl = null;
            let contentId = null;
            if (sendTask && window.pancakeDataManager) {
                const imageFile = new File([imageBlob], `bill_${order.Number || Date.now()}.png`, { type: 'image/png' });
                const uploadResult = await window.pancakeDataManager.uploadImage(sendTask.channelId, imageFile);
                contentUrl = typeof uploadResult === 'string' ? uploadResult : uploadResult.content_url;
                // IMPORTANT: Use content_id (hash), not id (UUID) - Pancake API expects content_id
                contentId = typeof uploadResult === 'object' ? (uploadResult.content_id || uploadResult.id) : null;
                console.log(`[FAST-SALE] ğŸ“¤ Pre-uploaded bill image for ${order.Number}: ${contentUrl}, content_id: ${contentId}`);
            }

            // Cache the data
            const cacheKey = order.Id || order.Number;
            window.preGeneratedBillData.set(cacheKey, {
                imageBlob,
                contentUrl,
                contentId,
                enrichedOrder,
                sendTask
            });

            console.log(`[FAST-SALE] âœ… Pre-generated bill ${i + 1}/${successOrders.length}: ${order.Number}`);

        } catch (error) {
            console.error(`[FAST-SALE] âŒ Error pre-generating bill for ${order.Number}:`, error);
        }
    }

    console.log(`[FAST-SALE] ğŸ¨ Pre-generation complete: ${window.preGeneratedBillData.size}/${successOrders.length} bills ready`);
    window.notificationManager.success(`ÄÃ£ táº¡o sáºµn ${window.preGeneratedBillData.size} bill images`, 2000);

    window.isPreGeneratingBills = false;
}

/**
 * Show Fast Sale Results Modal
 * @param {Object} results - API response with OrdersSucessed, OrdersError, DataErrorFast
 */
function showFastSaleResultsModal(results) {
    // Store results
    fastSaleResultsData = {
        forced: results.DataErrorFast || [],
        failed: results.OrdersError || [],
        success: results.OrdersSucessed || []
    };

    // Update counts
    document.getElementById('forcedCount').textContent = fastSaleResultsData.forced.length;
    document.getElementById('failedCount').textContent = fastSaleResultsData.failed.length;
    document.getElementById('successCount').textContent = fastSaleResultsData.success.length;

    // Render tables
    renderForcedOrdersTable();
    renderFailedOrdersTable();
    renderSuccessOrdersTable();

    // Show modal
    const modal = document.getElementById('fastSaleResultsModal');
    if (modal) {
        modal.style.display = 'flex';
    }

    // Switch to appropriate tab
    if (fastSaleResultsData.forced.length > 0) {
        switchResultsTab('forced');
    } else if (fastSaleResultsData.failed.length > 0) {
        switchResultsTab('failed');
    } else {
        switchResultsTab('success');
    }

    // Pre-generate bill images in background (don't await - run async)
    if (fastSaleResultsData.success.length > 0) {
        setTimeout(() => preGenerateBillImages(), 100);
    }
}

/**
 * Close Fast Sale Results Modal
 */
function closeFastSaleResultsModal() {
    const modal = document.getElementById('fastSaleResultsModal');
    if (modal) {
        modal.style.display = 'none';
    }

    // Close Fast Sale modal if still open
    closeFastSaleModal();

    // Refresh table
    selectedOrderIds.clear();
    updateActionButtons();
    if (typeof filterAndDisplayOrders === 'function') {
        filterAndDisplayOrders();
    }
}

/**
 * Switch between results tabs
 * @param {string} tabName - 'forced', 'failed', or 'success'
 */
function switchResultsTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.fast-sale-results-tab').forEach(tab => {
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update tab content
    document.querySelectorAll('.fast-sale-results-content').forEach(content => {
        if (content.id === `${tabName}Tab`) {
            content.classList.add('active');
        } else {
            content.classList.remove('active');
        }
    });
}

/**
 * Render Forced Orders Table (CÆ°á»¡ng bá»©c)
 */
function renderForcedOrdersTable() {
    const container = document.getElementById('forcedOrdersTable');
    if (!container) return;

    if (fastSaleResultsData.forced.length === 0) {
        container.innerHTML = '<p style="color: #6b7280; text-align: center; padding: 40px;">KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng cáº§n cÆ°á»¡ng bá»©c</p>';
        return;
    }

    const html = `
        <table class="fast-sale-results-table">
            <thead>
                <tr>
                    <th style="width: 40px;">#</th>
                    <th style="width: 40px;"><input type="checkbox" id="selectAllForced" onchange="toggleAllForcedOrders(this.checked)"></th>
                    <th>MÃ£</th>
                    <th>Sá»‘ phiáº¿u</th>
                    <th>KhÃ¡ch hÃ ng</th>
                    <th>Lá»—i</th>
                </tr>
            </thead>
            <tbody>
                ${fastSaleResultsData.forced.map((order, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td><input type="checkbox" class="forced-order-checkbox" value="${index}"></td>
                        <td>${order.Reference || 'N/A'}</td>
                        <td>${order.Number || ''}</td>
                        <td>${order.Partner?.PartnerDisplayName || order.PartnerDisplayName || 'N/A'}</td>
                        <td><div class="fast-sale-error-msg">${order.DeliveryNote || 'Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh'}</div></td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;

    container.innerHTML = html;
}

/**
 * Render Failed Orders Table (Tháº¥t báº¡i)
 */
function renderFailedOrdersTable() {
    const container = document.getElementById('failedOrdersTable');
    if (!container) return;

    if (fastSaleResultsData.failed.length === 0) {
        container.innerHTML = '<p style="color: #6b7280; text-align: center; padding: 40px;">KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng tháº¥t báº¡i</p>';
        return;
    }

    const html = `
        <table class="fast-sale-results-table">
            <thead>
                <tr>
                    <th style="width: 40px;">#</th>
                    <th>MÃ£</th>
                    <th>Sá»‘ phiáº¿u</th>
                    <th>KhÃ¡ch hÃ ng</th>
                    <th>Lá»—i</th>
                </tr>
            </thead>
            <tbody>
                ${fastSaleResultsData.failed.map((order, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${order.Reference || 'N/A'}</td>
                        <td>${order.Number || ''}</td>
                        <td>${order.Partner?.PartnerDisplayName || order.PartnerDisplayName || 'N/A'}</td>
                        <td><div class="fast-sale-error-msg">${order.DeliveryNote || 'Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh'}</div></td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;

    container.innerHTML = html;
}

/**
 * Render Success Orders Table (ThÃ nh cÃ´ng)
 */
function renderSuccessOrdersTable() {
    const container = document.getElementById('successOrdersTable');
    if (!container) return;

    if (fastSaleResultsData.success.length === 0) {
        container.innerHTML = '<p style="color: #6b7280; text-align: center; padding: 40px;">KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng thÃ nh cÃ´ng</p>';
        return;
    }

    const html = `
        <table class="fast-sale-results-table">
            <thead>
                <tr>
                    <th style="width: 40px;">#</th>
                    <th style="width: 40px;"><input type="checkbox" id="selectAllSuccess" onchange="toggleAllSuccessOrders(this.checked)"></th>
                    <th>MÃ£</th>
                    <th>Sá»‘ phiáº¿u</th>
                    <th>Tráº¡ng thÃ¡i</th>
                    <th>KhÃ¡ch hÃ ng</th>
                    <th>MÃ£ váº­n Ä‘Æ¡n</th>
                </tr>
            </thead>
            <tbody>
                ${fastSaleResultsData.success.map((order, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td><input type="checkbox" class="success-order-checkbox" value="${index}" data-order-id="${order.Id}"></td>
                        <td>${order.Reference || 'N/A'}</td>
                        <td>${order.Number || ''}</td>
                        <td><span style="color: #10b981; font-weight: 600;">âœ“ ${order.ShowState || 'Nháº­p'}</span></td>
                        <td>${order.Partner?.PartnerDisplayName || order.PartnerDisplayName || 'N/A'}</td>
                        <td>${order.TrackingRef || ''}</td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;

    container.innerHTML = html;
}

/**
 * Toggle all forced orders checkboxes
 * @param {boolean} checked
 */
function toggleAllForcedOrders(checked) {
    document.querySelectorAll('.forced-order-checkbox').forEach(cb => {
        cb.checked = checked;
    });
}

/**
 * Create Forced Orders (Táº¡o cÆ°á»¡ng bá»©c)
 */
async function createForcedOrders() {
    const selectedIndexes = Array.from(document.querySelectorAll('.forced-order-checkbox:checked'))
        .map(cb => parseInt(cb.value));

    if (selectedIndexes.length === 0) {
        window.notificationManager.warning('Vui lÃ²ng chá»n Ã­t nháº¥t 1 Ä‘Æ¡n hÃ ng Ä‘á»ƒ táº¡o cÆ°á»¡ng bá»©c', 'ThÃ´ng bÃ¡o');
        return;
    }

    const selectedOrders = selectedIndexes.map(i => fastSaleResultsData.forced[i]);

    try {
        const headers = await window.tokenManager.getAuthHeader();
        // Use isForce=true query parameter for forced creation
        const url = `https://chatomni-proxy.nhijudyshop.workers.dev/api/odata/FastSaleOrder/InsertListOrderModel?isForce=true&$expand=DataErrorFast($expand=Partner),OrdersError($expand=Partner),OrdersSucessed($expand=Partner)`;

        // Use is_approve: false with isForce=true for forced creation
        const requestBody = {
            is_approve: false,
            model: selectedOrders
        };

        const loadingNotif = window.notificationManager.info(
            `Äang táº¡o cÆ°á»¡ng bá»©c ${selectedIndexes.length} Ä‘Æ¡n hÃ ng...`,
            3000 // Auto-dismiss after 3 seconds
        );

        const response = await API_CONFIG.smartFetch(url, {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();
        console.log('[FAST-SALE] Force create result:', result);

        // Close loading notification
        if (loadingNotif && typeof loadingNotif.close === 'function') {
            loadingNotif.close();
        }

        // Show results in the same modal
        showFastSaleResultsModal(result);

        // Auto-switch to Success tab if there are successful orders
        if (result.OrdersSucessed && result.OrdersSucessed.length > 0) {
            setTimeout(() => {
                switchResultsTab('success');
            }, 100);
        }

        window.notificationManager.success(
            `ÄÃ£ táº¡o cÆ°á»¡ng bá»©c ${result.OrdersSucessed?.length || 0} Ä‘Æ¡n hÃ ng`,
            'ThÃ nh cÃ´ng'
        );

    } catch (error) {
        console.error('[FAST-SALE] Error creating forced orders:', error);

        // Close loading notification on error
        if (loadingNotif && typeof loadingNotif.close === 'function') {
            loadingNotif.close();
        }

        window.notificationManager.error(`Lá»—i khi táº¡o cÆ°á»¡ng bá»©c: ${error.message}`, 'Lá»—i');
    }
}

/**
 * Toggle all success orders checkboxes
 * @param {boolean} checked
 */
function toggleAllSuccessOrders(checked) {
    document.querySelectorAll('.success-order-checkbox').forEach(cb => {
        cb.checked = checked;
    });
}

/**
 * Print success orders (In hÃ³a Ä‘Æ¡n, In phiáº¿u ship, In soáº¡n hÃ ng)
 * @param {string} type - 'invoice', 'shipping', or 'picking'
 */
async function printSuccessOrders(type) {
    // Pre-generation runs in background - if cached data exists, use it; otherwise generate on-the-fly

    const selectedIndexes = Array.from(document.querySelectorAll('.success-order-checkbox:checked'))
        .map(cb => parseInt(cb.value));

    if (selectedIndexes.length === 0) {
        window.notificationManager.warning('Vui lÃ²ng chá»n Ã­t nháº¥t 1 Ä‘Æ¡n hÃ ng Ä‘á»ƒ in', 'ThÃ´ng bÃ¡o');
        return;
    }

    const selectedOrders = selectedIndexes.map(i => fastSaleResultsData.success[i]);
    const orderIds = selectedOrders.map(o => o.Id).filter(id => id);

    if (orderIds.length === 0) {
        window.notificationManager.error('KhÃ´ng tÃ¬m tháº¥y ID Ä‘Æ¡n hÃ ng Ä‘á»ƒ in', 'Lá»—i');
        return;
    }

    console.log(`[FAST-SALE] Printing ${type} for ${orderIds.length} orders:`, orderIds);

    // For invoice type, use custom bill and send to Messenger
    if (type === 'invoice') {
        console.log('[FAST-SALE] Using custom bill for invoice printing...');

        // Clear currentSaleOrderData to prevent old data interference
        currentSaleOrderData = null;

        // Collect all enriched orders and send tasks
        const enrichedOrders = [];
        const sendTasks = [];

        for (let i = 0; i < selectedOrders.length; i++) {
            const order = selectedOrders[i];

            // Find original order by matching SaleOnlineIds or Reference
            const originalOrderIndex = fastSaleOrdersData.findIndex(o =>
                (o.SaleOnlineIds && order.SaleOnlineIds &&
                    JSON.stringify(o.SaleOnlineIds) === JSON.stringify(order.SaleOnlineIds)) ||
                (o.Reference && o.Reference === order.Reference)
            );
            const originalOrder = originalOrderIndex >= 0 ? fastSaleOrdersData[originalOrderIndex] : null;

            // Also try to find saleOnline order from displayedData for additional data
            const saleOnlineId = order.SaleOnlineIds?.[0];
            const saleOnlineOrderForData = saleOnlineId
                ? displayedData.find(o => o.Id === saleOnlineId || String(o.Id) === String(saleOnlineId))
                : null;

            // Get CarrierName from form dropdown (same logic as collectFastSaleData)
            const carrierSelect = originalOrderIndex >= 0 ? document.getElementById(`fastSaleCarrier_${originalOrderIndex}`) : null;
            const carrierNameFromDropdown = carrierSelect?.options[carrierSelect.selectedIndex]?.text || '';
            // Fallback chain: dropdown > originalOrder.Carrier.Name > order.CarrierName > order.Carrier.Name
            const carrierName = carrierNameFromDropdown ||
                originalOrder?.Carrier?.Name ||
                originalOrder?.CarrierName ||
                order.CarrierName ||
                order.Carrier?.Name ||
                '';
            const shippingFee = originalOrderIndex >= 0
                ? parseFloat(document.getElementById(`fastSaleShippingFee_${originalOrderIndex}`)?.value) || 0
                : order.DeliveryPrice || 0;

            // Get OrderLines - priority: originalOrder (from FastSale API) > saleOnlineOrder.Details > order.OrderLines
            let orderLines = originalOrder?.OrderLines || order.OrderLines || [];
            if ((!orderLines || orderLines.length === 0) && saleOnlineOrderForData?.Details) {
                // Map saleOnline Details to OrderLines format
                orderLines = saleOnlineOrderForData.Details.map(d => ({
                    ProductName: d.ProductName || d.ProductNameGet || '',
                    ProductNameGet: d.ProductNameGet || d.ProductName || '',
                    ProductUOMQty: d.Quantity || d.ProductUOMQty || 1,
                    Quantity: d.Quantity || d.ProductUOMQty || 1,
                    PriceUnit: d.Price || d.PriceUnit || 0,
                    Note: d.Note || ''
                }));
            }

            // Merge data: API result + original OrderLines + form values
            const enrichedOrder = {
                ...order,
                OrderLines: orderLines,
                CarrierName: carrierName,
                DeliveryPrice: shippingFee,
                PartnerDisplayName: order.PartnerDisplayName || originalOrder?.PartnerDisplayName || '',
            };

            enrichedOrders.push(enrichedOrder);

            console.log('[FAST-SALE] Enriched order for bill:', {
                number: enrichedOrder.Number,
                carrierName: enrichedOrder.CarrierName,
                orderLinesCount: enrichedOrder.OrderLines?.length
            });

            // Find saleOnline order for chat info
            let saleOnlineOrder = saleOnlineOrderForData;
            const saleOnlineName = order.SaleOnlineNames?.[0];
            if (!saleOnlineOrder && saleOnlineName) {
                saleOnlineOrder = displayedData.find(o => o.Code === saleOnlineName);
            }
            if (!saleOnlineOrder && order.PartnerId) {
                saleOnlineOrder = displayedData.find(o => o.PartnerId === order.PartnerId);
            }

            // DEBUG: Log customer matching info
            console.log('[FAST-SALE] DEBUG - Customer matching for order:', order.Number, {
                saleOnlineId,
                saleOnlineName,
                partnerId: order.PartnerId,
                foundSaleOnlineOrder: !!saleOnlineOrder,
                saleOnlineOrderId: saleOnlineOrder?.Id,
                saleOnlineOrderName: saleOnlineOrder?.Name,
                saleOnlineOrderCode: saleOnlineOrder?.Code,
                Facebook_ASUserId: saleOnlineOrder?.Facebook_ASUserId,
                Facebook_PostId: saleOnlineOrder?.Facebook_PostId
            });

            // Prepare send task for this customer
            if (saleOnlineOrder) {
                const psid = saleOnlineOrder.Facebook_ASUserId;
                const postId = saleOnlineOrder.Facebook_PostId;
                const channelId = postId ? postId.split('_')[0] : null;

                console.log('[FAST-SALE] DEBUG - Send task check:', {
                    orderNumber: order.Number,
                    customerName: saleOnlineOrder.Name,
                    psid,
                    postId,
                    channelId,
                    willAddToSendTasks: !!(psid && channelId)
                });

                if (psid && channelId) {
                    console.log('[FAST-SALE] Will send bill to:', saleOnlineOrder.Name, 'for order:', order.Number);
                    sendTasks.push({
                        enrichedOrder,
                        channelId,
                        psid,
                        customerName: saleOnlineOrder.Name,
                        orderNumber: order.Number
                    });
                } else {
                    console.warn('[FAST-SALE] âš ï¸ Missing psid or channelId for order:', order.Number, {
                        psid: psid || 'MISSING',
                        channelId: channelId || 'MISSING'
                    });
                }
            } else {
                console.warn('[FAST-SALE] âš ï¸ No saleOnlineOrder found for order:', order.Number);
            }
        }

        // DEBUG: Summary of collected data
        console.log('[FAST-SALE] DEBUG - Collection summary:', {
            selectedOrdersCount: selectedOrders.length,
            enrichedOrdersCount: enrichedOrders.length,
            sendTasksCount: sendTasks.length,
            sendTasksDetails: sendTasks.map(t => ({ orderNumber: t.orderNumber, customer: t.customerName, psid: t.psid }))
        });

        // 1. Open ONE combined print popup with all bills
        if (enrichedOrders.length > 0) {
            console.log('[FAST-SALE] Opening combined print popup for', enrichedOrders.length, 'bills...');
            openCombinedPrintPopup(enrichedOrders);
        }

        // 3. Clear main table checkboxes after printing
        console.log('[FAST-SALE] Clearing main table checkboxes after print...');
        selectedOrderIds.clear();
        // Uncheck all checkboxes in main table
        document.querySelectorAll('#ordersTable input[type="checkbox"]:checked').forEach(cb => {
            cb.checked = false;
        });
        // Also uncheck header checkbox
        const headerCheckbox = document.querySelector('#ordersTable thead input[type="checkbox"]');
        if (headerCheckbox) headerCheckbox.checked = false;
        // Update action buttons visibility
        updateActionButtons();

        // 2. Send all bills to Messenger in PARALLEL
        if (sendTasks.length > 0) {
            console.log('[FAST-SALE] Sending', sendTasks.length, 'bills to Messenger in parallel...');
            window.notificationManager.info(`Äang gá»­i ${sendTasks.length} bill qua Messenger...`, 3000);

            const sendPromises = sendTasks.map(task => {
                // Check for pre-generated bill data
                const orderId = task.enrichedOrder?.Id;
                const orderNumber = task.enrichedOrder?.Number;
                const cachedData = window.preGeneratedBillData?.get(orderId) ||
                    window.preGeneratedBillData?.get(orderNumber);

                const sendOptions = {};
                if (cachedData && cachedData.contentUrl && cachedData.contentId) {
                    console.log(`[FAST-SALE] âš¡ Using pre-generated bill for ${task.orderNumber}`);
                    sendOptions.preGeneratedContentUrl = cachedData.contentUrl;
                    sendOptions.preGeneratedContentId = cachedData.contentId;
                }

                return sendBillToCustomer(task.enrichedOrder, task.channelId, task.psid, sendOptions)
                    .then(res => {
                        if (res.success) {
                            console.log(`[FAST-SALE] âœ… Bill sent for ${task.orderNumber} to ${task.customerName}`);
                            return { success: true, orderNumber: task.orderNumber, customerName: task.customerName };
                        } else {
                            console.warn(`[FAST-SALE] âš ï¸ Failed to send bill for ${task.orderNumber}:`, res.error);
                            return { success: false, orderNumber: task.orderNumber, error: res.error };
                        }
                    })
                    .catch(err => {
                        console.error(`[FAST-SALE] âŒ Error sending bill for ${task.orderNumber}:`, err);
                        return { success: false, orderNumber: task.orderNumber, error: err.message };
                    });
            });

            // Wait for all sends to complete
            Promise.all(sendPromises).then(results => {
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;

                if (successCount > 0) {
                    window.notificationManager.success(`ÄÃ£ gá»­i ${successCount}/${results.length} bill qua Messenger`, 3000);
                }
                if (failCount > 0) {
                    window.notificationManager.warning(`${failCount} bill gá»­i tháº¥t báº¡i`, 3000);
                }
            });
        }

        return;
    }

    // For shipping and picking types, use TPOS API
    try {
        const headers = await window.tokenManager.getAuthHeader();
        const idsParam = orderIds.join(',');

        let printEndpoint = '';
        let printLabel = '';

        // Determine endpoint based on print type
        if (type === 'shipping') {
            printEndpoint = 'print2'; // In phiáº¿u ship
            printLabel = 'phiáº¿u ship';
        } else if (type === 'picking') {
            printEndpoint = 'print3'; // In soáº¡n hÃ ng
            printLabel = 'soáº¡n hÃ ng';
        }

        const url = `https://chatomni-proxy.nhijudyshop.workers.dev/api/fastsaleorder/${printEndpoint}?ids=${idsParam}`;

        console.log(`[FAST-SALE] Fetching print HTML from: ${url}`);

        // Show loading notification
        const loadingNotif = window.notificationManager.info(
            `Äang chuáº©n bá»‹ in ${printLabel}...`,
            3000
        );

        // Fetch the print HTML
        const response = await API_CONFIG.smartFetch(url, {
            method: 'GET',
            headers: {
                ...headers,
                'Accept': 'application/json, text/javascript, */*; q=0.01'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();
        console.log('[FAST-SALE] Print response:', result);

        // Close loading notification
        if (loadingNotif && typeof loadingNotif.close === 'function') {
            loadingNotif.close();
        }

        // Check for errors
        if (result.listErrors && result.listErrors.length > 0) {
            window.notificationManager.error(
                `Lá»—i khi in: ${result.listErrors.join(', ')}`,
                'Lá»—i'
            );
            return;
        }

        // Open new window and write HTML
        if (result.html) {
            const printWindow = window.open('', '_blank');
            if (printWindow) {
                printWindow.document.write(result.html);
                printWindow.document.close();

                // Use both onload and setTimeout for reliability
                let printed = false;

                printWindow.onload = function () {
                    if (!printed) {
                        printed = true;
                        printWindow.focus();
                        printWindow.print();
                    }
                };

                // Fallback timeout in case onload doesn't fire
                setTimeout(() => {
                    if (!printed) {
                        printed = true;
                        printWindow.focus();
                        printWindow.print();
                    }
                }, 1000); // Increased to 1000ms for complex HTML

                window.notificationManager.success(
                    `ÄÃ£ má»Ÿ cá»­a sá»• in ${printLabel} cho ${orderIds.length} Ä‘Æ¡n hÃ ng`,
                    2000
                );
            } else {
                window.notificationManager.error(
                    'KhÃ´ng thá»ƒ má»Ÿ cá»­a sá»• in. Vui lÃ²ng kiá»ƒm tra popup blocker',
                    'Lá»—i'
                );
            }
        } else {
            window.notificationManager.error(
                'KhÃ´ng nháº­n Ä‘Æ°á»£c HTML Ä‘á»ƒ in',
                'Lá»—i'
            );
        }

    } catch (error) {
        console.error('[FAST-SALE] Error printing orders:', error);

        // Better error message extraction
        let errorMessage = 'KhÃ´ng xÃ¡c Ä‘á»‹nh';
        if (error instanceof Error) {
            errorMessage = error.message;
        } else if (typeof error === 'string') {
            errorMessage = error;
        } else if (error && error.toString) {
            errorMessage = error.toString();
        }

        window.notificationManager.error(
            `Lá»—i khi in: ${errorMessage}`,
            'Lá»—i'
        );
    }
}

// Make functions globally accessible
window.showFastSaleModal = showFastSaleModal;
window.closeFastSaleModal = closeFastSaleModal;
window.confirmFastSale = confirmFastSale;
window.confirmAndCheckFastSale = confirmAndCheckFastSale;
window.updateFastSaleShippingFee = updateFastSaleShippingFee;
window.showFastSaleResultsModal = showFastSaleResultsModal;
window.closeFastSaleResultsModal = closeFastSaleResultsModal;
window.switchResultsTab = switchResultsTab;
window.toggleAllForcedOrders = toggleAllForcedOrders;
window.toggleAllSuccessOrders = toggleAllSuccessOrders;
window.createForcedOrders = createForcedOrders;
window.printSuccessOrders = printSuccessOrders;

// #endregion FAST SALE MODAL

// #region BILL TEMPLATE SETTINGS

/**
 * Default bill template settings
 */
const defaultBillSettings = {
    // General
    shopName: '',
    shopPhone: '',
    shopAddress: '',
    billTitle: 'PHIáº¾U BÃN HÃ€NG',
    footerText: 'Cáº£m Æ¡n quÃ½ khÃ¡ch! Háº¹n gáº·p láº¡i!',
    // Sections visibility
    showHeader: true,
    showTitle: true,
    showSTT: true,
    showBarcode: true,
    showOrderInfo: true,
    showCarrier: true,
    showCustomer: true,
    showSeller: true,
    showProducts: true,
    showTotals: true,
    showCOD: true,
    showDeliveryNote: true,
    showFooter: true,
    // Style
    fontShopName: 18,
    fontTitle: 16,
    fontContent: 13,
    fontCOD: 18,
    billWidth: '80mm',
    billPadding: 20,
    codBackground: '#fef3c7',
    codBorder: '#f59e0b'
};

/**
 * Get bill template settings from localStorage
 */
function getBillTemplateSettings() {
    try {
        const saved = localStorage.getItem('billTemplateSettings');
        if (saved) {
            return { ...defaultBillSettings, ...JSON.parse(saved) };
        }
    } catch (e) {
        console.error('[BILL-SETTINGS] Error loading settings:', e);
    }
    return { ...defaultBillSettings };
}

/**
 * Open bill template settings modal
 */
function openBillTemplateSettings() {
    const modal = document.getElementById('billTemplateSettingsModal');
    if (modal) {
        modal.style.display = 'flex';
        loadBillSettingsToForm();
    }
}

/**
 * Close bill template settings modal
 */
function closeBillTemplateSettings() {
    const modal = document.getElementById('billTemplateSettingsModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

/**
 * Switch between settings tabs
 */
function switchBillSettingsTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.bill-settings-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabName);
    });
    // Update content
    document.querySelectorAll('.bill-settings-content').forEach(content => {
        content.style.display = 'none';
    });
    const tabMap = {
        'general': 'billSettingsGeneral',
        'sections': 'billSettingsSections',
        'style': 'billSettingsStyle',
        'preview': 'billSettingsPreview'
    };
    const targetContent = document.getElementById(tabMap[tabName]);
    if (targetContent) {
        targetContent.style.display = 'block';
    }
}

/**
 * Load settings to form
 */
function loadBillSettingsToForm() {
    const settings = getBillTemplateSettings();
    // General
    document.getElementById('billShopName').value = settings.shopName || '';
    document.getElementById('billShopPhone').value = settings.shopPhone || '';
    document.getElementById('billShopAddress').value = settings.shopAddress || '';
    document.getElementById('billTitle').value = settings.billTitle || 'PHIáº¾U BÃN HÃ€NG';
    document.getElementById('billFooterText').value = settings.footerText || '';
    // Sections
    document.getElementById('billShowHeader').checked = settings.showHeader !== false;
    document.getElementById('billShowTitle').checked = settings.showTitle !== false;
    document.getElementById('billShowSTT').checked = settings.showSTT !== false;
    document.getElementById('billShowBarcode').checked = settings.showBarcode !== false;
    document.getElementById('billShowOrderInfo').checked = settings.showOrderInfo !== false;
    document.getElementById('billShowCarrier').checked = settings.showCarrier !== false;
    document.getElementById('billShowCustomer').checked = settings.showCustomer !== false;
    document.getElementById('billShowSeller').checked = settings.showSeller !== false;
    document.getElementById('billShowProducts').checked = settings.showProducts !== false;
    document.getElementById('billShowTotals').checked = settings.showTotals !== false;
    document.getElementById('billShowCOD').checked = settings.showCOD !== false;
    document.getElementById('billShowDeliveryNote').checked = settings.showDeliveryNote !== false;
    document.getElementById('billShowFooter').checked = settings.showFooter !== false;
    // Style
    document.getElementById('billFontShopName').value = settings.fontShopName || 18;
    document.getElementById('billFontTitle').value = settings.fontTitle || 16;
    document.getElementById('billFontContent').value = settings.fontContent || 13;
    document.getElementById('billFontCOD').value = settings.fontCOD || 18;
    document.getElementById('billWidth').value = settings.billWidth || '80mm';
    document.getElementById('billPadding').value = settings.billPadding || 20;
    document.getElementById('billCODBackground').value = settings.codBackground || '#fef3c7';
    document.getElementById('billCODBorder').value = settings.codBorder || '#f59e0b';
}

/**
 * Save bill template settings
 */
function saveBillTemplateSettings() {
    const settings = {
        // General
        shopName: document.getElementById('billShopName').value.trim(),
        shopPhone: document.getElementById('billShopPhone').value.trim(),
        shopAddress: document.getElementById('billShopAddress').value.trim(),
        billTitle: document.getElementById('billTitle').value.trim() || 'PHIáº¾U BÃN HÃ€NG',
        footerText: document.getElementById('billFooterText').value.trim(),
        // Sections
        showHeader: document.getElementById('billShowHeader').checked,
        showTitle: document.getElementById('billShowTitle').checked,
        showSTT: document.getElementById('billShowSTT').checked,
        showBarcode: document.getElementById('billShowBarcode').checked,
        showOrderInfo: document.getElementById('billShowOrderInfo').checked,
        showCarrier: document.getElementById('billShowCarrier').checked,
        showCustomer: document.getElementById('billShowCustomer').checked,
        showSeller: document.getElementById('billShowSeller').checked,
        showProducts: document.getElementById('billShowProducts').checked,
        showTotals: document.getElementById('billShowTotals').checked,
        showCOD: document.getElementById('billShowCOD').checked,
        showDeliveryNote: document.getElementById('billShowDeliveryNote').checked,
        showFooter: document.getElementById('billShowFooter').checked,
        // Style
        fontShopName: parseInt(document.getElementById('billFontShopName').value) || 18,
        fontTitle: parseInt(document.getElementById('billFontTitle').value) || 16,
        fontContent: parseInt(document.getElementById('billFontContent').value) || 13,
        fontCOD: parseInt(document.getElementById('billFontCOD').value) || 18,
        billWidth: document.getElementById('billWidth').value || '80mm',
        billPadding: parseInt(document.getElementById('billPadding').value) || 20,
        codBackground: document.getElementById('billCODBackground').value || '#fef3c7',
        codBorder: document.getElementById('billCODBorder').value || '#f59e0b'
    };

    try {
        localStorage.setItem('billTemplateSettings', JSON.stringify(settings));
        window.notificationManager.success('ÄÃ£ lÆ°u cÃ i Ä‘áº·t bill template', 2000);
        closeBillTemplateSettings();
    } catch (e) {
        console.error('[BILL-SETTINGS] Error saving settings:', e);
        window.notificationManager.error('Lá»—i khi lÆ°u cÃ i Ä‘áº·t', 2000);
    }
}

/**
 * Reset bill template settings to default
 */
function resetBillTemplateSettings() {
    localStorage.removeItem('billTemplateSettings');
    loadBillSettingsToForm();
    window.notificationManager.info('ÄÃ£ Ä‘áº·t láº¡i cÃ i Ä‘áº·t máº·c Ä‘á»‹nh', 2000);
}

/**
 * Preview bill template with sample data
 */
function previewBillTemplate() {
    const sampleOrder = {
        Number: 'NJD/2026/SAMPLE',
        PartnerDisplayName: 'Nguyá»…n VÄƒn A',
        Partner: { Name: 'Nguyá»…n VÄƒn A', Phone: '0901234567', Street: '123 ÄÆ°á»ng ABC, Quáº­n 1, TP.HCM' },
        CarrierName: 'Giao hÃ ng nhanh (GHN)',
        DeliveryPrice: 25000,
        CashOnDelivery: 350000,
        AmountDeposit: 50000,
        Discount: 10000,
        Ship_Note: 'Gá»i trÆ°á»›c khi giao. Ship COD.',
        SessionIndex: '123',
        OrderLines: [
            { ProductName: 'Ão thun nam size L', Quantity: 2, PriceUnit: 150000 },
            { ProductName: 'Quáº§n jean ná»¯ size M', Quantity: 1, PriceUnit: 250000, Note: 'MÃ u xanh Ä‘áº­m' }
        ]
    };

    const html = window.generateCustomBillHTML(sampleOrder, {});
    const container = document.getElementById('billPreviewContainer');
    if (container) {
        container.innerHTML = `<div style="background: white; padding: 10px; max-width: 320px; margin: 0 auto; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">${html}</div>`;
    }
}

// Make functions globally accessible
window.openBillTemplateSettings = openBillTemplateSettings;
window.closeBillTemplateSettings = closeBillTemplateSettings;
window.switchBillSettingsTab = switchBillSettingsTab;
window.saveBillTemplateSettings = saveBillTemplateSettings;
window.resetBillTemplateSettings = resetBillTemplateSettings;
window.previewBillTemplate = previewBillTemplate;
window.getBillTemplateSettings = getBillTemplateSettings;

// #endregion BILL TEMPLATE SETTINGS
